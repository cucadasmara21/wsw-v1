LEY I â€” Identidad TopolÃ³gica: Puntero en la Red Morton, Linaje por Epoch y Contrato Binario de Unicidad

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO 0 â€” Principios de No-NegociaciÃ³n (Axiomas de Identidad)
3. ARTÃCULO I â€” Principio de Identidad UnÃ­voca: El Invariante TopolÃ³gico Fundamental
4. ARTÃCULO II â€” DefiniciÃ³n del Identificador Universal (UID64) y ComposiciÃ³n Bitwise
5. ARTÃCULO III â€” El Puntero Morton: MÃ©trica TopolÃ³gica, Interleaving y Superioridad MecÃ¡nica
6. ARTÃCULO IV â€” Unicidad, Determinismo y No-ColisiÃ³n Constitucional
7. ARTÃCULO V â€” Localidad Espacial, Coherencia de CachÃ© y SoA SIMD-Friendly
8. ARTÃCULO VI â€” IntegraciÃ³n con Vertex28 y Meta32: ManifestaciÃ³n FÃ­sica de Identidad
9. ARTÃCULO VII â€” ImplementaciÃ³n de Bajo Nivel (PseudocÃ³digo Ejecutable, Lock-Free, Branchless, SIMD-Friendly)
10. ARTÃCULO VIII â€” Modelo de Coste y Presupuesto de Rendimiento (Kernels de Identidad)
11. ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 Soberano para Identidad)
12. ARTÃCULO X â€” Persistencia, SerializaciÃ³n y VerificaciÃ³n de Integridad
13. ARTÃCULO XI â€” Conexiones Inter-Ley (Identidad como Sujeto Inmutable)
14. ARTÃCULO XII â€” Ruta SIMD/Branchless para Identidad y Locality-Hint
15. ARTÃCULO XIII â€” Pruebas Deterministas y MediciÃ³n (Identidad sin AmbigÃ¼edad)
16. ARTÃCULO XIV â€” AXIOMA FINAL
17. AXIOMA FINAL

Ãmbito
Universo N = 200,000; 16.67ms/frame; cero micro-stuttering; bus final Vertex28 (stride 28 bytes); integraciÃ³n estricta con Ley III (Vertex28/Meta32) + Ley IV (Manifold/Langevin) + Ley V (Tsallis/TSD/ALFAâ€“SIGMAâ€“OMEGA) + Ley VI (OrÃ¡culo/ataque/cuarentena) + Ley VII (UID64/Atlas SoA/DNA_PACK/SENT8) + Ley VIII (OMEGA-ZERO/VoidPool/ReencarnaciÃ³n lock-free) + Ley IX (Masa MÃ­nima / Horizonte).

LEY I â€” Identidad TopolÃ³gica: Puntero en la Red Morton, Linaje por Epoch y Contrato Binario de Unicidad

Dictamen de dominio: la Identidad es mecÃ¡nica, no semÃ¡ntica. En TITAN V8, â€œconocerâ€ un activo significa poder direccionarlo O(1) sin locks, sin strings y sin ambigÃ¼edad, y poder invalidar referencias obsoletas sin stutter.

ARTÃCULO 0 â€” Principios de No-NegociaciÃ³n (Axiomas de Identidad)

0.1. Identidad â‰  nombre: ningÃºn componente del hot-loop consume tickers, strings o claves externas. La Ãºnica identidad operativa es binaria: UID64 (Ley VII), Meta32 (Ley III/IX) y posiciÃ³n topolÃ³gica Morton32 (Ley I/III).
0.2. El slot es el Ã¡tomo del silicio: el direccionamiento fÃ­sico de SoA y VBO es un Ã­ndice SLOT32 en
[
0
,
ğ‘
âˆ’
1
]
[0,Nâˆ’1], implÃ­cito por offset; no se serializa en texto, no se negocia, no se realoca.
0.3. Unicidad verificable: toda identidad debe ser verificable con un test binario O(1) (epoch + checksum/CRC) y fallar de forma determinista: stale â‡’ invÃ¡lido â‡’ invisible â‡’ purga.
0.4. Anti-ABA constitucional: ninguna referencia antigua puede re-apuntar a un inquilino nuevo tras reencarnaciÃ³n (Ley VIII). La soluciÃ³n soberana es epoch en UID64 + verificaciÃ³n de integridad + commit con release/acquire.
0.5. TopologÃ­a antes que semÃ¡ntica: la â€œred Mortonâ€ es el tejido donde la identidad existe fÃ­sicamente. Todo lo demÃ¡s es campo derivado (DNA, SENT, riesgo, shock).

ARTÃCULO I â€” Principio de Identidad UnÃ­voca: El Invariante TopolÃ³gico Fundamental

I.1. Axioma de Identidad CuÃ¡ntica (invariante topolÃ³gico):
Se define la Identidad de TITAN V8 como un invariante topolÃ³gico del silicio: no depende del valor econÃ³mico, del nombre del activo ni de la trayectoria. Es el hecho de ocupar un nodo direccionable del manifold discreto y poseer un handle verificable. Formalmente, para un activo vivo
ğ‘–
i en frame
ğ‘¡
t:

ğ¼
ğ‘–
(
ğ‘¡
)
â‰¡
âŸ¨
ğ‘ˆ
ğ¼
ğ·
64
ğ‘–
(
ğ‘¡
)
,

ğ‘š
ğ‘–
(
ğ‘¡
)
,

ğ‘š
ğ‘’
ğ‘¡
ğ‘
32
ğ‘–
(
ğ‘¡
)
âŸ©
I
i
	â€‹

(t)â‰¡âŸ¨UID64
i
	â€‹

(t),m
i
	â€‹

(t),meta32
i
	â€‹

(t)âŸ©

donde
ğ‘š
ğ‘–
(
ğ‘¡
)
m
i
	â€‹

(t) es Morton32 (posiciÃ³n topolÃ³gica), y
ğ‘š
ğ‘’
ğ‘¡
ğ‘
32
ğ‘–
(
ğ‘¡
)
meta32
i
	â€‹

(t) gobierna su pertenencia fÃ­sica/consenso por mÃ¡scara (Ley IX).
Invariante: si un handle
ğ‘ˆ
ğ¼
ğ·
64
UID64 es vÃ¡lido en
ğ‘¡
t, entonces su resoluciÃ³n produce un Ãºnico slot fÃ­sico
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
SLOT32 en el Atlas y ese slot pertenece a exactamente un inquilino vivo; si el inquilino muere y reencarna, el epoch cambia y el handle antiguo se vuelve invÃ¡lido.

I.2. Identidad como â€œpunteroâ€ en la red Morton:
La red Morton define un orden Z (Z-order) sobre el manifold cuantizado. El â€œpunteroâ€ de identidad no es un nombre: es un ancla topolÃ³gica. TITAN V8 decide vecindad, agregaciÃ³n y batching por proximidad en Morton, no por taxonomÃ­a narrativa. El activo â€œexisteâ€ fÃ­sicamente si su estado satisface:

L
I
V
E
ğ‘–
(
ğ‘¡
)
=
1
[
(
ğ‘š
ğ‘’
ğ‘¡
ğ‘
32
ğ‘–
(
ğ‘¡
)

&

ğ‘€
ğ´
ğ‘†
ğ¾
_
ğ‘†
ğ¾
ğ¼
ğ‘ƒ
_
ğ‘ƒ
ğ»
ğ‘Œ
ğ‘†
)
=
0
]
LIVE
i
	â€‹

(t)=1[(meta32
i
	â€‹

(t)&MASK_SKIP_PHYS)=0]

y su orden topolÃ³gico se define por
ğ‘š
ğ‘–
(
ğ‘¡
)
m
i
	â€‹

(t). La identidad se manifiesta como coherencia de direccionamiento: el mismo slot produce el mismo paquete binario (UID64, DNA, SENT) hasta su muerte; en reencarnaciÃ³n, el slot permanece y el epoch invalida el pasado.

I.3. Unicidad y determinismo bajo reencarnaciÃ³n y concurrencia:
La unicidad se impone en dos capas:

Capa lÃ³gica:
ğ‘ˆ
ğ¼
ğ·
64
UID64 no colisiona con ningÃºn
ğ‘ˆ
ğ¼
ğ·
64
UID64 vivo (Ley VII: Cuckoo/Atlas).

Capa temporal: el campo VER16 (epoch) diferencia generaciones; dos inquilinos distintos no comparten
(
ğ»
ğ¼
ğ·
32
,
ğ¹
ğ´
ğ‘€
16
,
ğ‘‰
ğ¸
ğ‘…
16
)
(HID32,FAM16,VER16) mientras exista el sistema.
Regla soberana: todo nacimiento incrementa epoch del slot antes del commit; toda resoluciÃ³n exige epoch exacto, o es stale.

ARTÃCULO II â€” DefiniciÃ³n del Identificador Universal (UID64) y ComposiciÃ³n Bitwise

II.1. Estructura canÃ³nica (inmutable por Ley VII):

ğ‘ˆ
ğ¼
ğ·
64
=
[
ğ»
ğ¼
ğ·
32
âˆ£
ğ¹
ğ´
ğ‘€
16
âˆ£
ğ‘‰
ğ¸
ğ‘…
16
]
UID64=[HID32âˆ£FAM16âˆ£VER16]

HID32: identidad lÃ³gica compacta (hash/linaje/rasgos mÃ­nimos).

FAM16: familia de hashing y control de integridad (bucket-seed + CRC).

VER16: epoch de generaciÃ³n anti-ABA (no string, no contador global infinito).

II.2. Sub-layout soberano dentro de HID32 (sin romper Ley VII):
HID32 se dicta como contenedor de topologÃ­a gruesa + tipo + mezcla (no como Morton completo, sino como ancla estadÃ­stica para locality-hint y defensa anti-colisiÃ³n):

ğ»
ğ¼
ğ·
32
â‰¡
[
ğ‘€
12
âˆ£
ğ‘‡
6
âˆ£
ğº
8
âˆ£
ğ»
6
]
HID32â‰¡[M12âˆ£T6âˆ£G8âˆ£H6]

ğ‘€
12
M12: 12 bits de Morton-coarse (p.ej. bits altos de Morton32 o hash de celda) para locality-hint en tablas auxiliares.

ğ‘‡
6
T6: tipo compacto (0..63) para clases fÃ­sicas/mercado si aplica.

ğº
8
G8: generaciÃ³n corta (0..255) redundante (refuerzo anti-stale rÃ¡pido); la verdad temporal soberana es VER16, pero
ğº
8
G8 acelera filtros.

ğ»
6
H6: checksum/mezcla de baja entropÃ­a (no seguridad criptogrÃ¡fica; integridad mÃ­nima branchless).

II.3. Sub-layout soberano dentro de FAM16:

ğ¹
ğ´
ğ‘€
16
â‰¡
[
ğ¶
ğ‘…
ğ¶
4
âˆ£
ğ¹
12
]
FAM16â‰¡[CRC4âˆ£F12]

CRC4: verificaciÃ³n mÃ­nima de integridad del handle (detecta corrupciÃ³n/bit-flip).

F12: selector de familia/bucket seed para Cuckoo y dispersiÃ³n uniforme.

II.4. VER16 (epoch) â€” regla de incremento y wrap:
Sea
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
âˆˆ
[
0
,
65535
]
epoch[SLOT32]âˆˆ[0,65535] almacenado en SoA u16. En cada reencarnaciÃ³n exitosa del slot:

ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
â†
(
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
+
1
)

m
o
d

2
16
,
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
â‰ 
0
epochâ†(epoch+1)mod2
16
,epoch
î€ 
=0

Regla: epoch nunca toma 0; si el wrap produce 0, se incrementa a 1 (sentinela de â€œno-epochâ€ prohibido).
DetecciÃ³n anti-ABA: un handle stale se define por:

S
T
A
L
E
(
ğ‘ˆ
ğ¼
ğ·
64
,
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
)
=
1
[
ğ‘‰
ğ¸
ğ‘…
16
(
ğ‘ˆ
ğ¼
ğ·
64
)
â‰ 
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
]
STALE(UID64,SLOT32)=1[VER16(UID64)
î€ 
=epoch[SLOT32]]

II.5. Diagrama bit-a-bit (endianness neutral):

UID64:  [63..........................................................0]
        [ HID32 (32) ][  FAM16 (16) ][        VER16 (16)              ]

HID32:  [31........0] = [ M12 | T6 | G8 | H6 ]
FAM16:  [15........0] = [ CRC4 | F12 ]
VER16:  epoch16 (anti-ABA)

ARTÃCULO III â€” El Puntero Morton: MÃ©trica TopolÃ³gica, Interleaving y Superioridad MecÃ¡nica

III.1. Manifold discreto y cuantizaciÃ³n float32-safe:
Se define cuantizaciÃ³n por eje con
ğ‘
=
10
b=10 bits (rejilla 1024) en NDC-safe:

ğ‘
(
ğœ‰
)
=
c
l
a
m
p
[
0
,
2
ğ‘
âˆ’
1
]
(
âŒŠ
(
ğœ‰
â‹…
0.5
+
0.5
)
â‹…
(
2
ğ‘
âˆ’
1
)
âŒ‹
)
q(Î¾)=clamp
[0,2
b
âˆ’1]
	â€‹

(âŒŠ(Î¾â‹…0.5+0.5)â‹…(2
b
âˆ’1)âŒ‹)
(
ğ‘¥
ğ‘
,
ğ‘¦
ğ‘
,
ğ‘§
ğ‘
)
=
(
ğ‘
(
ğ‘¥
)
,
ğ‘
(
ğ‘¦
)
,
ğ‘
(
ğ‘§
)
)
(x
q
	â€‹

,y
q
	â€‹

,z
q
	â€‹

)=(q(x),q(y),q(z))

III.2. Morton32 por entrelazado (Z-order):

ğ‘š
=
i
n
t
e
r
l
e
a
v
e
(
ğ‘¥
ğ‘
,
ğ‘¦
ğ‘
,
ğ‘§
ğ‘
)
m=interleave(x
q
	â€‹

,y
q
	â€‹

,z
q
	â€‹

)

donde el entrelazado toma bits
(
ğ‘¥
ğ‘˜
,
ğ‘¦
ğ‘˜
,
ğ‘§
ğ‘˜
)
(x
k
	â€‹

,y
k
	â€‹

,z
k
	â€‹

) y produce:

ğ‘š
=
âˆ‘
ğ‘˜
=
0
ğ‘
âˆ’
1
(
(
ğ‘¥
ğ‘˜
â‰ª
(
3
ğ‘˜
)
)

âˆ£

(
ğ‘¦
ğ‘˜
â‰ª
(
3
ğ‘˜
+
1
)
)

âˆ£

(
ğ‘§
ğ‘˜
â‰ª
(
3
ğ‘˜
+
2
)
)
)
m=
k=0
âˆ‘
bâˆ’1
	â€‹

((x
k
	â€‹

â‰ª(3k))âˆ£(y
k
	â€‹

â‰ª(3k+1))âˆ£(z
k
	â€‹

â‰ª(3k+2)))

y caben
3
ğ‘
=
30
3b=30 bits; los 2 bits altos restantes se reservan a estratos si se requiere (LOD-zone), sin afectar a la topologÃ­a bÃ¡sica.

III.3. Por quÃ© Morton (y no Hilbert) bajo ConstituciÃ³n TITAN:

Morton se implementa con bit-masks y shifts: branchless, SIMD-friendly, coste fijo.

Hilbert requiere rotaciones/estado dependiente del prefijo; introduce dependencia de control â‡’ peor vectorizaciÃ³n y peor predictibilidad.

En TITAN, la prioridad es tiempo fijo y dispatch uniforme. Morton es el compromiso soberano entre locality y coste determinista.

III.4. Morton como red: vecindad y batching:
Sea
ğœ‹
(
ğ‘¡
)
Ï€(t) una permutaciÃ³n de slots por Morton (orden ascendente de
ğ‘š
m). Entonces, para cualquier kernel que haga agregaciÃ³n local:

bloques contiguos en
ğœ‹
(
ğ‘¡
)
â‡’
mayor probabilidad de vecindad real
â‡’
prefetch
u
ËŠ
til
bloques contiguos en Ï€(t)â‡’mayor probabilidad de vecindad realâ‡’prefetch
u
ËŠ
til

El â€œpunteroâ€ no es
ğ‘š
m como identificador semÃ¡ntico; es
ğ‘š
m como coordenada topolÃ³gica que gobierna el coste del mundo.

ARTÃCULO IV â€” Unicidad, Determinismo y No-ColisiÃ³n Constitucional

IV.1. Dos dominios de colisiÃ³n (y su sentencia):

ColisiÃ³n de HID32: dos activos externos distintos podrÃ­an producir el mismo HID32. En TITAN, esto no se â€œtoleraâ€: se detecta por Cuckoo/Atlas y se sentencia como conflicto (no entra o se cuarentena).

ColisiÃ³n de UID64 completo: prohibida para vivos; si ocurre por corrupciÃ³n, se trata como identidad rota y se purga.

IV.2. GeneraciÃ³n determinista de HID32 desde clave externa ya binaria:
La ingesta entrega una clave externa Kext64 ya sin strings (hash fuera de hot-loop). Se dicta un mezclador branchless:

ğ‘š
ğ‘–
ğ‘¥
32
(
ğ‘¢
)
=
(
(
ğ‘¢
âŠ•
(
ğ‘¢
â‰«
33
)
)
â‹…
ğ‘
1
)
âŠ•
(
(
(
ğ‘¢
âŠ•
(
ğ‘¢
â‰«
33
)
)
â‹…
ğ‘
1
)
â‰«
29
)
â‹…
ğ‘
2
mix32(u)=((uâŠ•(uâ‰«33))â‹…c
1
	â€‹

)âŠ•(((uâŠ•(uâ‰«33))â‹…c
1
	â€‹

)â‰«29)â‹…c
2
	â€‹


con constantes
ğ‘
1
,
ğ‘
2
c
1
	â€‹

,c
2
	â€‹

 fijas de 32-bit (multiplicaciÃ³n entera wrap).
Luego:

ğ»
ğ¼
ğ·
32
=
ğ‘
ğ‘
ğ‘
ğ‘˜
(
ğ‘€
12
,
ğ‘‡
6
,
ğº
8
,
ğ»
6
)
HID32=pack(M12,T6,G8,H6)

donde:

ğ‘€
12
M12 se deriva de Morton-coarse o de hash de celda de nacimiento (no de nombre).

ğº
8
=
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
16

m
o
d

256
G8=epoch16mod256 (refuerzo).

ğ»
6
H6 se deriva de los 6 bits bajos de
ğ‘š
ğ‘–
ğ‘¥
32
(
ğ¾
ğ‘’
ğ‘¥
ğ‘¡
64
âŠ•
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
16
)
mix32(Kext64âŠ•epoch16).

IV.3. Regla de admisiÃ³n anti-colisiÃ³n:
Al nacer, el sistema intenta insertar HID32 en la tabla Cuckoo (Ley VII).

Si el slot encontrado ya tiene HID32 igual pero epoch distinto, se trata como stale-alias y se rechaza.

Si HID32 colisiona con un vivo distinto, se fuerza rehash controlado (variar
ğ¹
12
F12 con un salt fijo) hasta
ğ‘…
R intentos; si persiste, se sentencia como DISPUTA lÃ³gica (flag) y se rechaza.

IV.4. Determinismo bajo concurrencia:
Todo cambio de identidad se hace con protocolo prepare/commit: primero se escribe Atlas/epoch/meta en buffer inactivo o por-slot, luego se publica con store_release. La lectura valida epoch con load_acquire. Stutter prohibido â‡’ no locks.

ARTÃCULO V â€” Localidad Espacial, Coherencia de CachÃ© y SoA SIMD-Friendly

V.1. Principio de contigÃ¼idad: el orden Morton tiende a agrupar entidades cercanas; por tanto, operar por chunks contiguos aumenta la reutilizaciÃ³n de lÃ­neas de cachÃ©. En CPU, el coste de memoria domina; TITAN impone locality como ley.
V.2. PermutaciÃ³n Morton y tabla de Ã­ndices:
Se define un array SoA:

ğ‘œ
ğ‘Ÿ
ğ‘‘
ğ‘’
ğ‘Ÿ
[
ğ‘¡
]
[
ğ‘˜
]
=
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
_
ğœ‹
ğ‘˜
(
ğ‘¡
)
order[t][k]=SLOT32_Ï€
k
	â€‹

(t)

No se mueve la memoria de estado (prohibido re-alocar y reordenar SoA vivo). Se reordena solo el orden de iteraciÃ³n.
V.3. Prefetch por ventana: para cada bloque
ğµ
B de tamaÃ±o fijo:

p
r
e
f
e
t
c
h
(
ğ‘
ğ‘œ
ğ‘ 
[
ğ‘œ
ğ‘Ÿ
ğ‘‘
ğ‘’
ğ‘Ÿ
[
ğ‘˜
+
ğ‘ƒ
]
]
)
p
r
e
f
e
t
c
h
(
ğ‘š
ğ‘’
ğ‘¡
ğ‘
[
ğ‘œ
ğ‘Ÿ
ğ‘‘
ğ‘’
ğ‘Ÿ
[
ğ‘˜
+
ğ‘ƒ
]
]
)
prefetch(pos[order[k+P]])prefetch(meta[order[k+P]])

donde
ğ‘ƒ
P es distancia de prefetch calibrada.
V.4. SIMD: el SoA se procesa por bloques mÃºltiplos del ancho SIMD; Morton reduce saltos de memoria y hace que gathers sean menos patolÃ³gicos.

ARTÃCULO VI â€” IntegraciÃ³n con Vertex28 y Meta32: ManifestaciÃ³n FÃ­sica de Identidad

VI.1. Identidad en Vertex28 sin romper stride:
Vertex28 ya contiene morton32 y meta32; el Ã­ndice fÃ­sico SLOT32 es el offset del vÃ©rtice en el VBO (y en CPU es el Ã­ndice SoA). Por tanto, â€œIDXâ€ estÃ¡ presente como posiciÃ³n en el buffer, no como byte adicional.
Regla: el shader puede recuperar identidad fÃ­sica mediante gl_VertexID (o Ã­ndice equivalente del pipeline), y topologÃ­a mediante morton32.

VI.2. Meta32 como contrato de identidad (banderas mÃ­nimas):
La identidad se manifiesta por:

flags de existencia (Ley IX): VOID_READY/INVISIBLE/EJECT_PENDING/AGONYâ€¦

flags de integridad y linaje (Ley I): STATIC/GLOBAL/HAS_DNA/REINCARNATED (bit-a-bit, Art. IX).
Regla: ninguna propiedad de identidad requiere branching; se decide por mÃ¡scaras.

VI.3. Identidad â†” Atlas SoA (Ley VII):
El slot fÃ­sico indexa el Atlas:

â„
ğ‘–
ğ‘‘
32
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
,

ğ‘‘
ğ‘›
ğ‘
32
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
,

ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
8
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
,

ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
16
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
hid32[SLOT32], dna32[SLOT32], sent8[SLOT32], epoch16[SLOT32]

La coherencia se impone por verificaciÃ³n:

ğ‘‰
ğ¸
ğ‘…
16
(
ğ‘ˆ
ğ¼
ğ·
64
)
=
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
16
[
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
]
VER16(UID64)=epoch16[SLOT32]

Si falla, el slot no se acepta como resoluciÃ³n vÃ¡lida.

ARTÃCULO VII â€” ImplementaciÃ³n de Bajo Nivel (PseudocÃ³digo Ejecutable, Lock-Free, Branchless, SIMD-Friendly)

VII.1. Morton interleaving (branchless):

static inline uint32_t q10(float x){
  float u = fminf(1.f, fmaxf(-1.f, x));
  float t = (u*0.5f + 0.5f) * 1023.f;
  return (uint32_t)t; // floor via cast
}
static inline uint32_t part1by2_10(uint32_t v){
  v &= 0x3FFu;
  v = (v | (v << 16)) & 0x030000FFu;
  v = (v | (v <<  8)) & 0x0300F00Fu;
  v = (v | (v <<  4)) & 0x030C30C3u;
  v = (v | (v <<  2)) & 0x09249249u;
  return v;
}
static inline uint32_t morton32(float x,float y,float z){
  uint32_t X = part1by2_10(q10(x));
  uint32_t Y = part1by2_10(q10(y)) << 1;
  uint32_t Z = part1by2_10(q10(z)) << 2;
  return (X | Y | Z); // 30 bits
}


VII.2. Mezclador binario para HID32 (sin strings, determinista):

static inline uint32_t mix32(uint64_t k){
  uint32_t x = (uint32_t)(k ^ (k >> 32));
  x ^= x >> 16; x *= 0x7FEB352Du;
  x ^= x >> 15; x *= 0x846CA68Bu;
  x ^= x >> 16;
  return x;
}
static inline uint16_t crc4_uid(uint32_t hid, uint16_t f12, uint16_t ver){
  uint32_t x = hid ^ (uint32_t(f12) << 16) ^ uint32_t(ver);
  x ^= x >> 16; x ^= x >> 8; x ^= x >> 4;
  return (uint16_t)(x & 0xFu);
}
static inline uint32_t pack_hid(uint32_t M12,uint32_t T6,uint32_t G8,uint32_t H6){
  return ((M12 & 0xFFFu) << 20) | ((T6 & 0x3Fu) << 14) | ((G8 & 0xFFu) << 6) | (H6 & 0x3Fu);
}
static inline uint16_t pack_fam(uint16_t f12, uint16_t crc4){
  return (uint16_t)((crc4 << 12) | (f12 & 0x0FFFu));
}
static inline uint64_t pack_uid(uint32_t hid, uint16_t fam, uint16_t ver){
  return (uint64_t(hid) << 32) | (uint64_t(fam) << 16) | uint64_t(ver);
}


VII.3. Epoch anti-ABA (u16 SoA) y commit de nacimiento (con Ley VIII/VII):

// SoA:
alignas(64) uint16_t epoch16[N];
alignas(64) uint32_t hid32[N];
alignas(64) uint32_t dna32[N];
alignas(64) uint8_t  sent8[N];
alignas(64) uint32_t meta32[N];

static inline uint16_t epoch_next(uint16_t e){
  e = (uint16_t)(e + 1u);
  if(e == 0u) e = 1u;
  return e;
}

// Nacimiento: reclama slot fÃ­sico de VoidPool (Ley VIII) y fija UID coherente.
bool BirthCommit(uint64_t Kext64, uint32_t M12, uint32_t T6,
                 uint32_t DNA, int8_t SENT, uint16_t famSeed12,
                 uint32_t slot){ // slot obtenido por VoidPop (Ley VIII)
  // 1) incrementar epoch antes de publicar (anti-ABA)
  uint16_t ver = epoch_next(epoch16[slot]);
  epoch16[slot] = ver;

  // 2) construir HID32 determinista
  uint32_t h = mix32(Kext64 ^ uint64_t(ver));
  uint32_t G8 = (uint32_t)(ver & 0xFFu);
  uint32_t H6 = (h & 0x3Fu);
  uint32_t hid = pack_hid(M12, T6, G8, H6);

  // 3) FAM16 = [CRC4|F12]
  uint16_t crc4 = (uint16_t)crc4_uid(hid, famSeed12, ver);
  uint16_t fam  = pack_fam(famSeed12, crc4);

  uint64_t uid = pack_uid(hid, fam, ver);

  // 4) insertar en Cuckoo (Ley VII). Rechazo sin locks.
  if(!CuckooInsert(hid, fam, ver, slot)){ // usa (hid,fam) como clave; ver se valida al resolver
    // rollback: epoch ya avanzÃ³; permanece como cicatriz lÃ³gica anti-ABA.
    return false;
  }

  // 5) escribir Atlas/ADN/SENT (zero-copy)
  hid32[slot] = hid;
  dna32[slot] = DNA;
  sent8[slot] = (uint8_t)SENT;

  // 6) flags de identidad (Meta32) y existencia (Ley IX/VIII)
  uint32_t m = meta32[slot];
  m &= ~(F_VOID_READY | F_INVISIBLE | F_EJECT_PENDING | F_AGONY); // vida limpia
  m |=  F_HAS_DNA;                                                // Ley I (Art. IX)
  m |=  (uint32_t)-(ver != 1u) & F_REINCARNATED;                  // ver>1 => reencarnado
  meta32[slot] = m;

  // 7) publicar (si hay consumidores asÃ­ncronos): store_release del puntero activo (Ley VIII)
  PublishSlot(slot); // release/acquire por swap de buffer o fence equivalente
  return true;
}


VII.4. ResoluciÃ³n UID64â†’slot (O(1), anti-stale, branchless):

// Resolver por HID32 vÃ­a Cuckoo devuelve slot candidato (o false).
bool ResolveUID(uint64_t uid, uint32_t& outSlot){
  uint32_t hid = (uint32_t)(uid >> 32);
  uint16_t fam = (uint16_t)(uid >> 16);
  uint16_t ver = (uint16_t)(uid);

  uint32_t slot;
  if(!CuckooFind(hid, fam, slot)) return false;

  // ValidaciÃ³n anti-ABA: epoch exacto
  uint16_t cur = epoch16[slot];
  uint32_t ok  = (uint32_t)-(cur == ver);

  // Integridad mÃ­nima CRC4 (detecta corrupciÃ³n/bitflips)
  uint16_t f12  = (uint16_t)(fam & 0x0FFFu);
  uint16_t crc4 = (uint16_t)(fam >> 12);
  uint16_t crc4c= crc4_uid(hid, f12, ver);
  ok &= (uint32_t)-(crc4c == crc4);

  // Branchless return
  if(ok == 0u) return false;
  outSlot = slot;
  return true;
}


VII.5. Lectura branchless de propiedades de identidad vÃ­a Meta32:

static inline uint32_t flag_mask(uint32_t m, uint32_t F){
  return (uint32_t)-( (m & F) != 0u ); // 0xFFFFFFFF si set, 0 si no
}
uint32_t m = meta32[slot];
uint32_t is_static = flag_mask(m, F_ID_STATIC);
uint32_t has_dna   = flag_mask(m, F_HAS_DNA);
uint32_t reinc     = flag_mask(m, F_REINCARNATED);

// gating fÃ­sico (Ley IX) siempre soberano:
uint32_t live_mask = (uint32_t)-( (m & MASK_SKIP_PHYS) == 0u );

ARTÃCULO VIII â€” Modelo de Coste y Presupuesto de Rendimiento (Kernels de Identidad)

VIII.1. Kernels constitucionales de Identidad:

ğ¾
_
ğ¼
ğ·
_
ğ‘€
ğ‘‚
ğ‘…
ğ‘‡
K_ID_MORT: cÃ¡lculo Morton32 por slot (cuantizaciÃ³n + part1by2 + OR).

ğ¾
_
ğ¼
ğ·
_
ğº
ğ¸
ğ‘
K_ID_GEN: generaciÃ³n de HID32/FAM16/VER16 y commit de nacimiento (incluye CAS/tabla).

ğ¾
_
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ‘†
K_ID_RES: resoluciÃ³n
ğ‘ˆ
ğ¼
ğ·
64
â†’
ğ‘†
ğ¿
ğ‘‚
ğ‘‡
32
UID64â†’SLOT32 (CuckooFind + epoch/CRC).

ğ¾
_
ğ¼
ğ·
_
ğ‘‰
ğ‘…
ğ¹
K_ID_VRF: verificaciÃ³n de integridad y staleness por bloque (screening).

VIII.2. Presupuesto fijo (sin promesas vagas):
Se dicta que la suma de kernels de identidad no puede dominar el frame:

ğ¾
_
ğ¼
ğ·
_
ğ‘€
ğ‘‚
ğ‘…
ğ‘‡
+
ğ¾
_
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ‘†
+
ğ¾
_
ğ¼
ğ·
_
ğ‘‰
ğ‘…
ğ¹
â‰¤
1.0
 ms
(
bajo carga t
Ä±
ËŠ
pica
)
K_ID_MORT+K_ID_RES+K_ID_VRFâ‰¤1.0 ms(bajo carga t
Ä±
ËŠ
pica)

y bajo churn:

ğ¾
_
ğ¼
ğ·
_
ğº
ğ¸
ğ‘
â‰¤
0.3
 ms
(nacimientos/eyecciones batch y limitados)
K_ID_GENâ‰¤0.3 ms(nacimientos/eyecciones batch y limitados)

Regla de soberanÃ­a: en tormenta,
ğ¾
_
ğ¼
ğ·
_
ğº
ğ¸
ğ‘
K_ID_GEN se rate-limita por frame; el resto permanece invisible/pendiente (Ley IX/VIII) sin bloquear.

VIII.3. Coste por operaciÃ³n (modelo micro-mecÃ¡nico, no folklore):

Morton interleave: operaciones enteras (shifts/masks) + 3 cuantizaciones float â‡’ coste ALU fijo, sin memoria indirecta.

ResolveUID: 1 bÃºsqueda Cuckoo (2-vÃ­as) + 2 lecturas SoA (epoch/meta) + CRC4 â‡’ coste dominado por 1â€“2 lÃ­neas de cachÃ©.

BirthCommit: 1 VoidPop (CAS) + 1 insert Cuckoo (CAS/evict) + escrituras SoA contiguas â‡’ coste dominado por contenciÃ³n; por eso se batch-limita constitucionalmente.

ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 Soberano para Identidad)

IX.1. Meta32 (uint32) â€” particiÃ³n compatible con Ley III/V/IX y ampliaciÃ³n de identidad:
Se preservan bits altos ya soberanos (Ley IX), y se dicta el uso de bits bajos para identidad sin tocar el stride:

Bits [31:28]: LOD4 (o TSD_hi4 en muerte; Ley V/VIII)

Bits [27:24]: FLAGS4 (Ley IX: DISPUTA/FLASH/VOID_READY/AGONY)

Bits [23:20]: STATUS4 (Ley V: ALFA/SIGMA/OMEGA/OMEGA_FAST)

Bits [19:16]: VITAL4 (Ley IX: INVISIBLE/EJECT_PENDING/VOL_FAKE/AGONY_FREEZE)

Bits [15:0]: ID16 (Ley I: flags de identidad + clase compacta)

IX.2. Layout de ID16 (bajo 16 bits, identidad intrÃ­nseca):

ğ¼
ğ·
16
â‰¡
[
ğ¼
ğ·
ğ¹
4
âˆ£
ğ¶
ğ¿
ğ‘†
12
]
ID16â‰¡[IDF4âˆ£CLS12]

CLS12 (bits 0..11): clase compacta (0..4095) derivada de taxonomÃ­a/LUT (no strings).

IDF4 (bits 12..15): banderas de identidad puras.

IX.3. Banderas de identidad (Meta32):

// Identidad (IDF4 dentro de ID16):
static constexpr uint32_t F_ID_STATIC      = 0x00001000u; // bit12: identidad inmutable (no migra de clase)
static constexpr uint32_t F_ID_GLOBAL      = 0x00002000u; // bit13: visible a todos los subsistemas (no local)
static constexpr uint32_t F_HAS_DNA        = 0x00004000u; // bit14: DNA32 vÃ¡lido (Ley VII)
static constexpr uint32_t F_REINCARNATED   = 0x00008000u; // bit15: ver>1 (linaje no virgen)


IX.4. MÃ¡scaras compuestas (identidad y existencia):

static constexpr uint32_t MASK_ID_FLAGS    = 0x0000F000u; // IDF4
static constexpr uint32_t MASK_ID_CLASS    = 0x00000FFFu; // CLS12

// Existencia fÃ­sica/consenso (Ley IX) ya soberana:
static constexpr uint32_t MASK_SKIP_PHYS   = (F_VOID_READY | F_INVISIBLE | F_AGONY | F_EJECT_PENDING);
static constexpr uint32_t MASK_SKIP_ORCL   = (F_VOID_READY | F_INVISIBLE | F_EJECT_PENDING);


IX.5. Reglas branchless obligatorias (lectura/escritura):

// Leer flags:
uint32_t idf = meta32[slot] & MASK_ID_FLAGS;
uint32_t has_dna_mask = (uint32_t)-((idf & F_HAS_DNA) != 0u);

// Escribir F_REINCARNATED sin branches:
meta32[slot] = (meta32[slot] & ~F_REINCARNATED) |
               (((uint32_t)-(epoch16[slot] != 1u)) & F_REINCARNATED);

// Clase CLS12 (0..4095) derivada:
meta32[slot] = (meta32[slot] & ~MASK_ID_CLASS) | (cls12 & MASK_ID_CLASS);

ARTÃCULO X â€” Persistencia, SerializaciÃ³n y VerificaciÃ³n de Integridad

X.1. Inmutabilidad constitucional del handle: un
ğ‘ˆ
ğ¼
ğ·
64
UID64 emitido para un inquilino vivo no se muta; si cambia cualquier propiedad fundamental, se emite nueva generaciÃ³n (epoch).
X.2. SerializaciÃ³n binaria (endianness explÃ­cito):
UID64 se serializa como 8 bytes little-endian:

ğ‘
ğ‘¦
ğ‘¡
ğ‘’
ğ‘ 
[
0..1
]
=
ğ‘‰
ğ¸
ğ‘…
16
,

ğ‘
ğ‘¦
ğ‘¡
ğ‘’
ğ‘ 
[
2..3
]
=
ğ¹
ğ´
ğ‘€
16
,

ğ‘
ğ‘¦
ğ‘¡
ğ‘’
ğ‘ 
[
4..7
]
=
ğ»
ğ¼
ğ·
32
bytes[0..1]=VER16,bytes[2..3]=FAM16,bytes[4..7]=HID32

X.3. DetecciÃ³n de corrupciÃ³n: CRC4 (FAM16[15:12]) debe coincidir con
ğ‘
ğ‘Ÿ
ğ‘
4
_
ğ‘¢
ğ‘–
ğ‘‘
(
â„
ğ‘–
ğ‘‘
,
ğ‘“
12
,
ğ‘£
ğ‘’
ğ‘Ÿ
)
crc4_uid(hid,f12,ver). Si falla:

set
ğ¹
_
ğ¼
ğ‘
ğ‘‰
ğ¼
ğ‘†
ğ¼
ğµ
ğ¿
ğ¸
F_INVISIBLE inmediato (Ley IX mask)

set
ğ¹
_
ğ·
ğ¼
ğ‘†
ğ‘ƒ
ğ‘ˆ
ğ‘‡
ğ´
F_DISPUTA y
ğ¹
_
ğ‘‰
ğ‘‚
ğ¿
_
ğ¹
ğ´
ğ¾
ğ¸
F_VOL_FAKE si procede (Ley VI/IX)

ordenar OMEGA_FAST si persiste por
ğ‘
N frames (Ley V/IX) â‡’ Ley VIII.

ARTÃCULO XI â€” Conexiones Inter-Ley (Identidad como Sujeto Inmutable)

XI.1. Con Ley VII (Atlas/DNA/SENT): UID64 es el punto de anclaje lÃ³gico; el Atlas SoA indexado por slot materializa propiedades fÃ­sicas desde DNA_PACK y presiÃ³n desde SENT8.
XI.2. Con Ley VIII (ReencarnaciÃ³n): la reencarnaciÃ³n recicla slot fÃ­sico; el epoch (VER16) invalida el pasado;
ğ¹
_
ğ‘…
ğ¸
ğ¼
ğ‘
ğ¶
ğ´
ğ‘…
ğ‘
ğ´
ğ‘‡
ğ¸
ğ·
F_REINCARNATED marca linaje.
XI.3. Con Ley VI (OrÃ¡culo): el OrÃ¡culo no â€œnombraâ€ activos; escribe verdad y flags por slot; identidad corrupta o disputada reduce peso, activa cuarentena o dispara muerte acelerada.
XI.4. Con Ley IX (Horizonte): la existencia y participaciÃ³n se deciden por mÃ¡scara; identidad no puede forzar permanencia. El silicio hospeda masa; lo demÃ¡s es ruido.

ARTÃCULO XII â€” Ruta SIMD/Branchless para Identidad y Locality-Hint

XII.1. PolÃ­tica soberana SIMD: portable-first con feature-detect (Scalar-branchless mÃ­nimo; WASM-SIMD128; AVX2; AVX-512 si existe). La semÃ¡ntica de identidad es idÃ©ntica en todos los backends: solo cambia el ancho del vector.
XII.2. Kernel vectorizable: Morton y lectura de flags se ejecutan por bloques contiguos; la permutaciÃ³n por Morton se usa para reducir dispersiÃ³n y amortizar prefetch.
XII.3. ProhibiciÃ³n: ninguna ruta SIMD introduce locks ni alocaciones; cualquier estructura auxiliar (histogramas, tablas) es fija y pre-reservada.

ARTÃCULO XIII â€” Pruebas Deterministas y MediciÃ³n (Identidad sin AmbigÃ¼edad)

XIII.1. Propiedades obligatorias:

No-stale: un UID64 antiguo nunca resuelve a un inquilino nuevo (epoch).

No-duplicados vivos: no existen dos slots vivos con mismo HID32+FAM16 bajo Atlas.

No-corrupciÃ³n silenciosa: CRC4 detecta bit-flip; al fallar, el activo se vuelve invisible y se purga.

No-stutter: bajo churn, BirthCommit se rate-limita; ResolveUID permanece O(1) y no bloquea.

XIII.2. MÃ©tricas constitucionales:

ğ‘¡
(
ğ¾
_
ğ¼
ğ·
_
ğ‘€
ğ‘‚
ğ‘…
ğ‘‡
)
t(K_ID_MORT),
ğ‘¡
(
ğ¾
_
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ‘†
)
t(K_ID_RES),
ğ‘¡
(
ğ¾
_
ğ¼
ğ·
_
ğº
ğ¸
ğ‘
)
t(K_ID_GEN) por frame.

fallos CAS en VoidPool/Cuckoo (contenciÃ³n) y profundidad de cola de nacimientos.

ratio stale-reject y crc-fail (debe tender a 0 en rÃ©gimen sano).

ARTÃCULO XIV â€” AXIOMA FINAL

â€œLa identidad en TITAN V8 es un invariante topolÃ³gico: un puntero verificable en la red Morton, sellado por epoch contra el pasado. Todo lo demÃ¡s es campo; y el campo â€”sin masaâ€” cae.â€

LEY II â€” Nacimiento: Singularidad de InyecciÃ³n, EnergÃ­a de Desplazamiento y Barreras de Anclaje
Nombre formal: LEY II â€” Nacimiento: Singularidad de InyecciÃ³n, EnergÃ­a de Desplazamiento y Barreras de Anclaje

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Principio de la Singularidad de InyecciÃ³n: Nacimiento como DeformaciÃ³n del Manifold
3. ARTÃCULO II â€” Criterio de AdmisiÃ³n: EnergÃ­a de Desplazamiento y Anclaje
4. ARTÃCULO III â€” ConexiÃ³n con Ley IV: Nacimiento y TransmigraciÃ³n como Operadores Unificados
5. ARTÃCULO IV â€” GestiÃ³n de Slots y Coherencia con Ley I, Ley VIII y Ley IX
6. ARTÃCULO V â€” ImplementaciÃ³n de Bajo Nivel: PseudocÃ³digo Ejecutable C++/WASM (Lock-Free, Branchless, SIMD-Friendly)
7. ARTÃCULO VI â€” Modelo de Coste y Presupuesto de Rendimiento (Nacimiento bajo 16.67ms)
8. ARTÃCULO VII â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para Nacimiento)
9. AXIOMA FINAL

Ãmbito
Universo N = 200,000 (cardinalidad fija); 16.67ms/frame; cero micro-stuttering; bus final Vertex28 (stride 28 bytes); prohibida re-allocaciÃ³n en hot-loop; integraciÃ³n estricta con Ley I (Identidad/UID64/epoch anti-ABA) + Ley IV (Manifold/Langevin/barreras/cÃ¡usalidad discreta) + Ley V (Tsallis/TSD/ALFAâ€“SIGMAâ€“OMEGA) + Ley VI (OrÃ¡culo/consenso/ataque/cuarentena/flags) + Ley VIII (OMEGA-ZERO/VoidPool/reciclaje lock-free) + Ley IX (Masa MÃ­nima/Horizonte/AGONY/EJECT_PENDING).

LEY II â€” Nacimiento: Singularidad de InyecciÃ³n, EnergÃ­a de Desplazamiento y Barreras de Anclaje


Dictamen de dominio: en TITAN V8 nacer no es â€œaparecerâ€; es insertar curvatura local y reordenar ocupaciÃ³n bajo presiÃ³n sin bloquear el frame. El nacimiento es un operador fÃ­sico que o reclama vacÃ­o soberano o exige desplazamiento por excedente energÃ©tico sobre el anclaje del sitio. No existe singularidad gratuita.

ARTÃCULO I â€” Principio de la Singularidad de InyecciÃ³n: Nacimiento como DeformaciÃ³n del Manifold
I.1. Axioma de InyecciÃ³n Conformal (singularidad acotada):
Sea el manifold discreto MâŠ‚R3\mathcal{M}\subset \mathbb{R}^3MâŠ‚R3 donde cada activo iii es un estado (xi,vi)(x_i,v_i)(xiâ€‹,viâ€‹) (Ley IV). Un nacimiento en t0t_0t0â€‹ introduce una perturbaciÃ³n local de curvatura (energÃ­a potencial efectiva) sobre una regiÃ³n ccc (celda Morton o vecindad top-K):
Î”Î©i(x,t0)=Î“i(t0)â‹…Kâ€‰â£(âˆ¥xâˆ’xiseedâˆ¥2â„“c2)\Delta\Omega_i(x,t_0)=\Gamma_i(t_0)\cdot K\!\left(\frac{\|x-x^{seed}_i\|^2}{\ell_c^2}\right)Î”Î©iâ€‹(x,t0â€‹)=Î“iâ€‹(t0â€‹)â‹…K(â„“c2â€‹âˆ¥xâˆ’xiseedâ€‹âˆ¥2â€‹)
donde K(â‹…)K(\cdot)K(â‹…) es un kernel radial compacto y Î“i(t0)\Gamma_i(t_0)Î“iâ€‹(t0â€‹) es la amplitud de inyecciÃ³n. Se dicta acotaciÃ³n dura (float32-safe) para impedir explosiÃ³n numÃ©rica:
Î“i(t0)â†clamp(Î“i(t0),â€‰0,â€‰Î“maxâ¡),K(u)â†clamp(K(u),â€‰0,â€‰1)\Gamma_i(t_0)\leftarrow \mathrm{clamp}\big(\Gamma_i(t_0),\,0,\,\Gamma_{\max}\big),\qquad
K(u)\leftarrow \mathrm{clamp}\big(K(u),\,0,\,1\big)Î“iâ€‹(t0â€‹)â†clamp(Î“iâ€‹(t0â€‹),0,Î“maxâ€‹),K(u)â†clamp(K(u),0,1)
Consecuencia fÃ­sica: el nacimiento no crea materia; redistribuye energÃ­a local. Si no existe excedente energÃ©tico por encima del anclaje, la singularidad es prohibida.
I.2. Nacimiento â‰ \neqî€ = colocaciÃ³n: operador Bi(t0)B_i(t_0)Biâ€‹(t0â€‹):
Se define el nacimiento como operador de transiciÃ³n VacÃ­o/No-existencia â†’ Existencia sobre un slot fÃ­sico sss:
Bi(t0): VOID(s) â†¦ ALFA(s,i) âˆ§ xsâ‰ˆxiseed âˆ§ vs=0B_i(t_0):\ \mathrm{VOID}(s)\ \mapsto\ \mathrm{ALFA}(s,i)\ \wedge\ x_s\approx x^{seed}_i\ \wedge\ v_s=0Biâ€‹(t0â€‹): VOID(s) â†¦ ALFA(s,i) âˆ§ xsâ€‹â‰ˆxiseedâ€‹ âˆ§ vsâ€‹=0
La operaciÃ³n BiB_iBiâ€‹ estÃ¡ constitucionalmente subordinada a:


AdmisiÃ³n por Masa (Ley IX): ningÃºn nacimiento puede comenzar bajo el Horizonte.


Identidad anti-ABA (Ley I): toda reencarnaciÃ³n debe cambiar VER16VER16VER16 (epoch) y ser verificable.


No-stutter: BiB_iBiâ€‹ se aplica por batch y doble bÃºfer; jamÃ¡s en caliente con realloc/locks.


I.3. Continuidad visual y estabilidad operativa (ramp-up):
Se dictan funciones de rampa deterministas para evitar flashes, picos de fuerza y discontinuidad de riesgo/shock:
g(Ï„)=sat[0,1]â€‰â£(Ï„Tramp),Ï„=tâˆ’t0g(\tau)=\mathrm{sat}_{[0,1]}\!\left(\frac{\tau}{T_{\mathrm{ramp}}}\right),\qquad \tau=t-t_0g(Ï„)=sat[0,1]â€‹(Trampâ€‹Ï„â€‹),Ï„=tâˆ’t0â€‹



**CONSTANTES DE SILICIO (LEY II):**
- `n_ramp_frames = 12` (canÃ³nico)  â‡’  `T_ramp = n_ramp_frames Â· Î”t_frame`.
- `epsMu = 1.0e-3` (FP32)  â‡’  Î¼ y sus inversas **jamÃ¡s** dividen por cero.

y se impone, durante Ï„âˆˆ[0,Tramp]\tau\in[0,T_{\mathrm{ramp}}]Ï„âˆˆ[0,Trampâ€‹]:
xi(t)=xiseed+Î´i,vi(t)=0,riski(t)=g(Ï„)â€‰riskioracle,shocki(t)=g(Ï„)â€‰shockioraclex_i(t)=x^{seed}_i+\delta_i,\quad v_i(t)=0,\quad
risk_i(t)=g(\tau)\,risk^{oracle}_i,\quad
shock_i(t)=g(\tau)\,shock^{oracle}_ixiâ€‹(t)=xiseedâ€‹+Î´iâ€‹,viâ€‹(t)=0,riskiâ€‹(t)=g(Ï„)riskioracleâ€‹,shockiâ€‹(t)=g(Ï„)shockioracleâ€‹
Fi(t)=g(Ï„)â€‰FiLeyIV(t)(acoplamiento suave a fuerzas)F_i(t)=g(\tau)\,F_i^{LeyIV}(t)\qquad(\text{acoplamiento suave a fuerzas})Fiâ€‹(t)=g(Ï„)FiLeyIVâ€‹(t)(acoplamiento suave a fuerzas)
Regla: un reciÃ©n nacido no aplica fuerza plena hasta completar rampa; su existencia es primero topolÃ³gica, luego dinÃ¡mica.

ARTÃCULO II â€” Criterio de AdmisiÃ³n: EnergÃ­a de Desplazamiento y Anclaje
II.1. EnergÃ­a de InyecciÃ³n EinjE_{\mathrm{inj}}Einjâ€‹ (excedente informacional + impacto):
Para un entrante iii que pretende nacer en regiÃ³n ccc en frame ttt, se define energÃ­a de inyecciÃ³n (O(1), SIMD-apta):
Einj(i,c,t)=Î±Iâ€‰I(i,c,t)+Î±Eâ€‰Ei(t)+Î±sâ€‰satâ€‰â£(âˆ£SENT8i(t)âˆ£/S0)+Î±râ€‰satâ€‰â£(riskioracle(t)/R0)+Î±Îºâ€‰ÎºiE_{\mathrm{inj}}(i,c,t)=
\alpha_I\,I(i,c,t)
+\alpha_E\,E_i(t)
+\alpha_s\,\mathrm{sat}\!\big(|SENT8_i(t)|/S_0\big)
+\alpha_r\,\mathrm{sat}\!\big(risk^{oracle}_i(t)/R_0\big)
+\alpha_\kappa\,\kappa_iEinjâ€‹(i,c,t)=Î±Iâ€‹I(i,c,t)+Î±Eâ€‹Eiâ€‹(t)+Î±sâ€‹sat(âˆ£SENT8iâ€‹(t)âˆ£/S0â€‹)+Î±râ€‹sat(riskioracleâ€‹(t)/R0â€‹)+Î±Îºâ€‹Îºiâ€‹
donde:


Ei(t)E_i(t)Eiâ€‹(t) es la energÃ­a informacional (Ley IX, Art. II) ya filtrada por OrÃ¡culo (volumen verdad + penalizaciones).


I(i,c,t)I(i,c,t)I(i,c,t) es impacto local de inserciÃ³n, definido por presiÃ³n de ocupaciÃ³n:


I(i,c,t)=satâ€‰â£(Pc(t)P0)â‹…satâ€‰â£(Î”Î©imaxâ¡(t)Î©0)I(i,c,t)=\mathrm{sat}\!\left(\frac{P_c(t)}{P_0}\right)\cdot \mathrm{sat}\!\left(\frac{\Delta\Omega_i^{\max}(t)}{\Omega_0}\right)I(i,c,t)=sat(P0â€‹Pcâ€‹(t)â€‹)â‹…sat(Î©0â€‹Î”Î©imaxâ€‹(t)â€‹)
con Pc(t)P_c(t)Pcâ€‹(t) presiÃ³n discreta de celda (Art. IV) y Î”Î©imaxâ¡\Delta\Omega_i^{\max}Î”Î©imaxâ€‹ amplitud mÃ¡xima acotada (Art. I).


SENT8SENT8SENT8 es presiÃ³n de mercado compacta (Ley VII/IX); riskoraclerisk^{oracle}riskoracle es riesgo inicial (Ley VI).


Îºiâˆˆ[0,1]\kappa_i\in[0,1]Îºiâ€‹âˆˆ[0,1] es movilidad intrÃ­nseca derivada de DNA (Ley VII) o LUT fija (sin strings).


II.2. EnergÃ­a de Anclaje EresE_{\mathrm{res}}Eresâ€‹ (resistencia del residente):
Para un residente jjj en regiÃ³n ccc, se define su energÃ­a de anclaje (lo que cuesta desplazarlo) como:
Eres(j,c,t)=Î²Mâ€‰Î¼(Îºj)âˆ’1+Î²Râ€‰Rj(t)+Î²Ï•â€‰Ï•c(xj,t)+Î²Tâ€‰Î˜j(t)E_{\mathrm{res}}(j,c,t)=
\beta_M\,\mu(\kappa_j)^{-1}
+\beta_R\,\mathcal{R}_j(t)
+\beta_\phi\,\phi_c(x_j,t)
+\beta_T\,\Theta_j(t)Eresâ€‹(j,c,t)=Î²Mâ€‹Î¼(Îºjâ€‹)âˆ’1+Î²Râ€‹Rjâ€‹(t)+Î²Ï•â€‹Ï•câ€‹(xjâ€‹,t)+Î²Tâ€‹Î˜jâ€‹(t)
donde:


Î¼(Îº)=ÏµÎ¼+Îº\mu(\kappa)=\epsilon_\mu+\kappaÎ¼(Îº)=ÏµÎ¼â€‹+Îº es movilidad efectiva (evita divisiÃ³n por 0); Î¼âˆ’1\mu^{-1}Î¼âˆ’1 penaliza a los â€œpegadosâ€ (baja movilidad â‡’ alto anclaje).


Rj(t)=sat(Ej(t)/E0)\mathcal{R}_j(t)=\mathrm{sat}\big(E_j(t)/E_0\big)Rjâ€‹(t)=sat(Ejâ€‹(t)/E0â€‹) es relevancia termodinÃ¡mica (Ley IX) reescalada.


Ï•c(x,t)\phi_c(x,t)Ï•câ€‹(x,t) es potencial barrera local (Cauchy-barrier discreta):


Ï•c(x,t)=Ï•0â‹…satâ€‰â£(d(x,âˆ‚c)d0)âˆ’1\phi_c(x,t)=\phi_0\cdot \mathrm{sat}\!\left(\frac{d(x,\partial c)}{d_0}\right)^{-1}Ï•câ€‹(x,t)=Ï•0â€‹â‹…sat(d0â€‹d(x,âˆ‚c)â€‹)âˆ’1
que crece cerca del borde para impedir teletransportes implÃ­citos y discontinuidades.


Î˜j(t)\Theta_j(t)Î˜jâ€‹(t) es tensiÃ³n tÃ©rmica (Ley V):


Î˜j(t)=satâ€‰â£(q(t)âˆ’qâ‹†Î”q)\Theta_j(t)=\mathrm{sat}\!\left(\frac{q(t)-q^\star}{\Delta q}\right)Î˜jâ€‹(t)=sat(Î”qq(t)âˆ’qâ‹†â€‹)
que modela rÃ©gimen de entropÃ­a alta (donde desplazar cuesta mÃ¡s si el sistema estÃ¡ inestable).
II.3. Criterio constitucional de nacimiento con histÃ©resis de sitio:
Existe nacimiento en regiÃ³n ccc si y solo si se cumple alguno de los dos caminos soberanos:
(A) Camino VacÃ­o: existe slot sss disponible en VoidPool (Ley VIII) y el entrante supera la masa mÃ­nima con margen:
Ei(t) â‰¥ Eminâ¡(t)+Î”EbirthE_i(t)\ \ge\ E_{\min}(t)+\Delta E_{\mathrm{birth}}Eiâ€‹(t) â‰¥ Eminâ€‹(t)+Î”Ebirthâ€‹
(Ley IX: Eminâ¡(t)=logâ¡(ÏµV+Vminâ¡(t))E_{\min}(t)=\log(\epsilon_V+V_{\min}(t))Eminâ€‹(t)=log(ÏµVâ€‹+Vminâ€‹(t))).
(B) Camino Desplazamiento: existe jâ‹†âˆˆC(c,t)j^\star\in C(c,t)jâ‹†âˆˆC(c,t) tal que:
Einj(i,c,t) > Eres(jâ‹†,c,t)â‹…(1+Î·hys)E_{\mathrm{inj}}(i,c,t)\ >\ E_{\mathrm{res}}(j^\star,c,t)\cdot(1+\eta_{\mathrm{hys}})Einjâ€‹(i,c,t) > Eresâ€‹(jâ‹†,c,t)â‹…(1+Î·hysâ€‹)
con Î·hys>0\eta_{\mathrm{hys}}>0Î·hysâ€‹>0 histÃ©resis anti-flicker de ocupaciÃ³n (evita ping-pong de expulsiÃ³n/entrada), y:
jâ‹†=argâ¡minâ¡jâˆˆC(c,t)Eres(j,c,t)j^\star=\arg\min_{j\in C(c,t)} E_{\mathrm{res}}(j,c,t)jâ‹†=argjâˆˆC(c,t)minâ€‹Eresâ€‹(j,c,t)
Dictamen: si no hay vacÃ­o y no hay excedente, el nacimiento no ocurre; se encola como BIRTH_PENDING sin contaminar la fÃ­sica.

ARTÃCULO III â€” ConexiÃ³n con Ley IV: Nacimiento y TransmigraciÃ³n como Operadores Unificados
III.1. Operador de InyecciÃ³n BiB_iBiâ€‹ vs Operador de Ruptura TiT_iTiâ€‹:
Se define la transmigraciÃ³n (salto) como operador que reubica un activo existente sin cambiar su identidad (Ley I):
Tj(t): xjâ†¦xjâ€²  con  UID64j invarianteT_j(t):\ x_j\mapsto x'_j\ \ \text{con}\ \ UID64_j \ \text{invariante}Tjâ€‹(t): xjâ€‹â†¦xjâ€²â€‹  con  UID64jâ€‹ invariante
El nacimiento BiB_iBiâ€‹ es el caso extremo donde el estado previo es VOID (Ley VIII) y se crea un nuevo inquilino con epoch nuevo. Ambos obedecen el mismo principio: evento solo si excede barrera:
Î”Î >Ï•+Î·\Delta \Pi > \phi + \etaÎ”Î >Ï•+Î·
donde Î”Î \Delta\PiÎ”Î  es excedente (impacto/movilidad/presiÃ³n), Ï•\phiÏ• barrera y Î·\etaÎ· histÃ©resis.
III.2. EnergÃ­a excedente unificada:
Para salto de jjj:
Î”Î j(t)=Î j(t)âˆ’Î site(câ€²,t)\Delta\Pi_j(t)=\Pi_j(t)-\Pi^{site}(c',t)Î”Î jâ€‹(t)=Î jâ€‹(t)âˆ’Î site(câ€²,t)
y el salto ocurre si Î”Î j(t)>Ï•câ€²+Î·jump\Delta\Pi_j(t)>\phi_{c'}+\eta_{jump}Î”Î jâ€‹(t)>Ï•câ€²â€‹+Î·jumpâ€‹.
Para nacimiento: Î”Î i(t)=Einj(i,c,t)âˆ’Eres(jâ‹†,c,t)\Delta\Pi_i(t)=E_{\mathrm{inj}}(i,c,t)-E_{\mathrm{res}}(j^\star,c,t)Î”Î iâ€‹(t)=Einjâ€‹(i,c,t)âˆ’Eresâ€‹(jâ‹†,c,t).
UnificaciÃ³n: el sistema no â€œdecideâ€ por heurÃ­stica narrativa; decide por excedente energÃ©tico con clamps y rampa.
III.3. Determinismo del seed espacial Î´\deltaÎ´ y reproducibilidad:
Se define jitter determinista por PRNG estable indexado por (UID64slot,t)(UID64_{slot},t)(UID64slotâ€‹,t):
Î´i=J(hash(UID64sâŠ•t)),âˆ¥Î´iâˆ¥â‰¤Î´maxâ¡\delta_i = J\big(\mathrm{hash}(UID64_s\oplus t)\big),\quad \|\delta_i\|\le\delta_{\max}Î´iâ€‹=J(hash(UID64sâ€‹âŠ•t)),âˆ¥Î´iâ€‹âˆ¥â‰¤Î´maxâ€‹
Esto asegura que, a igualdad de entradas, los nacimientos son reproducibles bit-a-bit (dentro de float32 determinista por backend).

ARTÃCULO IV â€” GestiÃ³n de Slots y Coherencia con Ley I, Ley VIII y Ley IX
IV.1. Conjunto de candidatos C(c,t)C(c,t)C(c,t) (ocupaciÃ³n local sin coste prohibitivo):
Se define ccc como celda Morton-coarse (p.ej. M12M12M12 de Ley I) o vecindad top-K ya cacheada por Ley IV. El conjunto candidato se extrae sin construir Ã­ndices globales dinÃ¡micos:
C(c,t)=TopKNeighbors(xiseed,t) âˆª Reservoir(c)C(c,t)=\mathrm{TopKNeighbors}(x^{seed}_i,t)\ \cup\ \mathrm{Reservoir}(c)C(c,t)=TopKNeighbors(xiseedâ€‹,t) âˆª Reservoir(c)
donde Reservoir(c) es un buffer fijo por celda con capacidad KRK_RKRâ€‹ mantenido por muestreo determinista (sin atomics en hot loop; actualizaciÃ³n por batch).
IV.2. Camino VacÃ­o: reclamaciÃ³n soberana del silicio (Ley VIII):
El nacimiento consume un slot solo vÃ­a VoidPop (Treiber stack) cuando el slot estÃ¡ en OMEGA-ZERO y F_VOID_READY=1 (Ley VIII). No existe â€œslot nuevoâ€.
IV.3. Camino Desplazamiento: conversiÃ³n de residente en recurso futuro:
Si se selecciona jâ‹†j^\starjâ‹†, el sistema no lo borra: lo sentencia por Ley IX/V:


set F_EJECT_PENDING=1 (Ley IX)


transicionar estado Ley V â†’ OMEGA acelerado (TSD_FAST)


al disipar a TSD8==255 â‡’ OMEGA-ZERO â‡’ VoidPush (Ley VIII)
El nacimiento del entrante queda BIRTH_PENDING hasta que exista slot real, o se realiza en otro slot libre si aparece antes (no bloquea).


IV.4. Coherencia con Ley I (identidad anti-ABA en reencarnaciÃ³n):
El slot fÃ­sico reutilizado debe incrementar VER16 antes de exponer el nuevo UID64. Toda referencia antigua falla por epoch y/o CRC (Ley I). El nacimiento no introduce ambigÃ¼edad temporal.
IV.5. Coherencia con Ley IX (horizonte):
Se prohÃ­be nacimiento que nazca â€œya muertoâ€:
Ei(t0)<Eminâ¡(t0)+Î”Ebirth â‡’ REJECT (no entra, no ocupa silicio)E_i(t_0) < E_{\min}(t_0)+\Delta E_{\mathrm{birth}}\ \Rightarrow\ \text{REJECT (no entra, no ocupa silicio)}Eiâ€‹(t0â€‹)<Eminâ€‹(t0â€‹)+Î”Ebirthâ€‹ â‡’ REJECT (no entra, no ocupa silicio)
El Portero (Ley IX) gobierna: Ley II ejecuta la mecÃ¡nica; Ley IX dicta la existencia.

ARTÃCULO V â€” ImplementaciÃ³n de Bajo Nivel: PseudocÃ³digo Ejecutable C++/WASM (Lock-Free, Branchless, SIMD-Friendly)
V.1. SoA mÃ­nimos (tamaÃ±o N fijo, sin realloc):
// SoA (N=200k):
alignas(64) float    posx[N], posy[N], posz[N];
alignas(64) float    velx[N], vely[N], velz[N];
alignas(64) float    risk[N], shock[N];
alignas(64) uint32_t morton[N];        // Vertex28 side
alignas(64) uint32_t meta32[N];        // Meta32 flags/status
alignas(64) uint16_t epoch16[N];       // Ley I
alignas(64) uint32_t hid32[N], dna32[N];
alignas(64) uint8_t  sent8[N];

// Global (Ley IX/Ley V/Ley VI):
extern float   Emin_t;                 // E_min(t) (o logVmin)
extern float   q_global;               // Tsallis regime
extern int     oracleState;            // NORMAL/ATAQUE/LOCKDOWN...

V.2. Estructuras de entrada: cola SPSC de nacimientos (sin strings):
struct BirthReq {
  uint64_t kext64;      // clave externa ya hasheada fuera del hot-loop
  uint32_t M12;         // morton-coarse deseado
  uint32_t T6;          // tipo compacto
  uint32_t dna;         // DNA32
  int8_t   sent;        // SENT8 firmado
  float    seedx, seedy, seedz;   // x_seed (NDC-safe)
  float    Einf;        // E_i(t0) ya computada/filtrada (Ley IX)
  float    risk0, shock0;
  float    kappa;       // movilidad [0,1]
  uint16_t fam12;       // familia/seed para FAM16
};
SPSC<BirthReq, 4096> gBirthQ;      // prealloc fija
SPSC<uint32_t, 4096> gDeathQ;      // slots sentenciados (si aplica)

V.3. Funciones de energÃ­a (O(1), branchless-friendly):
static inline float sat01(float x){ return fminf(1.f, fmaxf(0.f, x)); }

static inline float Einj(const BirthReq& b, float Pc, float dOmegaMax){
  float I = sat01(Pc) * sat01(dOmegaMax);
  float s = sat01(fabsf((float)b.sent) / 64.f);
  float r = sat01(b.risk0 / 1.f);
  return alphaI*I + alphaE*b.Einf + alphas*s + alphar*r + alphak*b.kappa;
}

static inline float mu_inv(float kappa){
  return 1.f / (epsMu + kappa);
}

static inline float Theta(float q){
  return sat01((q - qStar) / dQ);
}

static inline float Eres(uint32_t j, uint32_t cellMask /*coarse*/, float Pc){
  // Relevancia termodinÃ¡mica local (proxy desde Ley IX):
  float Ej = sat01(EnergyProxy(j) / E0);
  // Barrera de sitio (simple: proporcional a presiÃ³n y cercanÃ­a al borde; aquÃ­ proxy con Pc):
  float phi = phi0 * sat01(Pc);
  float kappa = KappaProxy(j); // desde DNA/LUT
  return betaM*mu_inv(kappa) + betaR*Ej + betaPhi*phi + betaT*Theta(q_global);
}

V.4. SelecciÃ³n determinista de candidato jâ‹†j^\starjâ‹† (sobre C(c,t)C(c,t)C(c,t) fijo):
// Candidatos: top-K vecinos ya cacheados por Ley IV + reservoir fijo por celda.
// Deben estar disponibles sin construir estructuras dinÃ¡micas.
static inline uint32_t SelectVictim(const BirthReq& b, const uint32_t* cand, uint32_t K,
                                   float Pc, float Einj_i, float& outEresMin){
  float best = 1e30f;
  uint32_t bestIdx = 0xFFFFFFFFu;

  for(uint32_t k=0;k<K;++k){
    uint32_t j = cand[k];
    uint32_t m = meta32[j];

    // Excluir VOID/INVISIBLE/EJECT_PENDING: no son residentes vÃ¡lidos a desplazar
    uint32_t bad = (m & (F_VOID_READY | F_INVISIBLE | F_EJECT_PENDING)) != 0u;
    if(bad) continue;

    float er = Eres(j, b.M12, Pc);
    // mÃ­nimo determinista
    if(er < best){ best = er; bestIdx = j; }
  }
  outEresMin = best;
  return bestIdx;
}

V.5. Protocolo de nacimiento (dos caminos) sin locks ni stutter:
static inline uint32_t OracleWar(int st){ return (st==ATAQUE || st==LOCKDOWN); }

// Aplica como K3 (eventos), fuera del hot-loop de fÃ­sica/render.
void ProcessBirthBatch(uint32_t maxBirthsPerFrame){
  uint32_t n=0;
  BirthReq b;
  while(n<maxBirthsPerFrame && gBirthQ.pop(b)){
    // 1) AdmisiÃ³n por Horizonte (Ley IX) con margen:
    if(b.Einf < (Emin_t + dE_birth)) continue; // reject silencioso (no ocupa silicio)

    // 2) Intento Camino VacÃ­o:
    uint32_t slot;
    if(VoidPop(slot)){ // Ley VIII: Treiber stack lock-free
      // Commit de identidad + estado inicial (Ley I + ramp-up)
      BirthCommit(b, slot);  // define UID64/epoch/Atlas/meta (Ley I)
      SeedStateRamp(slot, b); // x_seed+delta, v=0, risk/shock ramp
      ++n; continue;
    }

    // 3) Si no hay vacÃ­o: Camino Desplazamiento (si guerra, se restringe)
    if(OracleWar(oracleState)) {
      // En ataque/lockdown: prohibido desplazar por presiÃ³n local (evita purgas inducidas).
      // Se re-encola con backoff determinista (no bloqueo).
      gBirthQ.push(b);
      break;
    }

    // 4) Construir candidatos C(c,t) (top-K + reservoir fijo)
    uint32_t cand[KCAND_MAX];
    uint32_t K = GatherCandidates(b.seedx,b.seedy,b.seedz,b.M12,cand);

    // 5) PresiÃ³n de celda Pc (O(1) desde contadores coarse precomputados por batch)
    float Pc = CellPressure(b.M12);

    // 6) Einj y selecciÃ³n de vÃ­ctima
    float Einj_i = Einj(b, Pc, /*dOmegaMax*/1.f);
    float EresMin;
    uint32_t jstar = SelectVictim(b, cand, K, Pc, Einj_i, EresMin);
    if(jstar==0xFFFFFFFFu) { gBirthQ.push(b); break; }

    // 7) Criterio de desplazamiento con histÃ©resis
    if(Einj_i <= EresMin*(1.f + eta_hys)) {
      gBirthQ.push(b); // no excede anclaje â‡’ no nace
      break;
    }

    // 8) Sentenciar vÃ­ctima (Ley IX/V) sin bloquear
    uint32_t mj = meta32[jstar];
    mj |= F_EJECT_PENDING;            // Ley IX: muerte ordenada
    mj &= ~F_INVISIBLE;               // el renderer puede mantener cicatriz, pero fÃ­sica/consenso se gatea por MASK_SKIP
    meta32[jstar] = mj;
    MarkOmegaAccelerated(jstar);      // Ley V: TSD_FAST, estado OMEGA acelerado

    // 9) El nacimiento queda pendiente: ocurrirÃ¡ cuando VoidPool reciba slot (Ley VIII).
    // Se re-encola; no hay busy-wait.
    gBirthQ.push(b);
    ++n;
  }
}

V.6. SemÃ¡ntica de ramp-up (sin flashes; branchless por mÃ¡scara):
void SeedStateRamp(uint32_t s, const BirthReq& b){
  // jitter determinista a partir de epoch/slot (Ley I):
  float dx,dy,dz; JitterFromSlotEpoch(s, dx,dy,dz);

  posx[s]=b.seedx+dx; posy[s]=b.seedy+dy; posz[s]=b.seedz+dz;
  velx[s]=0.f; vely[s]=0.f; velz[s]=0.f;
  risk[s]=0.f; shock[s]=0.f;  // ramp-up posterior en K1 (Ley IV/IX)

  // STATUS4 = ALFA_BORN (ver Art. VII); visible pero con rampa de fuerzas
  uint32_t m = meta32[s];
  m = (m & ~MASK_STATUS4) | (STATUS_ALFA_BORN << 20);
  meta32[s]=m;
}

V.7. PublicaciÃ³n y coherencia (release/acquire):
Toda escritura de Atlas/meta/estado para nacimientos se publica por swap de punteros o fence de publicaciÃ³n del buffer inactivo (Ley VIII). Se prohÃ­be exponer parcialmente un nacido: primero identidad+estado, luego publicaciÃ³n.

ARTÃCULO VI â€” Modelo de Coste y Presupuesto de Rendimiento (Nacimiento bajo 16.67ms)
VI.1. Kernels soberanos (por kernel, no agregado):


K_BIRTH_Q (entrada): pop de SPSC + checks de Horizonte.


K_BIRTH_V (vacÃ­o): VoidPop + BirthCommit + SeedStateRamp.


K_BIRTH_D (desplazamiento): gather de candidatos + evaluaciÃ³n EinjE_{\mathrm{inj}}Einjâ€‹ y EresE_{\mathrm{res}}Eresâ€‹ + set de F_EJECT_PENDING + MarkOmegaAccelerated.


K_BIRTH_P (publicaciÃ³n): swap/acquire-release del buffer inactivo (si aplica).


VI.2. Presupuesto fijo constitucional (no negociable):


K_BIRTH_Qâ‰¤0.05â€‰msK\_{BIRTH\_Q} \le 0.05\,\mathrm{ms}K_BIRTH_Qâ‰¤0.05ms


K_BIRTH_Vâ‰¤0.30â€‰msK\_{BIRTH\_V} \le 0.30\,\mathrm{ms}K_BIRTH_Vâ‰¤0.30ms (limitado por births_per_frame)


K_BIRTH_Dâ‰¤0.25â€‰msK\_{BIRTH\_D} \le 0.25\,\mathrm{ms}K_BIRTH_Dâ‰¤0.25ms (limitado por candidatos KKK y churn)


K_BIRTH_Pâ‰¤0.05â€‰msK\_{BIRTH\_P} \le 0.05\,\mathrm{ms}K_BIRTH_Pâ‰¤0.05ms
y ademÃ¡s:


births_per_frameâ‰¤Bmaxâ¡,si excede, se encola (no bloquea)births\_per\_frame \le B_{\max},\qquad \text{si excede, se encola (no bloquea)}births_per_frameâ‰¤Bmaxâ€‹,si excede, se encola (no bloquea)
VI.3. Coste por operaciÃ³n (ciclos, dominio):


VoidPop: CAS loop esperado bajo baja contenciÃ³n; en tormenta aumenta fallos CAS â‡’ por eso se rate-limita.


SelectVictim: KKK lecturas de meta32 + KKK evaluaciones de EresE_{\mathrm{res}}Eresâ€‹ (ALU-dominante) â‡’ O(K)O(K)O(K) con KKK pequeÃ±o y fijo (top-K).


BirthCommit: inserciÃ³n Cuckoo (Ley VII) domina; se ejecuta solo cuando hay slot real o batch controlado.


VI.4. DegradaciÃ³n segura (tormenta de churn / guerra):


En ATAQUE/LOCKDOWN (Ley VI): se prohÃ­be el camino de desplazamiento; solo nacen por vacÃ­o real.


Si gBirthQ se aproxima a saturaciÃ³n: se aplica backpressure (rechazo de nuevos nacimientos bajo Horizonte, o diferido determinista), jamÃ¡s bloqueo.


Si no hay vacÃ­o, el sistema prefiere no nacer antes que contaminar la fÃ­sica con desplazamientos espurios.


ARTÃCULO VII â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para Nacimiento)
VII.1. Grupos de bits relevantes (ratificaciÃ³n de Meta32):


STATUS4 en bits [23:20][23:20][23:20] se utiliza como cÃ³digo de fase de nacimiento sin ampliar bus.


VITAL4 bits [19:16][19:16][19:16] (Ley IX) gobierna exclusiÃ³n/eyecciÃ³n; nacimiento no los viola.


FLAGS4 bits [27:24][27:24][27:24] (Ley IX) incluye DISPUTA/FLASH/VOID_READY/AGONY; nacimiento debe respetarlos.


ID16 bits [15:0][15:0][15:0] (Ley I) mantiene clase/identidad; nacimiento puede escribir solo CLS (clase) y no muta epoch/UID.


VII.2. MÃ¡scaras y cÃ³digos STATUS4 (hex y shift):
static constexpr uint32_t MASK_STATUS4      = 0x00F00000u;
static constexpr uint32_t STATUS_SHIFT      = 20;

// CÃ³digos STATUS4 (4 bits) compatibles con Ley V:
// 0x0 = ALFA_STABLE
// 0x1 = ALFA_BORN        (reciÃ©n nacido: ramp-up fuerzas/energÃ­a)
// 0x2 = ALFA_TRANSIT     (transmigraciÃ³n/ajuste local)
// 0x8..0xF reservados para SIGMA/OMEGA segÃºn Ley V (no redefinir aquÃ­)
static constexpr uint32_t STATUS_ALFA_STABLE = 0x0u;
static constexpr uint32_t STATUS_ALFA_BORN   = 0x1u;
static constexpr uint32_t STATUS_ALFA_TRANS  = 0x2u;

static inline uint32_t GetStatus4(uint32_t m){ return (m & MASK_STATUS4) >> STATUS_SHIFT; }
static inline uint32_t SetStatus4(uint32_t m, uint32_t s4){
  return (m & ~MASK_STATUS4) | ((s4 & 0xFu) << STATUS_SHIFT);
}

VII.3. Flags existentes usados por Ley II (sin inventar nuevos bits altos):
Ley II sentencia desplazamiento y sincroniza con Ley IX/V/VIII usando flags ya soberanos:


F_EJECT_PENDING = 0x00020000u (bit17, Ley IX) â€” â€œdesplazado / muerte ordenadaâ€


F_INVISIBLE = 0x00010000u (bit16, Ley IX) â€” â€œexclusiÃ³n fÃ­sica/consensoâ€ (se activa por Ley IX; nacimiento no la fuerza salvo por mÃ¡scara del sistema)


F_VOID_READY = 0x04000000u (bit26, Ley VIII) â€” â€œslot en OMEGA-ZERO listo para reclamoâ€


F_AGONY = 0x08000000u (bit27, Ley IX) â€” gobernado por Horizonte, no por nacimiento


VII.4. Reglas branchless obligatorias (fase de nacido y gating):
// marcar "reciÃ©n nacido" (STATUS4) sin branching pesado:
meta32[s] = SetStatus4(meta32[s], STATUS_ALFA_BORN);

// salir de nacido a estable cuando termina rampa (g==1):
uint32_t done = (uint32_t)-(g >= 1.f); // 0xFFFFFFFF si completÃ³
uint32_t m = meta32[s];
uint32_t s4 = GetStatus4(m);
uint32_t s4_new = (s4 & ~done) | (STATUS_ALFA_STABLE & done); // branchless select
meta32[s] = SetStatus4(m, s4_new);

// participaciÃ³n fÃ­sica siempre por mÃ¡scara (Ley IX):
uint32_t live_mask = (uint32_t)-((meta32[s] & MASK_SKIP_PHYS) == 0u);

VII.5. CondiciÃ³n formal de â€œnacimiento consumadoâ€:
Un activo se considera â€œnacidoâ€ (dinÃ¡micamente acoplado) si:
BORN_DONEi(t)=1[STATUS4=ALFA_STABLE] âˆ§ 1[g(tâˆ’t0)=1]\mathrm{BORN\_DONE}_i(t)=1\Big[\mathrm{STATUS4}=ALFA\_STABLE\Big]\ \wedge\ 1\Big[g(t-t_0)=1\Big]BORN_DONEiâ€‹(t)=1[STATUS4=ALFA_STABLE] âˆ§ 1[g(tâˆ’t0â€‹)=1]
Hasta entonces, existe topolÃ³gicamente pero su influencia fÃ­sica estÃ¡ rampada.

AXIOMA FINAL
â€œNacer en TITAN V8 es desplazar: ninguna singularidad existe sin exceder el anclaje del sitio por impacto, movilidad y barrera.â€

LEY III â€” Dualidad 1:1: Protocolo de SincronÃ­a Determinista y Densidad Inyectada al VBO
Nombre formal: LEY III â€” Dualidad 1:1: Protocolo de SincronÃ­a Determinista y Densidad Inyectada al VBO

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Principio de Dualidad 1:1: SincronÃ­a Determinista Estadoâ€“VÃ©rtice
3. ARTÃCULO II â€” Coeficiente de Densidad (\rho): Variable Operativa de Render sin Floats Extra
4. ARTÃCULO III â€” Densidad y LOD como Parte del Contrato Meta32
5. ARTÃCULO IV â€” Coalescencia y Consistencia: EmisiÃ³n Alineada por Bloques y Orden Morton
6. ARTÃCULO V â€” ImplementaciÃ³n de Bajo Nivel: PseudocÃ³digo Ejecutable C++/WASM (Lock-Free, Branchless, SIMD-Friendly)
7. ARTÃCULO VI â€” Modelo de Coste y Presupuesto de Rendimiento (Dualidad y Densidad)
8. ARTÃCULO VII â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para Dualidad y Densidad)
9. AXIOMA FINAL

Ãmbito
Universo N = 200,000 (cardinalidad fija); 16.67ms/frame; cero micro-stuttering; Ãºnica realidad exportable: Vertex28 (stride 28 bytes); arquitectura interna SoA libre, pero toda causalidad visual y contractual se resuelve por serializaciÃ³n determinista estadoâ†’vÃ©rtice. IntegraciÃ³n estricta con Ley I (Identidad/UID64â†’IDX16) + Ley II (Nacimiento/ramp-up/ALFA_BORN) + Ley IV (Manifold/Langevin/fuerzas y clamps) + Ley V (Tsallis/TSD/ALFAâ€“SIGMAâ€“OMEGA y lectura de LOD/TSD en Meta32) + Ley VI (OrÃ¡culo/flags de disputa/flash/lockdown) + Ley IX (Horizonte/Masa mÃ­nima/AGONY/EJECT_PENDING y gating por mÃ¡scara).

LEY III â€” Dualidad 1:1: Protocolo de SincronÃ­a Determinista y Densidad Inyectada al VBO


Dictamen ontolÃ³gico: En TITAN V8 no existe estado si no puede colapsar en un vÃ©rtice. Lo no serializable es ruido privado; lo privado no gobierna el frame.

---

ARTÃCULO I â€” Principio de Dualidad 1:1: SincronÃ­a Determinista Estadoâ€“VÃ©rtice

I.1. Axioma de la Realidad Exportable (VBO = Realidad):
Sea el estado interno por activo (i) un vector (\mathbf{s}_i(t)\in\mathbb{R}^{d}) distribuido en SoA (Ley IV/V/VI/VII/IX). Se define el operador de colapso (serializaciÃ³n) como:
[
\mathcal{S}:\ \mathbf{s}_i(t)\ \mapsto\ \mathbf{v}_i(t)\in{0,1}^{224}
]
donde (\mathbf{v}_i(t)) es el Vertex28 (224 bits). Se dicta:

* Realidad exportable (\equiv) (\mathbf{v}_i(t)).
* Toda lectura del pipeline visual consume solo (\mathbf{v}_i(t)); cualquier dato no contenido o derivable de Ã©l es no-fÃ­sico a efectos de render.
* La causalidad visual es un invariante de contrato: si no estÃ¡ en Vertex28, no existe.

I.2. Protocolo 1:1 (Asset (\Leftrightarrow) Vertex28):
Se fija un isomorfismo indexado por slot:
[
\forall i\in[0,N):\quad \mathbf{v}_i(t)\ \leftrightarrow\ \text{slot }i
]
y se prohÃ­be compacciÃ³n del VBO que rompa el orden de slots. La correspondencia 1:1 es un invariante temporal: el vÃ©rtice (i) es el espejo del slot (i). La validez del espejo se decide por mÃ¡scara, no por reordenaciÃ³n.

I.3. Determinismo constitucional (doble bÃºfer y borde de frame):
Sea (\mathbf{V}^{front}(t)) el VBO visible y (\mathbf{V}^{back}(t)) el VBO en construcciÃ³n. Se dicta el commit atÃ³mico del frame:
[
\mathbf{V}^{front}(t)\ \leftarrow\ \mathbf{V}^{back}(t)\quad\text{solo en frontera de frame}
]
mediante publicaciÃ³n release/acquire del puntero o Ã­ndice de bÃºfer. NingÃºn shader consume (\mathbf{V}^{back}) parcialmente. No existe â€œestado intermedioâ€ exportado.

I.4. Ley del Contracto de 28 bytes (prohibiciones absolutas):

* Prohibido aÃ±adir atributos fuera de Vertex28.
* Prohibido depender de doubles, strings, mapas dinÃ¡micos o punteros en el contrato visual.
* Prohibido â€œresolver densidadâ€ mediante estructuras GPU no deterministas sin reflejo bitwise en Meta32 o derivaciÃ³n determinista del propio Vertex28.
* Prohibido any-branching dependiente de datos inestables en el hot-loop de serializaciÃ³n: el gating es por bitmasking.

---

ARTÃCULO II â€” Coeficiente de Densidad (\rho): Variable Operativa de Render sin Floats Extra

II.1. DefiniciÃ³n de densidad operativa (\rho) (discreta, local, O(N)):
Se define una particiÃ³n espacial coarse por celda Morton (c=M_{12}(i)\in[0,2^{12})). Para cada frame:
[
n_c(t)=\sum_{i=0}^{N-1} \mathbf{1}\big[\text{LIVE}*i(t)\wedge M*{12}(i)=c\big]
]
y se define densidad por celda:
[
\rho_c(t)=\frac{n_c(t)}{A_c}\qquad(\text{con }A_c\text{ constante y absorbible})
]
y densidad por activo (operativa):
[
\rho_i(t)=\rho_{M_{12}(i)}(t)
]
Dictamen: en TITAN V8 la densidad no es un cÃ¡lculo continuo caro; es una medida termodinÃ¡mica discreta computable por conteo.

II.2. CuantizaciÃ³n obligatoria (\rho\rightarrow\rho^{Q8}) (sin floats extra):
La densidad no viaja como float; viaja como byte inyectado en Meta32:
[
\rho^{Q8}*i(t)=\mathrm{clamp}*{[0,255]}!\left(\left\lfloor
255\cdot \frac{\log(1+n_{M_{12}(i)}(t))}{\log(1+n_{\mathrm{ref}})}
\right\rceil\right)
]
donde (n_{\mathrm{ref}}) es setpoint constitucional (p.ej. cuantil fijo o valor de rÃ©gimen) y el log garantiza sensibilidad a colas (Pareto de ocupaciÃ³n).

II.3. Densidad como presiÃ³n de oclusiÃ³n (anti-ruido visual):
Se define el factor de oclusiÃ³n:
[
\Omega_i(t)=\mathrm{sat}_{[0,1]}!\left(\frac{\rho^{Q8}_i(t)}{255}\right)
]
y se impone que (\Omega) modula alpha y LOD (Art. III) para evitar saturaciÃ³n del pipeline y preservar SNR visual.

II.4. Densidad bajo guerra (Ley VI) y bajo purga (Ley IX):
Si (OracleState\in{\mathrm{ATAQUE},\mathrm{LOCKDOWN}}), la densidad no se usa para expulsar ni para alterar estados vitales; se usa solo como modulador visual (size/alpha/LOD). La densidad jamÃ¡s se convierte en instrumento de purga: la purga es Ley IX.

---

ARTÃCULO III â€” Densidad y LOD como Parte del Contrato Meta32

III.1. Meta32 como puente soberano motorâ†”visual:
Meta32 (uint32) es el Ãºnico canal de estados discretos y banderas que gobierna: existencia, rÃ©gimen termodinÃ¡mico, LOD, diseÃ±o de render y cortes. Lo que no estÃ© codificado en Meta32 o derivable del Vertex28 es inexistente visualmente.

III.2. LOD4 (bits [31:28]) como decimaciÃ³n determinista:
En rÃ©gimen ALFA (STATUS4 en ([23:20]) < 0x8), los bits ([31:28]) se interpretan como (LOD4\in[0,15]) con semÃ¡ntica:

* (LOD4=0): fidelidad mÃ¡xima (sin decimaciÃ³n).
* (LOD4\to 15): fidelidad mÃ­nima (punto pequeÃ±o, alpha reducida, shading simplificado).

Se dicta la ley de LOD por densidad+presiÃ³n+energÃ­a (sin branching):
[
LOD4_i(t)=\mathrm{clamp}*{[0,15]}!\left(
\left\lfloor L_0 + k*\rho,\Omega_i(t) + k_q,\Theta(t) - k_E,\mathrm{sat}!\big(E_i(t)/E_0\big)\right\rceil
\right)
]
donde (\Theta(t)=\mathrm{sat}\big((q(t)-q^\star)/\Delta q\big)) (Ley V).
Dictamen: a mayor densidad y entropÃ­a, mayor LOD (mÃ¡s disipaciÃ³n visual); a mayor energÃ­a informacional, menor LOD (se preserva seÃ±al).

III.3. RÃ©gimen SIGMA/OMEGA: prioridad de TSD sobre LOD:
Si STATUS4 (\ge 0x8) (SIGMA/OMEGA), bits ([31:28]) se interpretan como TSD_hi4 (Ley V/IX). En ese rÃ©gimen el LOD se deriva de TSD:
[
LOD4_i(t)=\mathrm{map}\big(TSD8_i(t)\big)
]
y queda prohibido sobrescribir TSD_hi4 con LOD. La termodinÃ¡mica manda; el render obedece.

III.4. Densidad embebida en Meta32 (bits bajos):
Se asigna contractualmente (\rho^{Q8}) al rango ([15:8]) y se reserva ([7:0]) para cuantizaciones auxiliares de render (Art. VII). NingÃºn byte extra.

---

ARTÃCULO IV â€” Coalescencia y Consistencia: EmisiÃ³n Alineada por Bloques y Orden Morton

IV.1. EmisiÃ³n contigua por Ã­ndice de slot (no compacciÃ³n):
El VBO se escribe en orden (i=0..N-1). Esta polÃ­tica fija:

* ancho de banda constante, sin jitter;
* direcciones contiguas, vectorizables;
* latencia estable: (O(N)) fijo.
  El culling se hace por alpha/size=0 y flags, no por reordenaciÃ³n.

IV.2. Orden Morton interno (mejora de cachÃ© sin violar 1:1):
Aunque el VBO es por Ã­ndice de slot, el sistema interno debe mantener vecindad Morton en SoA (Ley I) y producir agregados por celda (M_{12}) sin saltos de cachÃ©:

* conteos de densidad por celda: lectura secuencial de (M_{12}) y meta;
* acceso a vecinos: prefetch por ventanas de celdas contiguas.
  La localidad Morton optimiza la fÃ­sica; la dualidad 1:1 preserva la ontologÃ­a visual.

IV.3. Streaming del VBO (doble bÃºfer, sin locks):
Se dicta un protocolo de streaming:

1. `AcquireBackVBO()` devuelve puntero a (\mathbf{V}^{back}) preasignado.
2. Se escribe (\mathbf{v}_i) para todos los (i) (o rangos deterministas).
3. `PublishVBO()` publica el bÃºfer completo por store_release.
   El renderer consume por load_acquire. No existe upload parcial no determinista que fracture el frame.

IV.4. Datos que â€œno cabenâ€ (derivaciÃ³n soberana):

* Propiedades continuas no caben: se cuantizan a bytes/bits (Meta32 o pack32).
* Funciones caras no caben: se derivan en shader a partir de `hid32` (seed) y flags.
* SeÃ±al estructural (estado/vida): se expresa por STATUS4/FLAGS4/VITAL4 (Meta32).
  Lo que no se cuantiza/deriva se prohÃ­be.

---

ARTÃCULO V â€” ImplementaciÃ³n de Bajo Nivel: PseudocÃ³digo Ejecutable C++/WASM (Lock-Free, Branchless, SIMD-Friendly)

V.1. Contrato Vertex28 (224 bits) y layout byte-perfect:
Se dicta el layout de 28 bytes, alineado a 4 bytes, sin padding oculto:

* `float x` (4)
* `float y` (4)
* `float z` (4)  â†’ 12
* `uint32 meta32` (4) â†’ 16
* `uint32 hid32`  (4) â†’ 20
* `uint32 pack32` (4) â†’ 24
* `uint16 idx16`  (2) â†’ 26
* `uint16 cls16`  (2) â†’ 28

Con `pack32` definido como:
[
pack32 = (risk^{Q8}\ll 24)\ |\ (shock^{Q8}\ll 16)\ |\ (alpha^{Q8}\ll 8)\ |\ (aux^{Q8})
]
y `hid32` como semilla estable (sub-hash del UID64 o hash de identidad; Ley I).

V.2. Kernel K_DENSITY (conteo por celda, O(N), estable):

```cpp
static constexpr uint32_t NCELL = 1u << 12;   // M12
alignas(64) uint32_t cellCount[NCELL];

static inline uint32_t LiveForDensity(uint32_t m){
  // excluye VOID definitivo; AGONY/EJECT pueden contar o no segÃºn polÃ­tica: aquÃ­ cuentan como masa visible mÃ­nima
  return (uint32_t)-((m & F_VOID_READY) == 0u);
}

void K_DENSITY_buildCounts(){
  // memset fijo (NCELL pequeÃ±o, estable)
  for(uint32_t c=0;c<NCELL;++c) cellCount[c]=0u;

  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta32[i];
    uint32_t live = LiveForDensity(m) & 1u; // 0 o 1
    uint32_t c = morton12[i];               // M12 precomputado
    cellCount[c] += live;                   // single-thread o reducciÃ³n por chunks si MT
  }
}
```

V.3. Kernel K_SERIALIZE (densidadâ†’Meta32, PointSize derivable, 1:1):

```cpp
struct Vertex28 {
  float x, y, z;       // 12 B
  float risk;          // 4 B  -> 16
  float shock;         // 4 B  -> 20
  uint32_t meta32;     // 4 B  -> 24
  uint16_t idx16;      // 2 B  -> 26
  uint16_t pad16;      // 2 B  -> 28
};
static_assert(sizeof(Vertex28) == 28, "Vertex28 stride must be 28 bytes");static inline uint8_t QuantLogCount(uint32_t n, uint32_t nref){
  // rhoQ8 = round(255*log1p(n)/log1p(nref))
  float a = log1pf((float)n);
  float b = log1pf((float)nref);
  float q = (b>0.f)? (a/b) : 0.f;
  int v = (int)lrintf(255.f * fminf(1.f, fmaxf(0.f, q)));
  return (uint8_t)v;
}

static inline uint8_t Q8(float x){ return (uint8_t)lrintf(255.f * sat01(x)); }

static inline uint32_t SetRho8(uint32_t m, uint8_t rho){
  // bits [15:8]
  return (m & ~0x0000FF00u) | ((uint32_t)rho << 8);
}

void K_SERIALIZE_writeVBO(Vertex28* out, uint32_t nref){
  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta32[i];

    // LIVE mask branchless: 0xFFFFFFFF si participa visualmente, 0 si VOID definitivo
    uint32_t live = (uint32_t)-((m & F_VOID_READY) == 0u);

    // densidad por celda -> rhoQ8
    uint32_t c = morton12[i];
    uint8_t rho = QuantLogCount(cellCount[c], nref);

    // inyectar rho en meta32 (sin floats extra)
    m = SetRho8(m, rho);

    // LOD4 en ALFA: calcula y escribe solo si STATUS4 < 0x8
    uint32_t status4 = (m & 0x00F00000u) >> 20;
    if(status4 < 0x8u){
      float Omega = (float)rho * (1.0f/255.0f);
      float Th = Theta(q_global);
      float E = sat01(EnergyProxy(i)/E0);     // proxy Ley IX
      int lod = (int)lrintf(L0 + kRho*Omega + kQ*Th - kE*E);
      lod = (lod<0)?0: (lod>15?15:lod);
      m = (m & 0x0FFFFFFFu) | ((uint32_t)lod << 28);
    }

    // alphaQ8 (gating sin compacciÃ³n): invisible/agonÃ­a reduce, pero no borra el vÃ©rtice
    uint32_t invisible = (m & F_INVISIBLE) != 0u;
    uint32_t ejectp    = (m & F_EJECT_PENDING) != 0u;
    float a = 1.f;
    a *= 1.f - 0.85f* (float)invisible;
    a *= 1.f - 0.50f* (float)ejectp;
    uint8_t alpha = Q8(a);

    // pack32
    uint8_t rq = Q8(sat01(risk[i]/R0));
    uint8_t sq = Q8(sat01(shock[i]/S0));
    uint32_t pack = ((uint32_t)rq<<24) | ((uint32_t)sq<<16) | ((uint32_t)alpha<<8) | (uint32_t)Aux8(i);

    // escritura branchless (live mask): si VOID -> cero
    float fx = posx[i], fy = posy[i], fz = posz[i];
    uint32_t hid = hid32[i];
    uint16_t cls = cls16[i];

    out[i].x   = live ? fx : 0.f;
    out[i].y   = live ? fy : 0.f;
    out[i].z   = live ? fz : 0.f;
    out[i].meta= live ? m  : (m | F_VOID_READY); // marca coherente
    out[i].hid = live ? hid: 0u;
    out[i].pack= live ? pack: 0u;
    out[i].idx = (uint16_t)i;
    out[i].cls = cls;

    meta32[i] = m; // commit de rho/LOD al mundo interno (si procede)
  }
}
```

V.4. Kernel K_STREAM (doble bÃºfer, publicaciÃ³n atÃ³mica):

```cpp
Vertex28* AcquireBackVBO();     // puntero pre-map o buffer CPU fijo
void PublishVBO();              // store_release del Ã­ndice/puntero de front

void Frame_VBOCommit(uint32_t nref){
  Vertex28* back = AcquireBackVBO();
  K_DENSITY_buildCounts();
  K_SERIALIZE_writeVBO(back, nref);
  PublishVBO();                 // commit soberano del frame
}
```

V.5. PointSize en shader como observable fÃ­sico (sin float extra):
Sea (\Omega_i=\rho^{Q8}*i/255). Se define el tamaÃ±o como funciÃ³n derivada, clampada:
[
PointSize_i(t)=\mathrm{clip}\Big(p_0+p_r,\mathrm{sat}(risk^{Q8}*i)+p_s,\mathrm{sat}(shock^{Q8}*i)-p*\rho,\Omega_i,\ p*{\min},\ p*{\max}\Big)
]
donde (risk^{Q8}) y (shock^{Q8}) viajan en `pack32`. El shader decodifica bytes; no hay floats adicionales.

---

ARTÃCULO VI â€” Modelo de Coste y Presupuesto de Rendimiento (Dualidad y Densidad)

VI.1. Kernels soberanos (por kernel, no agregado):

* K_DENSITY_CALC: zero de `cellCount` + acumulaciÃ³n (n_c).
* K_VBO_SYNC: serializaciÃ³n completa de N vÃ©rtices a Vertex28 + publicaciÃ³n.
* K_SHADER_DERIVE: derivaciones deterministas (PointSize/alpha/color) a partir de bytes/bits (coste GPU, no CPU).

VI.2. Presupuesto fijo constitucional (16.67ms/frame):

* (K_{DENSITY_CALC} \le 0.35,\mathrm{ms}) (NCELL pequeÃ±o, streaming lineal).
* (K_{VBO_SYNC} \le 1.80,\mathrm{ms}) (escritura secuencial 28BÂ·N, sin locks).
* La serializaciÃ³n es (O(N)) fijo; su latencia no oscila con carga del mercado, solo con N (inmutable).

VI.3. Desglose de coste por vÃ©rtice (dominio de ciclos):
Por activo:

* 1 load `meta32`, 1 load `morton12`, 3 loads pos, 2 loads risk/shock, 1 store Vertex28Ã—7 campos, 1 store meta32.
* ALU: cuantizaciÃ³n log1p amortizada por densidad (se hace por celda/byte; el log1p de n puede pretabularse por rango de conteos).
  Se dicta optimizaciÃ³n legal: LUT de (\log(1+n)) para (n\in[0,N]) con quantizaciÃ³n por buckets (sin doubles en hot-loop).

VI.4. Estabilidad bajo churn (Ley IX/II):
La dualidad 1:1 impide picos por compacciÃ³n. En churn masivo, el coste del VBO permanece constante; el â€œapagadoâ€ de miles de slots es por alpha/size y `F_VOID_READY`, no por rearmado de buffers.

---

ARTÃCULO VII â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para Dualidad y Densidad)

VII.1. RatificaciÃ³n de layout Meta32 (compatibilidad Ley Vâ€“VIâ€“VIIIâ€“IX):

* Bits ([31:28]): LOD4 (ALFA) o TSD_hi4 (SIGMA/OMEGA).
* Bits ([27:24]): FLAGS4 (Ley IX): DISPUTA/FLASH/VOID_READY/AGONY.
* Bits ([23:20]): STATUS4 (Ley II/V): ALFA_BORN/ALFA_STABLE/SIGMA/OMEGAâ€¦
* Bits ([19:16]): VITAL4 (Ley IX): INVISIBLE/EJECT_PENDING/VOL_FAKE/AGONY_FREEZE.
* Bits ([15:8]): RHO8 (LEY III): densidad cuantizada (\rho^{Q8}).
* Bits ([7:4]): PS4 (LEY III): base de tamaÃ±o cuantizada (opcional; shader).
* Bits ([3:0]): MAT4 (LEY III): material/paleta/estilo (derivable de DNA/HID).

VII.2. MÃ¡scaras hex y operaciones obligatorias:

```cpp
// Campos Ley III:
static constexpr uint32_t MASK_RHO8   = 0x0000FF00u; // bits [15:8]
static constexpr uint32_t MASK_PS4    = 0x000000F0u; // bits [7:4]
static constexpr uint32_t MASK_MAT4   = 0x0000000Fu; // bits [3:0]

// Campos superiores (ratificados por Ley IX):
static constexpr uint32_t MASK_LOD4   = 0xF0000000u; // [31:28]
static constexpr uint32_t MASK_FLAGS4 = 0x0F000000u; // [27:24]
static constexpr uint32_t MASK_STATUS4= 0x00F00000u; // [23:20]
static constexpr uint32_t MASK_VITAL4 = 0x000F0000u; // [19:16]

// Branchless getters:
static inline uint32_t GetRho8(uint32_t m){ return (m & MASK_RHO8) >> 8; }
static inline uint32_t GetLod4(uint32_t m){ return (m & MASK_LOD4) >> 28; }

// Branchless setters:
static inline uint32_t SetRho8(uint32_t m, uint32_t r){
  return (m & ~MASK_RHO8) | ((r & 0xFFu) << 8);
}
static inline uint32_t SetLod4(uint32_t m, uint32_t l){
  return (m & ~MASK_LOD4) | ((l & 0xFu) << 28);
}
```

VII.3. Regla de existencia visual (gating por mÃ¡scara, coste ~0):
Se ratifica la mÃ¡scara de exclusiÃ³n fÃ­sica/visual mÃ­nima (Ley IX) y se aplica al VBO sin compacciÃ³n:

```cpp
static constexpr uint32_t MASK_SKIP_VBO = (F_VOID_READY); // el Ãºnico borrado real
static constexpr uint32_t MASK_DIM_VBO  = (F_INVISIBLE | F_EJECT_PENDING | F_AGONY);

uint32_t live_mask = (uint32_t)-((meta32[i] & MASK_SKIP_VBO) == 0u);
// live_mask: 0xFFFFFFFF => escribe vertex real; 0 => escribe cero
```

Si `MASK_DIM_VBO` estÃ¡ activo, el vÃ©rtice permanece pero su `alphaQ8` y/o `PointSize` se disipa. La dualidad 1:1 permanece intacta.

VII.4. ProhibiciÃ³n de divergencia semÃ¡ntica:

* Prohibido que un dato gobierne el render si no estÃ¡ en Meta32/pack32/hid32 o derivable determinÃ­sticamente.
* Prohibido que el renderer interprete un bit con semÃ¡ntica distinta a la definida aquÃ­ o en Ley IX/V.
* Prohibido que la densidad altere estados vitales (AGONY/EJECT); densidad altera solo observables visuales y LOD.

---

AXIOMA FINAL

â€œNingÃºn dato existe en TITAN V8 si no puede ser serializado en Vertex28 y sincronizado 1:1 con su vÃ©rtice.â€

LEY IV â€” JerarquÃ­a y DinÃ¡mica SistÃ©mica: Motor de TransmigraciÃ³n, VacÃ­os y Estabilidad HPC bajo el Bus Vertex28
Nombre formal: LEY IV â€” JerarquÃ­a y DinÃ¡mica SistÃ©mica: Motor de TransmigraciÃ³n, VacÃ­os y Estabilidad HPC bajo el Bus Vertex28

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Principios de No-NegociaciÃ³n y Manifold Riemanniano Conformal
3. ARTÃCULO II â€” Estado fÃ­sico mÃ­nimo por activo y movilidad
4. ARTÃCULO III â€” Tensor de afinidad y acoplamiento esparso
5. ARTÃCULO IV â€” FunciÃ³n de pertenencia/impacto
6. ARTÃCULO V â€” JerarquÃ­a (Ã¡rbol) + dinÃ¡mica (grafo) y representantes NodeAgg
7. ARTÃCULO VI â€” Campo de fuerzas total: conservativo + acoplamiento + fluidos clÃ¡sicos
8. ARTÃCULO VII â€” Barreras de Cauchy adaptativas y contracciÃ³n en crisis
9. ARTÃCULO VIII â€” EcuaciÃ³n maestra (Langevin clÃ¡sico en manifold conformal)
10. ARTÃCULO IX â€” Tsallis, presiÃ³n sistÃ©mica y enfriamiento simulado (sin reset)
11. ARTÃCULO X â€” Ruptura, transmigraciÃ³n, cascada limitada y llenado de vacÃ­os
12. ARTÃCULO XI â€” IntegraciÃ³n temporal:
13. ARTÃCULO XII â€” ImplementaciÃ³n de bajo nivel (C++/WASM): lock-free, branchless, SIMD-friendly
14. ARTÃCULO XIII â€” Modelo de coste y presupuesto de rendimiento (dinÃ¡mica sistÃ©mica)
15. ARTÃCULO XIV â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para dinÃ¡mica sistÃ©mica)
16. AXIOMA FINAL

Ãmbito
Universo N = 200,000 (capacidad fÃ­sica fija); 16.67ms/frame; cero micro-stuttering en el hot-loop; float32-safe (NaN/Inf prohibidos por ConstituciÃ³n); salida Ãºnica hacia render: Vertex28 (stride 28 bytes), sincronizado 1:1 (Ley III). Complejidad operativa objetivo O(N log N) mediante Morton + Ã¡rbol lineal (Barnesâ€“Hut) + NodeAgg, y O(NÂ·K) para acoplamientos locales con K â‰¤ 50 (Top-K con histÃ©resis). IntegraciÃ³n estricta con: Ley I (IDX16/UID64â†’hid32 y Morton), Ley II (Nacimiento como inyecciÃ³n con ramp-up), Ley III (Dualidad 1:1, densidad y LOD), Ley V (Tsallis/TSD/ALFAâ€“SIGMAâ€“OMEGA), Ley VI (OrÃ¡culo/ATAQUE/LOCKDOWN y flags DISPUTA/FLASH), Ley VII (Atlas SoA/DNA/SENT8), Ley VIII (VoidPool/ReencarnaciÃ³n lock-free) y Ley IX (Horizonte, AGONY/EJECT_PENDING y gating por mÃ¡scara).

LEY IV â€” JerarquÃ­a y DinÃ¡mica SistÃ©mica: Motor de TransmigraciÃ³n, VacÃ­os y Estabilidad HPC bajo el Bus Vertex28


ARTÃCULO I â€” Principios de No-NegociaciÃ³n y Manifold Riemanniano Conformal
I.1. Bus de Estado Ãšnico: Vertex28 como axioma de salida

I.1.1. Todo solver, aproximador, agregador o integrador debe colapsar su estado a Vertex28:

ğ‘†
:

ğ‘ 
ğ‘–
(
ğ‘¡
)

â†¦

ğ‘£
ğ‘–
(
ğ‘¡
)
âˆˆ
{
0
,
1
}
224
(
Vertex28
)
S: s
i
	â€‹

(t) â†¦ v
i
	â€‹

(t)âˆˆ{0,1}
224
(Vertex28)

I.1.2. La fÃ­sica interna puede usar SoA/HPC, pero la realidad exportable es solo
ğ‘£
ğ‘–
(
ğ‘¡
)
v
i
	â€‹

(t). Si un observable no cabe, se cuantiza (Meta32/pack32) o se deriva determinÃ­sticamente en shader desde hid32+bits.

I.2. Purga de formalismo cuÃ¡ntico: dinÃ¡mica clÃ¡sica determinista y cerrada

I.2.1. â€œVacÃ­oâ€ â‰¡ presiÃ³n clÃ¡sica; â€œarrastreâ€ â‰¡ Stokes; â€œtransiciÃ³nâ€ â‰¡ barrera suave (Cauchy) + histÃ©resis + cooldown.
I.2.2. Toda funciÃ³n crÃ­tica debe ser cerrada (sin â€œmÃ³dulo faltanteâ€): pertenencia/impacto
ğ¼
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
I(i,c,t), acoplamiento
ğ‘‡
ğ‘–
ğ‘—
(
ğ‘¡
)
T
ij
	â€‹

(t), conformalidad
Î©
(
ğ‘¥
,
ğ‘¡
)
Î©(x,t), barreras
ğœ™
ğ‘˜
(
ğ‘¥
,
ğ‘¡
)
Ï•
k
	â€‹

(x,t).
I.2.3. El sistema no admite discontinuidades en posiciones/velocidades por UI: cualquier salto es un evento fÃ­sico (Nacimiento, Ruptura o TransmigraciÃ³n) con protocolo y clamps.

I.3. Manifold riemanniano conformal y mÃ©trica inducida por volatilidad

I.3.1. El espacio visual-fÃ­sico es un manifold
ğ‘€
âŠ‚
ğ‘…
ğ‘‘
MâŠ‚R
d
, con
ğ‘‘
âˆˆ
{
2
,
3
}
dâˆˆ{2,3}. La mÃ©trica es conformal:

ğ‘”
ğœ‡
ğœˆ
(
ğ‘¥
,
ğ‘¡
)
=
Î©
(
ğ‘¥
,
ğ‘¡
)
2

ğ›¿
ğœ‡
ğœˆ
g
Î¼Î½
	â€‹

(x,t)=Î©(x,t)
2
Î´
Î¼Î½
	â€‹


I.3.2. El factor conformal
Î©
Î© se induce por un campo de â€œvolatilidad efectivaâ€
Î£
(
ğ‘¥
,
ğ‘¡
)
Î£(x,t) (de NodeAgg, no de magia):

Î©
(
ğ‘¥
,
ğ‘¡
)
=
Î©
min
â¡
+
(
Î©
max
â¡
âˆ’
Î©
min
â¡
)

ğ‘†
â€‰â£
(
Î£
(
ğ‘¥
,
ğ‘¡
)
âˆ’
Î£
â‹†
Î”
Î£
)
Î©(x,t)=Î©
min
	â€‹

+(Î©
max
	â€‹

âˆ’Î©
min
	â€‹

)S(
Î”Î£
Î£(x,t)âˆ’Î£
â‹†
	â€‹

	â€‹

)

donde
ğ‘†
(
ğ‘¢
)
S(u) es saturaciÃ³n suave float32-safe, por ejemplo:

ğ‘†
(
ğ‘¢
)
=
s
a
t
[
0
,
1
]
â€‰â£
(
1
2
+
1
2
tanh
â¡
(
ğ‘¢
)
)
S(u)=sat
[0,1]
	â€‹

(
2
1
	â€‹

+
2
1
	â€‹

tanh(u))

I.3.3. Distancia geodÃ©sica aproximada (barata, determinista):

ğ‘‘
ğ‘”
(
ğ‘–
,
ğ‘—
)
â‰ˆ
Î©
Ë‰
ğ‘–
ğ‘—
(
ğ‘¡
)

âˆ¥
ğ‘¥
ğ‘–
(
ğ‘¡
)
âˆ’
ğ‘¥
ğ‘—
(
ğ‘¡
)
âˆ¥
,
Î©
Ë‰
ğ‘–
ğ‘—
(
ğ‘¡
)
=
1
2
(
Î©
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
+
Î©
(
ğ‘¥
ğ‘—
,
ğ‘¡
)
)
d
g
	â€‹

(i,j)â‰ˆ
Î©
Ë‰
ij
	â€‹

(t)âˆ¥x
i
	â€‹

(t)âˆ’x
j
	â€‹

(t)âˆ¥,
Î©
Ë‰
ij
	â€‹

(t)=
2
1
	â€‹

(Î©(x
i
	â€‹

,t)+Î©(x
j
	â€‹

,t))

Con clamp duro:
ğ‘‘
ğ‘”
â†
max
â¡
(
ğœ€
ğ‘‘
,
ğ‘‘
ğ‘”
)
d
g
	â€‹

â†max(Îµ
d
	â€‹

,d
g
	â€‹

).
Dictamen: la conformalidad no aÃ±ade coste asintÃ³tico: solo escala distancias en kernels.

ARTÃCULO II â€” Estado fÃ­sico mÃ­nimo por activo y movilidad
ğ‘€
ğ‘–
M
i
	â€‹

II.1. Variables mÃ­nimas y su residencia SoA/Vertex28

Cada activo
ğ‘–
i mantiene (SoA, float32 salvo flags):

PosiciÃ³n
ğ‘¥
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
ğ‘‘
x
i
	â€‹

(t)âˆˆR
d
, velocidad
ğ‘£
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
ğ‘‘
v
i
	â€‹

(t)âˆˆR
d

Riesgo
ğ‘Ÿ
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
r
i
	â€‹

(t)âˆˆR, shock
ğ‘ 
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
s
i
	â€‹

(t)âˆˆR

Liquidez/masa de movilidad
ğœ…
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
+
Îº
i
	â€‹

(t)âˆˆR
+
	â€‹

 (puede ser float32 SoA; su proyecciÃ³n visual se cuantiza)

Contrato de salida (Ley III): Vertex28 porta
ğ‘¥
ğ‘–
x
i
	â€‹

 y meta32, hid32, pack32 (donde pack32 lleva
ğ‘Ÿ
,
ğ‘ 
,
ğ›¼
,
a
u
x
r,s,Î±,aux cuantizados). Nada mÃ¡s.

II.2. Movilidad y fricciÃ³n (Bohrium): Î¼(Îº) acotada

Movilidad escalar (isotrÃ³pica por ConstituciÃ³n, SIMD-friendly):

ğ‘€
ğ‘–
(
ğ‘¡
)
=
ğœ‡
(
ğœ…
ğ‘–
(
ğ‘¡
)
)

ğ¼
ğ‘‘
M
i
	â€‹

(t)=Î¼(Îº
i
	â€‹

(t))I
d
	â€‹


FunciÃ³n de movilidad float32-safe (monÃ³tona, saturada):

ğœ‡
(
ğœ…
)
=
ğœ‡
min
â¡
+
(
ğœ‡
max
â¡
âˆ’
ğœ‡
min
â¡
)

s
a
t
[
0
,
1
]
â€‰â£
(
log
â¡
(
ğœ€
ğœ…
+
ğœ…
)
âˆ’
log
â¡
(
ğœ…
â‹†
)
Î”
ğœ…
)
Î¼(Îº)=Î¼
min
	â€‹

+(Î¼
max
	â€‹

âˆ’Î¼
min
	â€‹

)sat
[0,1]
	â€‹

(
Î”
Îº
	â€‹

log(Îµ
Îº
	â€‹

+Îº)âˆ’log(Îº
â‹†
	â€‹

)
	â€‹

)

Arrastre tipo Stokes:

ğ¹
d
r
a
g
,
ğ‘–
(
ğ‘¡
)
=
âˆ’
ğ›¾
ğ‘–
(
ğ‘¡
)

ğ‘£
ğ‘–
(
ğ‘¡
)
F
drag,i
	â€‹

(t)=âˆ’Î³
i
	â€‹

(t)v
i
	â€‹

(t)

donde
ğ›¾
ğ‘–
(
ğ‘¡
)
Î³
i
	â€‹

(t) aumenta con estrÃ©s sistÃ©mico (Ley V/VI):

ğ›¾
ğ‘–
(
ğ‘¡
)
=
ğ›¾
0
(
1
+
ğœ‚
ğ›¾

Î˜
s
y
s
(
ğ‘¡
)
)
,
Î˜
s
y
s
(
ğ‘¡
)
=
s
a
t
[
0
,
1
]
â€‰â£
(
ğ‘†
s
y
s
(
ğ‘¡
)
âˆ’
ğ‘†
â‹†
Î”
ğ‘†
)
Î³
i
	â€‹

(t)=Î³
0
	â€‹

(1+Î·
Î³
	â€‹

Î˜
sys
	â€‹

(t)),Î˜
sys
	â€‹

(t)=sat
[0,1]
	â€‹

(
Î”S
S
sys
	â€‹

(t)âˆ’S
â‹†
	â€‹

	â€‹

)
II.3. Estabilidad y rendimiento como axiomas

IntegraciÃ³n estable (simpÃ©ctica o semi-implÃ­cita),
Î”
ğ‘¡
Î”t adaptativo y clamps (Art. XI).

Escalabilidad: fuerzas lejanas por Barnesâ€“Hut/NodeAgg, cercanas por Top-K.

PolÃ­tica de skipping (Ley IX): si MASK_SKIP_PHYS se activa, el activo no participa en fuerzas ni en migraciÃ³n (branchless).

ARTÃCULO III â€” Tensor de afinidad y acoplamiento esparso
ğ‘‡
ğ‘–
ğ‘—
T
ij
	â€‹

III.1. Escalabilidad:
ğ‘‡
ğ‘–
ğ‘—
T
ij
	â€‹

 escalar, definido solo en vecinos
ğ‘
ğ‘–
N
i
	â€‹


Se define un conjunto de vecinos acotado:

ğ‘
ğ‘–
(
ğ‘¡
)
âŠ‚
{
0
,
â€¦
,
ğ‘
âˆ’
1
}
,
âˆ£
ğ‘
ğ‘–
(
ğ‘¡
)
âˆ£
â‰¤
ğ¾
max
â¡
â‰¤
50
N
i
	â€‹

(t)âŠ‚{0,â€¦,Nâˆ’1},âˆ£N
i
	â€‹

(t)âˆ£â‰¤K
max
	â€‹

â‰¤50

y el acoplamiento es escalar (no matriz dÃ—d) por coste y SIMD.

III.2. Afinidad base por canales deterministas (robusta y normalizada)

Se define afinidad cruda como suma de canales:

ğ´
ğ‘–
ğ‘—
(
ğ‘¡
)
=
ğ‘¤
ğœ

ğ´
ğ‘–
ğ‘—
ğœ
+
ğ‘¤
ğœŒ

ğ´
ğ‘–
ğ‘—
ğœŒ
(
ğ‘¡
)
+
ğ‘¤
ğœ…

ğ´
ğ‘–
ğ‘—
ğœ…
(
ğ‘¡
)
âˆ’
ğ‘¤
âŠ–

ğ´
ğ‘–
ğ‘—
âŠ–
(
ğ‘¡
)
A
ij
	â€‹

(t)=w
Ï„
	â€‹

A
ij
Ï„
	â€‹

+w
Ï
	â€‹

A
ij
Ï
	â€‹

(t)+w
Îº
	â€‹

A
ij
Îº
	â€‹

(t)âˆ’w
âŠ–
	â€‹

A
ij
âŠ–
	â€‹

(t)

Ejemplos constitucionales (todos acotados):

Canal taxonÃ³mico (Ley VII, por grupos/categorÃ­as):
ğ´
ğ‘–
ğ‘—
ğœ
âˆˆ
{
0
,
1
}
A
ij
Ï„
	â€‹

âˆˆ{0,1}

CorrelaciÃ³n robusta rolling:
ğ´
ğ‘–
ğ‘—
ğœŒ
=
tanh
â¡
(
ğœŒ
ğ‘–
ğ‘—
r
o
b
)
âˆˆ
(
âˆ’
1
,
1
)
A
ij
Ï
	â€‹

=tanh(Ï
ij
rob
	â€‹

)âˆˆ(âˆ’1,1)

Similaridad de liquidez:
ğ´
ğ‘–
ğ‘—
ğœ…
=
exp
â¡
(
âˆ’
âˆ£
log
â¡
(
ğœ…
ğ‘–
+
ğœ€
)
âˆ’
log
â¡
(
ğœ…
ğ‘—
+
ğœ€
)
âˆ£
/
â„“
ğœ…
)
A
ij
Îº
	â€‹

=exp(âˆ’âˆ£log(Îº
i
	â€‹

+Îµ)âˆ’log(Îº
j
	â€‹

+Îµ)âˆ£/â„“
Îº
	â€‹

)

Anti-afinidad adversarial (Ley VI/IX flags):
ğ´
ğ‘–
ğ‘—
âŠ–
=
1
[
(
ğ‘š
ğ‘’
ğ‘¡
ğ‘
ğ‘–
âˆ¨
ğ‘š
ğ‘’
ğ‘¡
ğ‘
ğ‘—
)
&
ğ‘€
ğ´
ğ‘†
ğ¾
_
ğ‘…
ğ¼
ğ‘†
ğ¾
ğ‘Œ
â‰ 
0
]
A
ij
âŠ–
	â€‹

=1[(meta
i
	â€‹

âˆ¨meta
j
	â€‹

)&MASK_RISKY
î€ 
=0]

NormalizaciÃ³n constitucional (evita explosiÃ³n por outliers):

ğ´
~
ğ‘–
ğ‘—
(
ğ‘¡
)
=
ğ´
ğ‘–
ğ‘—
(
ğ‘¡
)
max
â¡
â€‰â£
(
ğœ€
ğ´
,

max
â¡
ğ‘˜
âˆˆ
ğ‘
ğ‘–
(
ğ‘¡
)
âˆ£
ğ´
ğ‘–
ğ‘˜
(
ğ‘¡
)
âˆ£
)
A
~
ij
	â€‹

(t)=
max(Îµ
A
	â€‹

, max
kâˆˆN
i
	â€‹

(t)
	â€‹

âˆ£A
ik
	â€‹

(t)âˆ£)
A
ij
	â€‹

(t)
	â€‹

III.3. Kernel espacial conformal y acoplamiento final
ğ‘‡
ğ‘–
ğ‘—
(
ğ‘¡
)
=
1
[
ğ‘—
âˆˆ
ğ‘
ğ‘–
(
ğ‘¡
)
]

ğ›¼
ğ‘‡

ğ´
~
ğ‘–
ğ‘—
(
ğ‘¡
)

exp
â¡
â€‰â£
(
âˆ’
ğ‘‘
ğ‘”
(
ğ‘–
,
ğ‘—
)
2
2
â„“
ğ‘‡
2
)

ğ‘“
ğ‘Ÿ
(
ğ‘Ÿ
ğ‘–
,
ğ‘Ÿ
ğ‘—
)
T
ij
	â€‹

(t)=1[jâˆˆN
i
	â€‹

(t)] Î±
T
	â€‹


A
~
ij
	â€‹

(t) exp(âˆ’
2â„“
T
2
	â€‹

d
g
	â€‹

(i,j)
2
	â€‹

) f
r
	â€‹

(r
i
	â€‹

,r
j
	â€‹

)

con modulaciÃ³n por riesgo acotada, por ejemplo:

ğ‘“
ğ‘Ÿ
(
ğ‘Ÿ
ğ‘–
,
ğ‘Ÿ
ğ‘—
)
=
1
+
ğœ†
ğ‘Ÿ

tanh
â¡
â€‰â£
(
ğ‘Ÿ
ğ‘–
+
ğ‘Ÿ
ğ‘—
2
ğ‘Ÿ
0
)
f
r
	â€‹

(r
i
	â€‹

,r
j
	â€‹

)=1+Î»
r
	â€‹

tanh(
2r
0
	â€‹

r
i
	â€‹

+r
j
	â€‹

	â€‹

)

y clamps duros:
ğ‘‡
ğ‘–
ğ‘—
â†
c
l
a
m
p
(
ğ‘‡
ğ‘–
ğ‘—
,
âˆ’
ğ‘‡
max
â¡
,
ğ‘‡
max
â¡
)
T
ij
	â€‹

â†clamp(T
ij
	â€‹

,âˆ’T
max
	â€‹

,T
max
	â€‹

).

III.4. Top-K + histÃ©resis del 15% + cooldown

Entrada de nuevo vecino solo si supera al peor por margen:

ğ‘‡
ğ‘–
,
ğ‘›
ğ‘’
ğ‘¤
>
(
1
+
ğœ‚
â„
ğ‘¦
ğ‘ 
)
min
â¡
ğ‘—
âˆˆ
ğ‘
ğ‘–
ğ‘‡
ğ‘–
ğ‘—
,
ğœ‚
â„
ğ‘¦
ğ‘ 
=
0.15
T
i,new
	â€‹

>(1+Î·
hys
	â€‹

)
jâˆˆN
i
	â€‹

min
	â€‹

T
ij
	â€‹

,Î·
hys
	â€‹

=0.15

y se prohÃ­be cambio de vecindad si cooldown_i>0 (Art. VII).

ARTÃCULO IV â€” FunciÃ³n de pertenencia/impacto
ğ¼
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
I(i,c,t) (cierre analÃ­tico)
IV.1. SeÃ±al base por familias
ğ‘ 
ğ¹
,
ğ‘ 
ğ‘€
,
ğ‘ 
ğ¸
s
F
	â€‹

,s
M
	â€‹

,s
E
	â€‹


Para una regiÃ³n/categorÃ­a objetivo
ğ‘
c (celda Morton, nodo taxonÃ³mico o â€œbucketâ€):

ğ‘ 
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
=
ğ‘ 
ğ¹
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
+
ğ‘ 
ğ‘€
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
+
ğ‘ 
ğ¸
(
ğ‘–
,
ğ‘
)
s(i,c,t)=s
F
	â€‹

(i,c,t)+s
M
	â€‹

(i,c,t)+s
E
	â€‹

(i,c)

Factorial / jerÃ¡rquica (afinidad a centroides jerÃ¡rquicos):

ğ‘ 
ğ¹
=
ğ‘¤
ğ¹

âŸ¨
ğ‘¢
ğ‘
,

ğ‘“
^
ğ‘–
(
ğ‘¡
)
âŸ©
s
F
	â€‹

=w
F
	â€‹

âŸ¨u
c
	â€‹

,
f
^
	â€‹

i
	â€‹

(t)âŸ©

donde
ğ‘¢
ğ‘
u
c
	â€‹

 es vector de factores del nodo (precomputado/SoA) y
ğ‘“
^
ğ‘–
f
^
	â€‹

i
	â€‹

 es proyecciÃ³n del activo (derivable de DNA/Ley VII).

Movilidad / proximidad conformal:

ğ‘ 
ğ‘€
=
ğ‘¤
ğ‘€

exp
â¡
â€‰â£
(
âˆ’
ğ‘‘
ğ‘”
(
ğ‘¥
ğ‘–
,
ğ‘¥
ğ‘
)
2
2
â„“
ğ‘€
2
)
â‹…
s
a
t
â€‰â£
(
âˆ¥
ğ‘£
ğ‘–
âˆ¥
ğ‘£
0
)
s
M
	â€‹

=w
M
	â€‹

exp(âˆ’
2â„“
M
2
	â€‹

d
g
	â€‹

(x
i
	â€‹

,x
c
	â€‹

)
2
	â€‹

)â‹…sat(
v
0
	â€‹

âˆ¥v
i
	â€‹

âˆ¥
	â€‹

)

EnergÃ­a excedente contra barrera:

ğ‘ 
ğ¸
=
ğ‘¤
ğ¸

s
a
t
[
0
,
1
]
â€‰â£
(
ğ¾
ğ¸
ğ‘–
âˆ’
ğ¸
b
a
r
(
ğ‘¥
ğ‘–
,
ğ‘
,
ğ‘¡
)
ğ¸
0
)
s
E
	â€‹

=w
E
	â€‹

sat
[0,1]
	â€‹

(
E
0
	â€‹

KE
i
	â€‹

âˆ’E
bar
	â€‹

(x
i
	â€‹

,c,t)
	â€‹

)

con
ğ¾
ğ¸
ğ‘–
=
1
2
âˆ¥
ğ‘£
ğ‘–
âˆ¥
2
KE
i
	â€‹

=
2
1
	â€‹

âˆ¥v
i
	â€‹

âˆ¥
2
 y
ğ¸
b
a
r
E
bar
	â€‹

 definido en Art. X/VII.

IV.2. Sigmoide con temperatura y normalizaciÃ³n sobre candidatos

Impacto (probabilidad operativa) con temperatura
ğ›½
ğ‘
Î²
c
	â€‹

:

ğ¼
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
=
ğœ
â€‰â£
(
ğ›½
ğ‘

(
ğ‘ 
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
âˆ’
ğœƒ
ğ‘
)
)
,
ğœ
(
ğ‘§
)
=
1
1
+
exp
â¡
(
âˆ’
ğ‘§
)
I(i,c,t)=Ïƒ(Î²
c
	â€‹

(s(i,c,t)âˆ’Î¸
c
	â€‹

)),Ïƒ(z)=
1+exp(âˆ’z)
1
	â€‹


NormalizaciÃ³n aproximada sobre un set acotado de candidatos
ğ¶
ğ‘–
(
ğ‘¡
)
C
i
	â€‹

(t) (no sobre todo el Ã¡rbol):

ğ¼
^
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
=
ğ¼
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
ğœ€
ğ¼
+
âˆ‘
ğ‘
â€²
âˆˆ
ğ¶
ğ‘–
(
ğ‘¡
)
ğ¼
(
ğ‘–
,
ğ‘
â€²
,
ğ‘¡
)
I
^
(i,c,t)=
Îµ
I
	â€‹

+âˆ‘
c
â€²
âˆˆC
i
	â€‹

(t)
	â€‹

I(i,c
â€²
,t)
I(i,c,t)
	â€‹


Dictamen:
ğ¶
ğ‘–
(
ğ‘¡
)
C
i
	â€‹

(t) es pequeÃ±o (p.ej. celdas vecinas + nodo padre + nodo destino sugerido por vacÃ­o), garantizando O(N).

IV.3. Cierre SciSpace: no existe â€œfunciÃ³n faltanteâ€

ğ¼
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
I(i,c,t) queda completamente definido por: NodeAgg (centroides y
Î£
Î£), estado local (x,v,r,s,\kappa) y barreras
ğœ™
ğ‘˜
Ï•
k
	â€‹

. No hay parÃ¡metro sin residencia SoA/Meta32 o tabla soberana.

ARTÃCULO V â€” JerarquÃ­a (Ã¡rbol) + dinÃ¡mica (grafo) y representantes NodeAgg
V.1. Estructura hÃ­brida: Ã¡rbol para aproximaciÃ³n, grafo para acoplamientos

Ãrbol: construido por Morton (quadtree/octree lineal) para Barnesâ€“Hut.

Grafo: inducido por
ğ‘
ğ‘–
(
ğ‘¡
)
N
i
	â€‹

(t) (Top-K) y
ğ‘‡
ğ‘–
ğ‘—
T
ij
	â€‹

 (Art. III).
El Ã¡rbol da fuerzas lejanas; el grafo da cohesiÃ³n local.

V.2. NodeAgg: masa de riesgo, centroide y volatilidad efectiva

Para cada nodo
ğ‘›
n del Ã¡rbol, con conjunto
ğ‘†
ğ‘›
S
n
	â€‹

 de activos:

ğ‘š
ğ‘›
=
âˆ‘
ğ‘–
âˆˆ
ğ‘†
ğ‘›
ğ‘¤
ğ‘–
,
ğ‘¥
ğ‘›
=
1
ğœ€
ğ‘š
+
ğ‘š
ğ‘›
âˆ‘
ğ‘–
âˆˆ
ğ‘†
ğ‘›
ğ‘¤
ğ‘–
ğ‘¥
ğ‘–
m
n
	â€‹

=
iâˆˆS
n
	â€‹

âˆ‘
	â€‹

w
i
	â€‹

,x
n
	â€‹

=
Îµ
m
	â€‹

+m
n
	â€‹

1
	â€‹

iâˆˆS
n
	â€‹

âˆ‘
	â€‹

w
i
	â€‹

x
i
	â€‹

ğ‘Ÿ
Ë‰
ğ‘›
=
1
ğœ€
ğ‘š
+
ğ‘š
ğ‘›
âˆ‘
ğ‘–
âˆˆ
ğ‘†
ğ‘›
ğ‘¤
ğ‘–
ğ‘Ÿ
ğ‘–
,
ğ‘ 
Ë‰
ğ‘›
=
1
ğœ€
ğ‘š
+
ğ‘š
ğ‘›
âˆ‘
ğ‘–
âˆˆ
ğ‘†
ğ‘›
ğ‘¤
ğ‘–
ğ‘ 
ğ‘–
r
Ë‰
n
	â€‹

=
Îµ
m
	â€‹

+m
n
	â€‹

1
	â€‹

iâˆˆS
n
	â€‹

âˆ‘
	â€‹

w
i
	â€‹

r
i
	â€‹

,
s
Ë‰
n
	â€‹

=
Îµ
m
	â€‹

+m
n
	â€‹

1
	â€‹

iâˆˆS
n
	â€‹

âˆ‘
	â€‹

w
i
	â€‹

s
i
	â€‹

Î£
ğ‘›
=
1
ğœ€
ğ‘š
+
ğ‘š
ğ‘›
âˆ‘
ğ‘–
âˆˆ
ğ‘†
ğ‘›
ğ‘¤
ğ‘–
âˆ¥
ğ‘¥
ğ‘–
âˆ’
ğ‘¥
ğ‘›
âˆ¥
2
Î£
n
	â€‹

=
Îµ
m
	â€‹

+m
n
	â€‹

1
	â€‹

iâˆˆS
n
	â€‹

âˆ‘
	â€‹

w
i
	â€‹

âˆ¥x
i
	â€‹

âˆ’x
n
	â€‹

âˆ¥
2
	â€‹


Pesos
ğ‘¤
ğ‘–
w
i
	â€‹

 branchless (castigos Ley VI/IX):

ğ‘¤
ğ‘–
=
s
a
t
[
0
,
1
]
â€‰â£
(
1
âˆ’
ğœŒ
ğ¹

1
[
ğ‘š
ğ‘’
ğ‘¡
ğ‘
ğ‘–
&
ğ‘€
ğ´
ğ‘†
ğ¾
_
ğ‘…
ğ¼
ğ‘†
ğ¾
ğ‘Œ
]
)
w
i
	â€‹

=sat
[0,1]
	â€‹

(1âˆ’Ï
F
	â€‹

1[meta
i
	â€‹

&MASK_RISKY])
V.3. Criterio Barnesâ€“Hut (aceptaciÃ³n) y traversal acotado

Sea
ğ‘ 
ğ‘›
s
n
	â€‹

 el tamaÃ±o del nodo (lado de celda) y
ğ‘‘
=
âˆ¥
ğ‘¥
ğ‘–
âˆ’
ğ‘¥
ğ‘›
âˆ¥
d=âˆ¥x
i
	â€‹

âˆ’x
n
	â€‹

âˆ¥. Se acepta aproximaciÃ³n si:

ğ‘ 
ğ‘›
ğ‘‘
+
ğœ€
ğ‘‘
<
ğœƒ
B
H
d+Îµ
d
	â€‹

s
n
	â€‹

	â€‹

<Î¸
BH
	â€‹


Traversal no recursivo con pila fija (mÃ¡ximo constitucional) para evitar stutter.

ARTÃCULO VI â€” Campo de fuerzas total: conservativo + acoplamiento + fluidos clÃ¡sicos
VI.1. DescomposiciÃ³n total
ğ¹
ğ‘–
(
ğ‘¡
)
=
ğ¹
c
o
n
s
,
ğ‘–
(
ğ‘¡
)
+
ğ¹
a
f
f
,
ğ‘–
(
ğ‘¡
)
+
ğ¹
v
a
c
,
ğ‘–
(
ğ‘¡
)
+
ğ¹
d
r
a
g
,
ğ‘–
(
ğ‘¡
)
+
ğ¹
n
o
i
s
e
,
ğ‘–
(
ğ‘¡
)
F
i
	â€‹

(t)=F
cons,i
	â€‹

(t)+F
aff,i
	â€‹

(t)+F
vac,i
	â€‹

(t)+F
drag,i
	â€‹

(t)+F
noise,i
	â€‹

(t)
VI.2. Fuerza conservativa: potencial jerÃ¡rquico + repulsiÃ³n suave

Potencial jerÃ¡rquico (muelle a centroide de categorÃ­a/grupo):

ğ‘‰
h
i
e
r
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
=
âˆ‘
ğ‘˜
âˆˆ
ğ»
(
ğ‘–
)
ğ›¼
ğ‘˜
2

âˆ¥
ğ‘¥
ğ‘–
âˆ’
ğ‘¥
ğ‘˜
(
ğ‘¡
)
âˆ¥
2
V
hier
	â€‹

(x
i
	â€‹

,t)=
kâˆˆH(i)
âˆ‘
	â€‹

2
Î±
k
	â€‹

	â€‹

âˆ¥x
i
	â€‹

âˆ’x
k
	â€‹

(t)âˆ¥
2

RepulsiÃ³n suave anti-colisiÃ³n (evita colapso visual):

ğ‘‰
r
e
p
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
=
âˆ‘
ğ‘—
âˆˆ
ğ‘
ğ‘–
ğ›¼
r
e
p

exp
â¡
â€‰â£
(
âˆ’
ğ‘‘
ğ‘”
(
ğ‘–
,
ğ‘—
)
2
2
â„“
r
e
p
2
)
V
rep
	â€‹

(x
i
	â€‹

,t)=
jâˆˆN
i
	â€‹

âˆ‘
	â€‹

Î±
rep
	â€‹

exp(âˆ’
2â„“
rep
2
	â€‹

d
g
	â€‹

(i,j)
2
	â€‹

)
ğ¹
c
o
n
s
,
ğ‘–
=
âˆ’
âˆ‡
(
ğ‘‰
h
i
e
r
+
ğ‘‰
r
e
p
)
F
cons,i
	â€‹

=âˆ’âˆ‡(V
hier
	â€‹

+V
rep
	â€‹

)
VI.3. Fuerza de acoplamiento (tensor esparso)
ğ¹
a
f
f
,
ğ‘–
(
ğ‘¡
)
=
âˆ‘
ğ‘—
âˆˆ
ğ‘
ğ‘–
(
ğ‘¡
)
ğ‘‡
ğ‘–
ğ‘—
(
ğ‘¡
)

(
ğ‘¥
ğ‘—
(
ğ‘¡
)
âˆ’
ğ‘¥
ğ‘–
(
ğ‘¡
)
)
F
aff,i
	â€‹

(t)=
jâˆˆN
i
	â€‹

(t)
âˆ‘
	â€‹

T
ij
	â€‹

(t)(x
j
	â€‹

(t)âˆ’x
i
	â€‹

(t))

Clamps:
âˆ¥
ğ¹
a
f
f
,
ğ‘–
âˆ¥
â‰¤
ğ¹
max
â¡
âˆ¥F
aff,i
	â€‹

âˆ¥â‰¤F
max
	â€‹

.

VI.4. VacÃ­os como presiÃ³n clÃ¡sica (llenado dirigido)

Definimos ocupaciÃ³n por regiÃ³n
ğ‘
c:
ğ‘›
ğ‘
(
ğ‘¡
)
n
c
	â€‹

(t) (NodeAgg/celdas). Definimos dÃ©ficit:

ğ›¿
ğ‘
(
ğ‘¡
)
=
s
a
t
[
0
,
1
]
â€‰â£
(
ğ‘›
ğ‘
â‹†
âˆ’
ğ‘›
ğ‘
(
ğ‘¡
)
ğ‘›
ğ‘
â‹†
+
ğœ€
)
Î´
c
	â€‹

(t)=sat
[0,1]
	â€‹

(
n
c
â‹†
	â€‹

+Îµ
n
c
â‹†
	â€‹

âˆ’n
c
	â€‹

(t)
	â€‹

)

Potencial de vacÃ­o (atracciÃ³n a centroides de regiones deficitarias):

ğ‘‰
v
a
c
(
ğ‘¥
,
ğ‘¡
)
=
âˆ‘
ğ‘
ğ›¼
v
a
c

ğœ“
(
ğ›¿
ğ‘
(
ğ‘¡
)
)

exp
â¡
â€‰â£
(
âˆ’
âˆ¥
ğ‘¥
âˆ’
ğ‘¥
ğ‘
(
ğ‘¡
)
âˆ¥
2
2
â„“
v
a
c
2
)
V
vac
	â€‹

(x,t)=
c
âˆ‘
	â€‹

Î±
vac
	â€‹

 Ïˆ(Î´
c
	â€‹

(t)) exp(âˆ’
2â„“
vac
2
	â€‹

âˆ¥xâˆ’x
c
	â€‹

(t)âˆ¥
2
	â€‹

)
ğ¹
v
a
c
,
ğ‘–
(
ğ‘¡
)
=
âˆ’
âˆ‡
ğ‘‰
v
a
c
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
F
vac,i
	â€‹

(t)=âˆ’âˆ‡V
vac
	â€‹

(x
i
	â€‹

,t)

con
ğœ“
(
ğ‘¢
)
=
ğ‘¢
ğœˆ
Ïˆ(u)=u
Î½
 (
ğœˆ
âˆˆ
[
1
,
2
]
Î½âˆˆ[1,2], acotado). Dictamen: el vacÃ­o no â€œteletransportaâ€; aplica gradiente.

VI.5. Ruido tÃ©rmico controlado (determinista)
ğ¹
n
o
i
s
e
,
ğ‘–
(
ğ‘¡
)
=
ğœ
ğ‘‡
(
ğ‘¡
)

ğœ‰
ğ‘–
(
ğ‘¡
)
,
ğœ‰
ğ‘–
âˆ¼
ğ‘
(
0
,
ğ¼
ğ‘‘
)
F
noise,i
	â€‹

(t)=Ïƒ
T
	â€‹

(t)Î¾
i
	â€‹

(t),Î¾
i
	â€‹

âˆ¼N(0,I
d
	â€‹

)

ğœ‰
ğ‘–
Î¾
i
	â€‹

 se genera por PRNG determinista semillado con hid32 y frame
ğ‘¡
t.

ARTÃCULO VII â€” Barreras de Cauchy adaptativas y contracciÃ³n en crisis
VII.1. Barrera suave tipo Cauchy (sin discontinuidades)

Para cada frontera jerÃ¡rquica
ğ‘˜
k (p.ej. categorÃ­a, subgrupo):

ğœ™
ğ‘˜
(
ğ‘¥
,
ğ‘¡
)
=
ğ›¼
ğ‘˜

log
â¡
â€‰â£
(
1
+
(
ğ‘‘
ğ‘˜
(
ğ‘¥
)
ğ‘
ğ‘˜
(
ğ‘¡
)
)
2
)
Ï•
k
	â€‹

(x,t)=Î±
k
	â€‹

log(1+(
b
k
	â€‹

(t)
d
k
	â€‹

(x)
	â€‹

)
2
)

donde
ğ‘‘
ğ‘˜
(
ğ‘¥
)
d
k
	â€‹

(x) es distancia firmada a la frontera (derivable de centroide y radio de nodo, o caja AABB).
Fuerza barrera:

ğ¹
b
a
r
,
ğ‘–
(
ğ‘¡
)
=
âˆ’
âˆ‡
ğœ™
ğ‘˜
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
F
bar,i
	â€‹

(t)=âˆ’âˆ‡Ï•
k
	â€‹

(x
i
	â€‹

,t)
VII.2. Ancho dinÃ¡mico
ğ‘
ğ‘˜
(
ğ‘¡
)
b
k
	â€‹

(t) dependiente de estrÃ©s sistÃ©mico
ğ‘
ğ‘˜
(
ğ‘¡
)
=
c
l
i
p
(
ğ‘
0
(
1
+
ğœ‚
Î£

Î˜
s
y
s
(
ğ‘¡
)
)
âˆ’
1
,

ğ‘
min
â¡
,

ğ‘
max
â¡
)
b
k
	â€‹

(t)=clip(b
0
	â€‹

(1+Î·
Î£
	â€‹

Î˜
sys
	â€‹

(t))
âˆ’1
, b
min
	â€‹

, b
max
	â€‹

)

ContracciÃ³n en crisis: si
Î˜
s
y
s
â†‘
Î˜
sys
	â€‹

â†‘,
ğ‘
ğ‘˜
â†“
b
k
	â€‹

â†“ â‡’ barrera mÃ¡s â€œrÃ­gidaâ€, crea sumideros y canales.

VII.3. Cooldown e histÃ©resis anti-flip

Tras una migraciÃ³n o ruptura:

ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
(
ğ‘¡
)
â†
c
l
a
m
p
ğ‘¢
8
(
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
(
ğ‘¡
)
+
Î”
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
,
0
,
255
)
cool
i
	â€‹

(t)â†clamp
u8
	â€‹

(cool
i
	â€‹

(t)+Î”
cool
	â€‹

,0,255)

y decae:
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
(
ğ‘¡
+
1
)
=
max
â¡
(
0
,
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
(
ğ‘¡
)
âˆ’
1
)
cool
i
	â€‹

(t+1)=max(0,cool
i
	â€‹

(t)âˆ’1). Mientras
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
>
0
cool
i
	â€‹

>0, se bloquea: (a) re-migraciÃ³n, (b) reemplazo agresivo de Top-K, (c) cambios bruscos de
ğ‘
ğ‘˜
b
k
	â€‹

 locales.

ARTÃCULO VIII â€” EcuaciÃ³n maestra (Langevin clÃ¡sico en manifold conformal)
VIII.1. DinÃ¡mica (float32-safe, movilidad + disipaciÃ³n + ruido)
ğ‘¥
Ë™
ğ‘–
=
ğ‘£
ğ‘–
x
Ë™
i
	â€‹

=v
i
	â€‹

ğ‘£
Ë™
ğ‘–
=
ğœ‡
(
ğœ…
ğ‘–
)
(
ğ¹
c
o
n
s
,
ğ‘–
+
ğ¹
a
f
f
,
ğ‘–
+
ğ¹
v
a
c
,
ğ‘–
âˆ’
âˆ‡
ğœ™
(
ğ‘¥
ğ‘–
)
)
âˆ’
ğ›¾
ğ‘–
ğ‘£
ğ‘–
+
2

ğ‘‡
ğ‘–

ğ›¾
ğ‘–

ğœ‰
ğ‘–
v
Ë™
i
	â€‹

=Î¼(Îº
i
	â€‹

)(F
cons,i
	â€‹

+F
aff,i
	â€‹

+F
vac,i
	â€‹

âˆ’âˆ‡Ï•(x
i
	â€‹

))âˆ’Î³
i
	â€‹

v
i
	â€‹

+
2T
i
	â€‹

Î³
i
	â€‹

	â€‹

Î¾
i
	â€‹


donde
ğ‘‡
ğ‘–
T
i
	â€‹

 es temperatura efectiva (Ley V: Tsallis/annealing), acotada
ğ‘‡
ğ‘–
âˆˆ
[
ğ‘‡
min
â¡
,
ğ‘‡
max
â¡
]
T
i
	â€‹

âˆˆ[T
min
	â€‹

,T
max
	â€‹

].

VIII.2. Compatibilidad WebGL2/WASM

La integraciÃ³n ocurre en CPU/WASM SIMD (o backend nativo) y se serializa a Vertex28. GPU solo deriva observables desde Meta32/pack32/hid32.

ARTÃCULO IX â€” Tsallis, presiÃ³n sistÃ©mica y enfriamiento simulado (sin reset)
IX.1. EstrÃ©s sistÃ©mico y rÃ©gimen

Sea
ğ‘†
s
y
s
(
ğ‘¡
)
S
sys
	â€‹

(t) un escalar de presiÃ³n (Ley V/VI/IX), p.ej. combinaciÃ³n de
ğ‘
(
ğ‘¡
)
q(t), tasa de disputas y volatilidad agregada.
Si
ğ‘†
s
y
s
â‰¥
ğ‘†
c
r
i
t
S
sys
	â€‹

â‰¥S
crit
	â€‹

: se activa â€œcontracciÃ³nâ€:
ğ‘
ğ‘˜
â†“
b
k
	â€‹

â†“,
ğ›¾
â†‘
Î³â†‘,
ğ‘‡
â†“
Tâ†“.

IX.2. EntropÃ­a de Tsallis como modulador
ğ‘†
ğ‘
(
ğ‘
)
=
1
âˆ’
âˆ‘
ğ‘˜
ğ‘
ğ‘˜
ğ‘
ğ‘
âˆ’
1
S
q
	â€‹

(p)=
qâˆ’1
1âˆ’âˆ‘
k
	â€‹

p
k
q
	â€‹

	â€‹


Se define un schedule:

ğ‘‡
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ›¼
ğ‘‡

ğ‘‡
(
ğ‘¡
)
,
ğ›¾
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ›¾
(
ğ‘¡
)
(
1
+
ğœ‚
ğ›¾

Î˜
s
y
s
(
ğ‘¡
)
)
T(t+Î”t)=Î±
T
	â€‹

T(t),Î³(t+Î”t)=Î³(t)(1+Î·
Î³
	â€‹

Î˜
sys
	â€‹

(t))

con histÃ©resis: el retorno requiere
ğ‘†
s
y
s
<
ğ‘†
c
r
i
t
(
1
âˆ’
ğœ‰
)
S
sys
	â€‹

<S
crit
	â€‹

(1âˆ’Î¾).

ARTÃCULO X â€” Ruptura, transmigraciÃ³n, cascada limitada y llenado de vacÃ­os
X.1. EnergÃ­a cinÃ©tica y energÃ­a de barrera
ğ¾
ğ¸
ğ‘–
=
1
2
âˆ¥
ğ‘£
ğ‘–
âˆ¥
2
KE
i
	â€‹

=
2
1
	â€‹

âˆ¥v
i
	â€‹

âˆ¥
2

EnergÃ­a de barrera hacia objetivo
ğ‘
c:

ğ¸
b
a
r
(
ğ‘¥
ğ‘–
,
ğ‘
,
ğ‘¡
)
=
ğœ™
ğ‘
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
+
ğœ‚
â„
ğ‘¦
ğ‘ 

ğœ™
ğ‘
(
ğ‘¥
ğ‘–
,
ğ‘¡
)
E
bar
	â€‹

(x
i
	â€‹

,c,t)=Ï•
c
	â€‹

(x
i
	â€‹

,t)+Î·
hys
	â€‹

Ï•
c
	â€‹

(x
i
	â€‹

,t)

(donde
ğœ‚
â„
ğ‘¦
ğ‘ 
Î·
hys
	â€‹

 introduce histÃ©resis constitucional).

X.2. Criterio de Ruptura/TransmigraciÃ³n (multi-factor, determinista)

Definimos persistencia
ğ‘¡
p
e
r
s
t
pers
	â€‹

 (contador u8) y cooldown
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
cool
i
	â€‹

.

ğ‘…
ğ‘ˆ
ğ‘ƒ
ğ‘‡
ğ‘ˆ
ğ‘…
ğ¸
ğ‘–
(
ğ‘¡
)
=
1
[
ğ¼
^
(
ğ‘–
,
ğ‘
â‹†
,
ğ‘¡
)
>
ğœƒ
i
m
p
a
c
t
]

âˆ§

1
[
ğ¾
ğ¸
ğ‘–
>
ğ¸
b
a
r
(
ğ‘¥
ğ‘–
,
ğ‘
â‹†
,
ğ‘¡
)
]

âˆ§

1
[
ğ‘¡
p
e
r
s
>
ğœ
min
â¡
]

âˆ§

1
[
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
=
0
]
RUPTURE
i
	â€‹

(t)=1[
I
^
(i,c
â‹†
,t)>Î¸
impact
	â€‹

] âˆ§ 1[KE
i
	â€‹

>E
bar
	â€‹

(x
i
	â€‹

,c
â‹†
,t)] âˆ§ 1[t
pers
	â€‹

>Ï„
min
	â€‹

] âˆ§ 1[cool
i
	â€‹

=0]

donde
ğ‘
â‹†
=
arg
â¡
max
â¡
ğ‘
âˆˆ
ğ¶
ğ‘–
ğ¼
^
(
ğ‘–
,
ğ‘
,
ğ‘¡
)
c
â‹†
=argmax
câˆˆC
i
	â€‹

	â€‹

I
^
(i,c,t).

X.3. Cascada limitada (anti-explosiÃ³n)

Una transmigraciÃ³n crea un â€œvacÃ­oâ€ local. Se permite una cascada de relleno con profundidad mÃ¡xima
ğ¶
max
â¡
C
max
	â€‹

 (p.ej. 5) por frame:

si se supera, los eventos se difieren (cola SPSC), nunca bloquean el frame.

X.4. Compatibilidad con Ley II y Ley IX

Nacimiento (Ley II) es un caso lÃ­mite de inyecciÃ³n con desplazamiento.

Ley IX gobierna existencia; un activo en AGONY/EJECT_PENDING no migra (gating por mÃ¡scara).

ARTÃCULO XI â€” IntegraciÃ³n temporal:
Î”
ğ‘¡
Î”t adaptativo, clamps y normalizaciÃ³n (anti-NaN)
XI.1. Integrador (Velocity Verlet semi-implÃ­cito)
ğ‘£
ğ‘–
ğ‘¡
+
1
2
=
ğ‘£
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
2

ğ‘
ğ‘–
ğ‘¡
,
ğ‘¥
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
=
ğ‘¥
ğ‘–
ğ‘¡
+
Î”
ğ‘¡

ğ‘£
ğ‘–
ğ‘¡
+
1
2
v
i
t+
2
1
	â€‹

	â€‹

=v
i
t
	â€‹

+
2
Î”t
	â€‹

a
i
t
	â€‹

,x
i
t+Î”t
	â€‹

=x
i
t
	â€‹

+Î”tv
i
t+
2
1
	â€‹

	â€‹

ğ‘
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
=
ğ‘
(
ğ‘¥
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
,
ğ‘£
ğ‘–
ğ‘¡
+
1
2
)
,
ğ‘£
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
=
ğ‘£
ğ‘–
ğ‘¡
+
1
2
+
Î”
ğ‘¡
2

ğ‘
ğ‘–
ğ‘¡
+
Î”
ğ‘¡
a
i
t+Î”t
	â€‹

=a(x
i
t+Î”t
	â€‹

,v
i
t+
2
1
	â€‹

	â€‹

),v
i
t+Î”t
	â€‹

=v
i
t+
2
1
	â€‹

	â€‹

+
2
Î”t
	â€‹

a
i
t+Î”t
	â€‹


donde
ğ‘
ğ‘–
=
ğ‘£
Ë™
ğ‘–
a
i
	â€‹

=
v
Ë™
i
	â€‹

 proviene de Art. VIII.

XI.2. Timestep adaptativo (CFL + fuerza) y clamps duros
Î”
ğ‘¡
=
min
â¡
(
Î”
ğ‘¡
max
â¡
,

Î”
ğ‘¡
C
F
L
,

Î”
ğ‘¡
f
o
r
c
e
)
Î”t=min(Î”t
max
	â€‹

, Î”t
CFL
	â€‹

, Î”t
force
	â€‹

)
Î”
ğ‘¡
C
F
L
=
ğœ‚
c
f
l
â„“
c
e
l
l
ğœ€
ğ‘£
+
âˆ¥
ğ‘£
ğ‘–
âˆ¥
max
â¡
,
Î”
ğ‘¡
f
o
r
c
e
=
ğœ‚
ğ‘“
â„“
c
e
l
l
ğœ€
ğ‘
+
âˆ¥
ğ‘
ğ‘–
âˆ¥
max
â¡
Î”t
CFL
	â€‹

=Î·
cfl
	â€‹

Îµ
v
	â€‹

+âˆ¥v
i
	â€‹

âˆ¥
max
	â€‹

â„“
cell
	â€‹

	â€‹

,Î”t
force
	â€‹

=Î·
f
	â€‹

Îµ
a
	â€‹

+âˆ¥a
i
	â€‹

âˆ¥
max
	â€‹

â„“
cell
	â€‹

	â€‹

	â€‹


Clamps constitucionales:

âˆ¥
ğ‘£
ğ‘–
âˆ¥
â†
min
â¡
(
âˆ¥
ğ‘£
ğ‘–
âˆ¥
,
ğ‘£
max
â¡
)
,
âˆ¥
ğ‘
ğ‘–
âˆ¥
â†
min
â¡
(
âˆ¥
ğ‘
ğ‘–
âˆ¥
,
ğ‘
max
â¡
)
âˆ¥v
i
	â€‹

âˆ¥â†min(âˆ¥v
i
	â€‹

âˆ¥,v
max
	â€‹

),âˆ¥a
i
	â€‹

âˆ¥â†min(âˆ¥a
i
	â€‹

âˆ¥,a
max
	â€‹

)

y si aparece NaN/Inf: zero-kill local (set
ğ‘£
=
0
v=0, clamp pos, flag de cuarentena vÃ­a Ley VI).

XI.3. NormalizaciÃ³n de constantes
ğ¶
C (invarianza de escala y densidad)

Para evitar que el rÃ©gimen cambie al variar N, zoom o densidad, se normaliza toda magnitud global por escalas soberanas:

Escala de longitud:
â„“
c
e
l
l
â„“
cell
	â€‹

 (celda Morton)

Escala de fuerza:
ğ¹
0
=
â„“
c
e
l
l
/
Î”
ğ‘¡
max
â¡
2
F
0
	â€‹

=â„“
cell
	â€‹

/Î”t
max
2
	â€‹


Escala de energÃ­a:
ğ¸
0
=
â„“
c
e
l
l
2
/
Î”
ğ‘¡
max
â¡
2
E
0
	â€‹

=â„“
cell
2
	â€‹

/Î”t
max
2
	â€‹


Cualquier coeficiente
ğ›¼
Î± se expresa como
ğ›¼
=
ğ›¼
^

ğ¹
0
Î±=
Î±
^
F
0
	â€‹

 o
ğ›¼
^

ğ¸
0
Î±
^
E
0
	â€‹

, con
ğ›¼
^
âˆˆ
[
0
,
1
]
Î±
^
âˆˆ[0,1] cuantizable. Dictamen: los parÃ¡metros viven en un simplex estable, no en unidades arbitrarias.

ARTÃCULO XII â€” ImplementaciÃ³n de bajo nivel (C++/WASM): lock-free, branchless, SIMD-friendly
XII.1. SoA mÃ­nimo (hot arrays, alineaciÃ³n 64B)

Supuestos SoA size N:

float posx[], posy[], posz[]

float velx[], vely[], velz[]

float risk[], shock[], kappa[]

uint32 meta[]

uint32 hid[]

uint16 morton12[] (celda coarse)

uint8 cool[], uint8 pers[] (contadores)

NeighborIdx neigh[Kmax][N] o CSR compactado (offline/slow path)

NodeAgg (por nodo/celda):

float cx[], cy[], cz[], mass[], rbar[], sbar[], sigma[]

uint32 count[]

MÃ¡scara de skipping fÃ­sico (ratificada por Ley IX):

static constexpr uint32_t MASK_SKIP_PHYS =
  (F_VOID_READY | F_INVISIBLE | F_AGONY | F_EJECT_PENDING);

XII.2. ConstrucciÃ³n NodeAgg por celda (barato) + Ã¡rbol (opcional)

Fase A (por celda coarse, O(N)):

for(c=0;c<NCELL;++c){ mass[c]=0; cx[c]=cy[c]=cz[c]=0; count[c]=0; }

for(i=0;i<N;++i){
  uint32_t m = meta[i];
  uint32_t live = (uint32_t)-((m & MASK_SKIP_PHYS)==0u) & 1u;
  uint32_t c = morton12[i];
  float w = (float)live * (1.0f - rhoF * (float)((m & MASK_RISKY)!=0u));

  mass[c] += w;
  cx[c]   += w*posx[i];
  cy[c]   += w*posy[i];
  cz[c]   += w*posz[i];
  count[c]+= live;
}
for(c=0;c<NCELL;++c){
  float inv = 1.0f/(epsM + mass[c]);
  cx[c]*=inv; cy[c]*=inv; cz[c]*=inv;
}


Fase B (sigma por celda, O(N)):

for(c=0;c<NCELL;++c) sigma[c]=0;
for(i=0;i<N;++i){
  uint32_t m = meta[i];
  uint32_t live = ((m & MASK_SKIP_PHYS)==0u);
  uint32_t c = morton12[i];
  float dx = posx[i]-cx[c], dy = posy[i]-cy[c], dz = posz[i]-cz[c];
  sigma[c] += (float)live * (dx*dx+dy*dy+dz*dz);
}
for(c=0;c<NCELL;++c){
  sigma[c] = sqrtf(sigma[c] / (epsM + (float)count[c]));
}


El Ã¡rbol Barnesâ€“Hut completo se permite como mejora (O(N log N)) usando Morton codes de mÃ¡s bits + radix sort + nodes lineales; el principio fÃ­sico no cambia.

XII.3. Factor conformal
Î©
Î© por lookup en celda (O(1))
static inline float OmegaCell(uint32_t c){
  float u = (sigma[c] - SigmaStar) * invDeltaSigma;
  float S = 0.5f + 0.5f * tanhf(u);
  S = fminf(1.f, fmaxf(0.f, S));
  return OmegaMin + (OmegaMax - OmegaMin) * S;
}

XII.4. Fuerzas: lejanas por NodeAgg (celdas vecinas + vacÃ­os), cercanas por Top-K
static inline float sat01(float x){ return fminf(1.f,fmaxf(0.f,x)); }

static inline void ForceFromCell(uint32_t c, float xi,float yi,float zi,
                                 float Oi, float& fx,float& fy,float& fz){
  // atracciÃ³n jerÃ¡rquica + vacÃ­o: usa centroide de celda
  float dx = cx[c]-xi, dy = cy[c]-yi, dz = cz[c]-zi;
  float dist2 = dx*dx+dy*dy+dz*dz + epsD;
  float dist = sqrtf(dist2);

  float Oj = OmegaCell(c);
  float Og = 0.5f*(Oi+Oj);
  float dg = Og * fmaxf(dist, 1e-9f); // epsilon guard (FP32)

  // kernel gaussiano
  float k = expf(-0.5f * (dg*dg) * invL2_vac);
  // dÃ©ficit (vacÃ­o) normalizado
  float delta = sat01((nStar[c] - (float)count[c]) * invNStar[c]);
  float psi   = powf(delta, nuVac);

  float a = alphaVac * psi * k / (dist + epsD);
  fx += a*dx; fy += a*dy; fz += a*dz;
}

void K_FORCE_EVAL(float dt){
  float gamma_sys = gamma0 * (1.f + etaG * ThetaSys());
  float Tsys      = clampf(T0 * expf(-lambdaT*ThetaSys()), Tmin, Tmax);

  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta[i];
    if(m & MASK_SKIP_PHYS) { continue; }

    uint32_t c = morton12[i];
    float xi=posx[i], yi=posy[i], zi=posz[i];
    float vxi=velx[i], vyi=vely[i], vzi=velz[i];

    float Oi = OmegaCell(c);

    // Fuerza total acumulada
    float fx=0, fy=0, fz=0;

    // VacÃ­o / presiÃ³n: escanea vecindad de celdas (acotado, p.ej. 3x3x3 => 27)
    for(uint32_t cc : NeighborCells27(c)){
      ForceFromCell(cc, xi,yi,zi, Oi, fx,fy,fz);
    }

    // Acoplamiento local Top-K (si existe CSR); aquÃ­ esquemÃ¡tico:
    uint32_t base = neighBase[i];
    uint32_t cnt  = neighCount[i]; // <=Kmax
    for(uint32_t k=0;k<cnt;++k){
      uint32_t j = neighIdx[base+k];
      float dx = posx[j]-xi, dy = posy[j]-yi, dz = posz[j]-zi;
      float dist2 = dx*dx+dy*dy+dz*dz + epsD;
      float dist = sqrtf(dist2);
      float Oj = OmegaCell(morton12[j]);
      float dg = 0.5f*(Oi+Oj)*dist;

      float A = AffinityNorm(i,j); // Art III, float32, acotado
      float Tij = alphaT * A * expf(-0.5f*(dg*dg)*invL2_T) * Frisk(risk[i],risk[j]);
      Tij = clampf(Tij, -Tmax, Tmax);

      fx += Tij*dx; fy += Tij*dy; fz += Tij*dz;
    }

    // Barreras Cauchy (fronteras jerÃ¡rquicas): derivable por nodo objetivo
    AddCauchyBarrierForces(i, xi,yi,zi, fx,fy,fz);

    // Movilidad y arrastre
    float mu = Mobility(kappa[i]);
    fx = mu*fx - gamma_sys*vxi;
    fy = mu*fy - gamma_sys*vyi;
    fz = mu*fz - gamma_sys*vzi;

    // Ruido tÃ©rmico determinista
    float nx,ny,nz; Gaussian3(hid[i], frameIndex, nx,ny,nz);
    fx += sqrtf(2.f*Tsys*gamma_sys) * nx;
    fy += sqrtf(2.f*Tsys*gamma_sys) * ny;
    fz += sqrtf(2.f*Tsys*gamma_sys) * nz;

    // Clamps de aceleraciÃ³n
    ClampAccel(fx,fy,fz, aMax);

    ax[i]=fx; ay[i]=fy; az[i]=fz; // SoA aceleraciÃ³n
  }
}

XII.5. IntegraciÃ³n Velocity Verlet + eventos de ruptura/migraciÃ³n (branchless)
void K_INTEGRATE(float dt){
  float half = 0.5f*dt;

  // pre: ax,ay,az calculados
  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta[i];
    if(m & MASK_SKIP_PHYS) continue;

    // v(t+1/2)
    velx[i] += half*ax[i];
    vely[i] += half*ay[i];
    velz[i] += half*az[i];

    // clamp v
    ClampVel(velx[i],vely[i],velz[i], vMax);

    // x(t+1)
    posx[i] += dt*velx[i];
    posy[i] += dt*vely[i];
    posz[i] += dt*velz[i];

    // clamp dominio (viewport / caja mundo)
    ClampPos(posx[i],posy[i],posz[i]);

    // persistencia (para ruptura): si â€œapuntaâ€ a mismo c* acumula, si no decae
    UpdatePersistence(i);

    // cooldown decae
    cool[i] = (cool[i]>0)? (cool[i]-1) : 0;
  }

  // recomputa fuerzas en nueva x
  K_FORCE_EVAL(dt);

  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta[i];
    if(m & MASK_SKIP_PHYS) continue;

    // v(t+1)
    velx[i] += half*ax[i];
    vely[i] += half*ay[i];
    velz[i] += half*az[i];
    ClampVel(velx[i],vely[i],velz[i], vMax);

    // Ruptura / transmigraciÃ³n (evento fÃ­sico)
    uint32_t can = (cool[i]==0);
    uint32_t rup = can & EvaluateRupture(i); // Art X (impacto+energÃ­a+persistencia)
    if(rup){
      ApplyTransmigration(i);       // mueve objetivo, setea cooldown, ajusta vecindad
      cool[i] = clamp_u8(cool[i] + CoolKick, 0, 255);
      MarkStatusMigrating(i);       // Meta32.STATUS4 subcÃ³digo ALFA_MIGRATING
    }
  }
}

ARTÃCULO XIII â€” Modelo de coste y presupuesto de rendimiento (dinÃ¡mica sistÃ©mica)
XIII.1. Kernels constitucionales

K_NODEAGG: conteos + centroides + sigma por celda/Ã¡rbol.

K_FORCE_EVAL: fuerzas (vacÃ­o+acoplamiento+barreras+drag+ruido).

K_INTEGRATION: integraciÃ³n + eventos (ruptura/migraciÃ³n) + contadores.

XIII.2. Presupuesto fijo (objetivo CPU/WASM, sin stutter)

ğ¾
ğ‘
ğ‘‚
ğ·
ğ¸
ğ´
ğº
ğº
â‰¤
0.60

m
s
K
NODEAGG
	â€‹

â‰¤0.60ms (NCELL bajo; Ã¡rbol completo solo si cabe)

ğ¾
ğ¹
ğ‘‚
ğ‘…
ğ¶
ğ¸
_
ğ¸
ğ‘‰
ğ´
ğ¿
â‰¤
3.80

m
s
K
FORCE_EVAL
	â€‹

â‰¤3.80ms (vacÃ­o 27 celdas + Top-K â‰¤ 50)

ğ¾
ğ¼
ğ‘
ğ‘‡
ğ¸
ğº
ğ‘…
ğ´
ğ‘‡
ğ¼
ğ‘‚
ğ‘
â‰¤
1.40

m
s
K
INTEGRATION
	â€‹

â‰¤1.40ms
Total dinÃ¡mica â‰² 5.8ms (resto para Ley IX, render sync, orÃ¡culo, UI).

XIII.3. DegradaciÃ³n segura bajo carga

Reducir vecindad efectiva:
ğ¾
max
â¡
â†“
K
max
	â€‹

â†“ por LOD (Ley III/V).

Desactivar Ã¡rbol completo y usar solo NodeAgg coarse.

Limitar eventos por frame (cascada
ğ¶
max
â¡
C
max
	â€‹

), difiriendo a cola SPSC.
Nunca se compacts buffers ni se aloca; la latencia permanece acotada.

ARTÃCULO XIV â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para dinÃ¡mica sistÃ©mica)
XIV.1. ReutilizaciÃ³n compatible del layout Meta32 (sin romper Ley IX/V/III)

Se ratifica el layout superior (Ley IX) y se define dinÃ¡mica usando sub-cÃ³digos en STATUS4 y aux bytes en pack32 (Vertex28), sin invadir flags vitales.

Meta32 (uint32):

[
31
:
28
]
[31:28] LOD4 / TSD_hi4 (Ley III/V)

[
27
:
24
]
[27:24] FLAGS4: DISPUTA/FLASH/VOID_READY/AGONY (Ley IX)

[
23
:
20
]
[23:20] STATUS4: rÃ©gimen + subestado dinÃ¡mico (LEY IV)

[
19
:
16
]
[19:16] VITAL4: INVISIBLE/EJECT_PENDING/VOL_FAKE/AGONY_FREEZE (Ley IX)

[
15
:
8
]
[15:8] RHO8 (Ley III)

[
7
:
4
]
[7:4] PS4 (Ley III, puede mapear energÃ­a cinÃ©tica cuantizada)

[
3
:
0
]
[3:0] MAT4 (Ley III, paleta derivable de jerarquÃ­a)

XIV.2. STATUS4: subestados ALFA para dinÃ¡mica (sin colisiÃ³n con SIGMA/OMEGA)

Se reserva:

0x0 ALFA_STABLE

0x1 ALFA_BORN (Ley II)

0x2 ALFA_MIGRATING (LEY IV: ruptura/transmigraciÃ³n en curso)

0x3 ALFA_COOLDOWN (LEY IV: protegido contra flip)

0x8..0xF SIGMA/OMEGA (Ley V, intocable)

MÃ¡scaras y reglas branchless:

static constexpr uint32_t MASK_STATUS4 = 0x00F00000u;

static inline uint32_t GetStatus4(uint32_t m){ return (m & MASK_STATUS4)>>20; }
static inline uint32_t SetStatus4(uint32_t m, uint32_t s){
  return (m & ~MASK_STATUS4) | ((s & 0xFu)<<20);
}

// Branchless: si migrating => status=2, si cooldown=>3, si none=>0, preservando SIGMA/OMEGA
static inline uint32_t ApplyDynStatus(uint32_t m, uint32_t migrating, uint32_t cooldown){
  uint32_t st = GetStatus4(m);
  uint32_t isThermo = (uint32_t)-(st >= 0x8u); // SIGMA/OMEGA intocable

  uint32_t s_alfa = 0u;
  s_alfa = (s_alfa & ~0xFu) | ( (uint32_t)-(migrating!=0) & 0x2u );
  s_alfa = (s_alfa & ~0xFu) | ( (uint32_t)-( (migrating==0) & (cooldown!=0) ) & 0x3u );
  // si ninguno: queda 0

  uint32_t m_alfa = SetStatus4(m, s_alfa);
  return (m & isThermo) | (m_alfa & ~isThermo);
}

XIV.3. pack32.aux como canal dinÃ¡mico cuantizado (cooldown/KE)

Se define pack32 (Ley III) y se asigna auxQ8 a cooldown o energÃ­a cinÃ©tica (modo ALFA):

ğ‘
ğ‘¢
ğ‘¥
ğ‘–
ğ‘„
8
=
c
l
a
m
p
[
0
,
255
]
(
âŒŠ
255
â‹…
s
a
t
â€‰â£
(
âˆ¥
ğ‘£
ğ‘–
âˆ¥
ğ‘£
max
â¡
)
âŒ‰
)
aux
i
Q8
	â€‹

=clamp
[0,255]
	â€‹

(âŒŠ255â‹…sat(
v
max
	â€‹

âˆ¥v
i
	â€‹

âˆ¥
	â€‹

)âŒ‰)

o bien
ğ‘
ğ‘¢
ğ‘¥
ğ‘–
ğ‘„
8
=
ğ‘
ğ‘œ
ğ‘œ
ğ‘™
ğ‘–
aux
i
Q8
	â€‹

=cool
i
	â€‹

 si se prioriza debuggabilidad. Shader puede mapearlo a brillo, estela o vibraciÃ³n sin floats extra.

XIV.4. Gating fÃ­sico/jerÃ¡rquico (Ley IX manda)

Regla soberana: si (meta & MASK_SKIP_PHYS)!=0, entonces:

no fuerzas, no migraciÃ³n, no actualizaciÃ³n de vecindad;

pos puede congelarse o disiparse por termodinÃ¡mica;

la salida Vertex28 se sigue emitiendo por dualidad 1:1 (Ley III), pero con alpha/LOD derivado.

AXIOMA FINAL

â€œEl universo de TITAN V8 es un manifold riemanniano conformal: activos-partÃ­culas evolucionan por fuerzas clÃ¡sicas, vacÃ­os como presiÃ³n y barreras adaptativas; y todo ello se ejecuta sin temblar el frame porque la fÃ­sica, como el silicio, obedece al contrato Vertex28.â€

LEY V â€” Inferencia SistÃ©mica y Persistencia Temporal
(RegÃ­menes de Vitalidad + Inercia de InformaciÃ³n + Cicatriz Visual)

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Los 3 Estados Vitales Obligatorios (ALFA, SIGMA, OMEGA)
3. ARTÃCULO II â€” Meta32: Bits Constitucionales para Estados + TSD (Sin CPU en Fading)
4. ARTÃCULO III â€” Inferencia: Memoria que deforma el acoplamiento
5. ARTÃCULO IV â€” Colapso de clÃºster (punto de ebulliciÃ³n) como mÃ©trica
6. ARTÃCULO V â€” NodeAgg como inferencia bayesiana de contagio (Shock â†’ Probabilidad)
7. ARTÃCULO VI â€” EspecificaciÃ³n WebGL2: Kernel GPU (TSD/Estado) + Shader de Cicatriz Visual
8. ARTÃCULO VII â€” Protocolo Anti-Caos (sin oscilaciones infinitas) y enmiendas tÃ©cnicas
9. ARTÃCULO VIII â€” Modelo de coste y presupuesto de rendimiento (LEY V)
10. ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para LEY V)
11. AXIOMA FINAL

Ãmbito
(ConstituciÃ³n operativa)

LEY V â€” Inferencia SistÃ©mica y Persistencia Temporal


Axioma rector: â€œNingÃºn activo muere: solo transita de masa a memoria. Su estado gobierna su visibilidad; su TSD gobierna su persistencia; su shock gobierna la cicatriz. En TITANV8, la inferencia es la conservaciÃ³n de la informaciÃ³n bajo un bus de 28 bytes.â€


La LEY V gobierna la post-vida computacional de los activos en un universo de N = 200,000, bajo:

Frame budget fijo:
16.67

m
s
16.67 ms por tick (60 FPS nominal).

Bus soberano: Vertex28 (stride 28 bytes) como Ãºnica realidad exportable (Ley III).

WebGL2: sin compute shaders nativos; todo cÃ³mputo GPU debe ser shader + transform feedback + ping-pong, sin realloc de VBO.

ProhibiciÃ³n absoluta: no aÃ±adir campos al bus para â€œpersistenciaâ€; la persistencia se implementa por reinterpretaciÃ³n de Meta32 + lectura de Risk/Shock ya existentes (Ley III/IV/IX).

Cero micro-stuttering en: desvanecimiento (fade), cicatriz (stain/trail), transiciones ALFAâ†’SIGMAâ†’OMEGA, y telemetrÃ­a de inferencia (NodeAgg).

IntegraciÃ³n estricta con:

Ley I: identidad estable (UID64/IDX16/hid32) y determinismo del linaje.

Ley II: nacimiento como inyecciÃ³n con ramp-up; no se â€œreviveâ€, se reencarna vÃ­a slots.

Ley III: dualidad 1:1: todo lo visible debe estar en Vertex28.

Ley IV: dinÃ¡mica/solver: la memoria (fantasma) deforma acoplamientos y fricciÃ³n.

Ley VI: orÃ¡culo/ataque/cuarentena: flags de DISPUTA/FLASH/LOCKDOWN modulan persistencia.

Ley VII: Atlas/DNA/SENT8: identidad ancla propiedades; persistencia nunca rompe el mapa.

Ley VIII: VoidPool: OMEGA habilita slot reutilizable lock-free.

Ley IX: horizonte: AGONY/EJECT_PENDING/VOID_READY y gating soberano.

ARTÃCULO I â€” Los 3 Estados Vitales Obligatorios (ALFA, SIGMA, OMEGA)
I.1. ALFA (Activo)

DefiniciÃ³n: activo plenamente vivo: contribuye a dinÃ¡mica, acoplamiento, presiÃ³n de vacÃ­os y render.
CodificaciÃ³n constitucional: STATE = ALFA y TSD_LOG = 0.

Propiedades:

ğ›¼
ğ‘–
(
ğ‘¡
)
=
ğ›¼
b
a
s
e
Î±
i
	â€‹

(t)=Î±
base
	â€‹

 (opacidad normal).

ğ‘ƒ
ğ‘œ
ğ‘–
ğ‘›
ğ‘¡
ğ‘†
ğ‘–
ğ‘§
ğ‘’
ğ‘–
(
ğ‘¡
)
PointSize
i
	â€‹

(t) regido por Ley III/IV (riesgo/shock/densidad).

Participa en NodeAgg â€œvivoâ€: sus magnitudes alimentan
ğ‘Ÿ
Ë‰
ğ‘
,
ğ‘ 
Ë‰
ğ‘
r
Ë‰
c
	â€‹

,
s
Ë‰
c
	â€‹

.

ProhibiciÃ³n: ALFA no puede â€œdesaparecerâ€ por borrar el vÃ©rtice; solo puede transitar por estado (SIGMA/OMEGA) sin realloc del VBO.

I.2. SIGMA (Shadow / Persistencia)

DefiniciÃ³n: el activo deja de ser masa dinÃ¡mica principal, pero conserva informaciÃ³n como residuo (fantasma) que:

persiste visualmente (cicatriz), y

persiste sistÃ©micamente (deforma contagio).

CodificaciÃ³n: STATE = SIGMA y TSD_LOG âˆˆ [1..255] creciente (o saturante).

Cicatriz visual: se rige por un kernel de decaimiento
ğ‘Š
(
Î”
ğ‘¡
)
W(Î”t) aplicado sobre shock y/o riesgo.

Residuo dinÃ¡mico: genera
ğº
ğ‘—
(
ğ‘¡
)
G
j
	â€‹

(t) y contribuye a
ğº
ğ‘
(
ğ‘¡
)
G
c
	â€‹

(t) por categorÃ­a (Art. III), modulando acoplamientos y/o fricciÃ³n del solver (Ley IV).

I.3. OMEGA (Liquidado / Slot Reutilizable)

DefiniciÃ³n: â€œcadÃ¡ver frÃ­oâ€: la contribuciÃ³n visual tiende a cero; el slot es reutilizable por VoidPool (Ley VIII) sin reordenar buffers.

CodificaciÃ³n: STATE = OMEGA y TSD_LOG saturado o superando umbral TSD_HIDE.

Presencia visual: asintÃ³ticamente nula:

ğ›¼
ğ‘–
(
ğ‘¡
)
â†’
0
y/o
ğ‘ƒ
ğ‘œ
ğ‘–
ğ‘›
ğ‘¡
ğ‘†
ğ‘–
ğ‘§
ğ‘’
ğ‘–
(
ğ‘¡
)
â†’
0
Î±
i
	â€‹

(t)â†’0y/oPointSize
i
	â€‹

(t)â†’0

PolÃ­tica â€œlazy removalâ€:

No se mueve posiciÃ³n si no hace falta (para evitar stutter).

Se fuerza invisibilidad en shader por estado y/o
ğ‘‡
ğ‘†
ğ·
TSD (Art. VII.3).

Interfaz con Ley VIII: si STATE=OMEGA y TSD_LOGâ‰¥TSD_FREE, entonces slot es void-ready.

ARTÃCULO II â€” Meta32: Bits Constitucionales para Estados + TSD (Sin CPU en Fading)
II.1. Layout mÃ­nimo obligatorio de Meta32 (V.1) â€” 32 bits exactos

Se define Meta32 V.1 como soberano para LEY V:

Bits	Campo	TamaÃ±o	Rango	SemÃ¡ntica
31..30	STATE	2	0..3	0=ALFA, 1=SIGMA, 2=OMEGA, 3=RESERVADO
29..22	TSD_LOG	8	0..255	Inercia temporal logarÃ­tmica (msâ†’cÃ³digo)
21..16	CLUSTER_CRIT	6	0..63	criticidad de clÃºster / punto de ebulliciÃ³n local
15..8	COOLDOWN_T	8	0..255	cooldown ticks (anti-oscilaciÃ³n)
7..0	FLAGS8	8	bits	flags de persistencia/inferencia

JustificaciÃ³n de tamaÃ±os (Bohrium + WebGL2 + bus fijo):

STATE 2b: 3 regÃ­menes obligatorios + 1 reservado para compatibilidad futura sin romper el bus.

TSD_LOG 8b: precisiÃ³n alta cerca de
ğ‘¡
=
0
t=0 y saturaciÃ³n suave hasta 60s (percepciÃ³n humana).

CLUSTER_CRIT 6b: suficiente para quantizar alarmas sistÃ©micas por categorÃ­a sin float extra.

COOLDOWN_T 8b: control de flips y reacciones en cadena (Ley IV/VII).

FLAGS8 8b: mÃ­nimos para gobernar visibilidad, congelaciÃ³n, â€œstain modeâ€, y enlace con Ley VI/IX.

II.2. TSD logarÃ­tmico como inercia de informaciÃ³n (0msâ†’60s)

Objetivo: alta resoluciÃ³n para los primeros segundos (cicatriz visible), y cola larga asintÃ³tica hasta 60s sin necesidad de floats ni timers por activo.

Se define el decode (cÃ³digoâ†’ms):

ğ‘¡
m
s
(
ğ‘
)
=
ğ¶
(
2
ğ‘
/
ğ‘†
âˆ’
1
)
t
ms
	â€‹

(q)=C(2
q/S
âˆ’1)

y el encode (msâ†’cÃ³digo):

ğ‘
=
r
o
u
n
d
â€‰â£
(
ğ‘†
log
â¡
2
â€‰â£
(
ğ‘¡
m
s
ğ¶
+
1
)
)
q=round(Slog
2
	â€‹

(
C
t
ms
	â€‹

	â€‹

+1))

CalibraciÃ³n constitucional: exigir

ğ‘¡
m
s
(
0
)
=
0
,
ğ‘¡
m
s
(
255
)
=
60000
t
ms
	â€‹

(0)=0,t
ms
	â€‹

(255)=60000

Tomando
ğ‘†
=
255
S=255, resulta:

60000
=
ğ¶
(
2
1
âˆ’
1
)

â‡’

ğ¶
=
60000
60000=C(2
1
âˆ’1) â‡’ C=60000

Por tanto:

ğ‘¡
m
s
(
ğ‘
)
=
60000
(
2
ğ‘
/
255
âˆ’
1
)
,
ğ‘
=
r
o
u
n
d
â€‰â£
(
255
log
â¡
2
â€‰â£
(
ğ‘¡
m
s
60000
+
1
)
)
t
ms
	â€‹

(q)=60000(2
q/255
âˆ’1),q=round(255log
2
	â€‹

(
60000
t
ms
	â€‹

	â€‹

+1))

Consecuencia clave: se puede hacer decaimiento en shader sin almacenar
Î”
ğ‘¡
Î”t exacto: basta con
ğ‘
q.

II.3. DecodificaciÃ³n en GPU (sin exp() costoso)

Dos rutas constitucionales:

Ruta A (preferida por simplicidad): exp2

Usar identidad:

ğ‘’
âˆ’
ğœ†
ğ‘¡
=
2
âˆ’
ğœ†
ğ‘¡
/
ln
â¡
2
e
âˆ’Î»t
=2
âˆ’Î»t/ln2

Si
ğ‘¡
t estÃ¡ en ms:

ğ‘Š
(
ğ‘¡
)
=
exp
â¡
(
âˆ’
ğœ†
ğ‘¡
)
=
exp
â¡
2
(
âˆ’
ğ‘˜
ğ‘¡
)
,
ğ‘˜
=
ğœ†
/
ln
â¡
2
W(t)=exp(âˆ’Î»t)=exp
2
	â€‹

(âˆ’kt),k=Î»/ln2

GLSL (pseudo):

// decode TSD_LOG -> t_ms
float tsd_ms(uint q){
  return 60000.0 * (exp2(float(q) / 255.0) - 1.0);
}

// decay kernel using exp2 (cheap)
float W_decay(uint q, float lambda){
  float t = tsd_ms(q);                 // ms
  float k = lambda / 0.69314718056;    // lambda / ln(2)
  return exp2(-k * (t * 0.001));       // convert ms->s if lambda in 1/s
}

Ruta B (preferida por predictibilidad): LUT 1D

Una LUT
ğ¿
[
ğ‘
]
=
ğ‘Š
(
ğ‘¡
m
s
(
ğ‘
)
)
L[q]=W(t
ms
	â€‹

(q)) precalculada (256 entradas) en textura 1D o UBO.

ARTÃCULO III â€” Inferencia: Memoria que deforma el acoplamiento
ğ‘‡
ğ‘–
ğ‘—
T
ij
	â€‹

III.1. Axioma de memoria: el residuo dinÃ¡mico

Cuando un activo transita fuera de ALFA, no desaparece del universo informacional. Se convierte en un residuo que:

persiste como â€œcampo fantasmaâ€ que afecta contagio,

persiste como cicatriz visual gobernada por shock.

Formalmente: el conjunto de activos se particiona:

ğ´
(
ğ‘¡
)
=
ğ´
ğ›¼
(
ğ‘¡
)

âˆª

ğ´
ğœ
(
ğ‘¡
)

âˆª

ğ´
ğœ”
(
ğ‘¡
)
A(t)=A
Î±
	â€‹

(t) âˆª A
Ïƒ
	â€‹

(t) âˆª A
Ï‰
	â€‹

(t)

y la inferencia usa
ğ´
ğœ
âˆª
ğ´
ğœ”
A
Ïƒ
	â€‹

âˆªA
Ï‰
	â€‹

 como memoria.

III.2. Campo fantasma por activo
ğº
ğ‘—
(
ğ‘¡
)
G
j
	â€‹

(t)

Para un activo
ğ‘—
j no-ALFA:

ğº
ğ‘—
(
ğ‘¡
)
=
âˆ£
ğ‘ 
ğ‘—
âˆ£
â‹…
ğ‘Š
(
ğ‘¡
ğ‘ 
ğ‘‘
ğ‘—
(
ğ‘¡
)
)
G
j
	â€‹

(t)=âˆ£s
j
	â€‹

âˆ£â‹…W(tsd
j
	â€‹

(t))

donde:

ğ‘ 
ğ‘—
s
j
	â€‹

 es shock escalar (float32 ya existente, o cuantizado en pack32),

ğ‘Š
(
â‹…
)
W(â‹…) es kernel de decaimiento (exp2/LUT).

Kernel canÃ³nico:

ğ‘Š
(
Î”
ğ‘¡
)
=
ğ‘’
âˆ’
ğœ†
Î”
ğ‘¡
â‡’
ğ‘Š
(
ğ‘
)
=
ğ‘’
âˆ’
ğœ†

ğ‘¡
m
s
(
ğ‘
)
W(Î”t)=e
âˆ’Î»Î”t
â‡’W(q)=e
âˆ’Î»t
ms
	â€‹

(q)

Con clamp:

ğº
ğ‘—
(
ğ‘¡
)
â†
min
â¡
(
ğº
ğ‘—
(
ğ‘¡
)
,
ğº
max
â¡
)
G
j
	â€‹

(t)â†min(G
j
	â€‹

(t),G
max
	â€‹

)

InterpretaciÃ³n: shock â€œmuertoâ€ conserva influencia pero decae suavemente.

III.3. Campo fantasma por categorÃ­a (NodeAgg como integrador)

Para cada categorÃ­a
ğ‘
c:

ğº
ğ‘
(
ğ‘¡
)
=
âˆ‘
ğ‘—
âˆˆ
ğ‘
,

ğ‘ 
ğ‘¡
ğ‘
ğ‘¡
ğ‘’
ğ‘—
â‰ 
ğ´
ğ¿
ğ¹
ğ´
ğº
ğ‘—
(
ğ‘¡
)
G
c
	â€‹

(t)=
jâˆˆc, state
j
	â€‹

î€ 
=ALFA
âˆ‘
	â€‹

G
j
	â€‹

(t)

Computable vÃ­a reducciÃ³n jerÃ¡rquica en NodeAgg sin tocar el stride: solo se requiere leer STATE, TSD_LOG, y shock
ğ‘ 
s existente.

III.4. DeformaciÃ³n mÃ­nima del acoplamiento por memoria

El acoplamiento efectivo se define:

ğ‘‡
ğ‘–
ğ‘—
e
f
f
(
ğ‘¡
)
=
ğ‘‡
ğ‘–
ğ‘—
(
ğ‘¡
)
(
1
+
ğœ‚

ğº
ğ‘—
(
ğ‘¡
)
)
T
ij
eff
	â€‹

(t)=T
ij
	â€‹

(t)(1+Î·G
j
	â€‹

(t))

y por categorÃ­a:

ğ‘‡
ğ‘
â†’
ğ‘‘
e
f
f
(
ğ‘¡
)
=
ğ‘‡
ğ‘
â†’
ğ‘‘
(
ğ‘¡
)
(
1
+
ğœ‚

ğº
ğ‘
(
ğ‘¡
)
)
T
câ†’d
eff
	â€‹

(t)=T
câ†’d
	â€‹

(t)(1+Î·G
c
	â€‹

(t))

Lectura operativa (Ley IV):

si
ğº
G alto, el tejido â€œrecuerdaâ€ el shock â‡’ aumenta contagio o fricciÃ³n, segÃºn modo.

No se aÃ±ade ningÃºn float:
ğœ‚
Î· es constante global o LUT por categorÃ­a.

ARTÃCULO IV â€” Colapso de clÃºster (punto de ebulliciÃ³n) como mÃ©trica
Î”
ğ‘
Î”q
IV.1. Histograma de shocks y â€œq efectivoâ€

Para categorÃ­a
ğ‘
c, se construye histograma normalizado sobre magnitud:

ğ‘
ğ‘˜
(
ğ‘
,
ğ‘¡
)
=
ğ‘›
ğ‘˜
(
ğ‘
,
ğ‘¡
)
ğœ€
+
âˆ‘
â„“
ğ‘›
â„“
(
ğ‘
,
ğ‘¡
)
p
k
	â€‹

(c,t)=
Îµ+âˆ‘
â„“
	â€‹

n
â„“
	â€‹

(c,t)
n
k
	â€‹

(c,t)
	â€‹


y se computa Tsallis:

ğ‘†
ğ‘
(
ğ‘
,
ğ‘¡
)
=
1
âˆ’
âˆ‘
ğ‘˜
ğ‘
ğ‘˜
(
ğ‘
,
ğ‘¡
)
ğ‘
ğ‘
âˆ’
1
S
q
	â€‹

(c,t)=
qâˆ’1
1âˆ’âˆ‘
k
	â€‹

p
k
	â€‹

(c,t)
q
	â€‹

DefiniciÃ³n operativa de
ğ‘
e
f
f
q
eff
	â€‹

 (calibrable, barata)

En vez de resolver un root-finding por frame, se define
ğ‘
e
f
f
q
eff
	â€‹

 desde el Ã­ndice de concentraciÃ³n:

ğ‘…
2
(
ğ‘
,
ğ‘¡
)
=
âˆ‘
ğ‘˜
ğ‘
ğ‘˜
(
ğ‘
,
ğ‘¡
)
2
R
2
	â€‹

(c,t)=
k
âˆ‘
	â€‹

p
k
	â€‹

(c,t)
2

y se mapea:

ğ‘
e
f
f
(
ğ‘
,
ğ‘¡
)
=
c
l
i
p
â€‰â£
(
1
+
ğ›¼
ğ‘
ğ‘…
2
(
ğ‘
,
ğ‘¡
)
âˆ’
ğ‘…
2
ğ‘Ÿ
ğ‘’
ğ‘“
(
ğ‘
)
ğœ€
+
ğ‘…
2
ğ‘Ÿ
ğ‘’
ğ‘“
(
ğ‘
)
,

ğ‘
min
â¡
,
ğ‘
max
â¡
)
q
eff
	â€‹

(c,t)=clip(1+Î±
q
	â€‹

Îµ+R
2
ref
	â€‹

(c)
R
2
	â€‹

(c,t)âˆ’R
2
ref
	â€‹

(c)
	â€‹

, q
min
	â€‹

,q
max
	â€‹

)

InterpretaciÃ³n: mayor concentraciÃ³n de shocks â‡’ colas mÃ¡s pesadas â‡’
ğ‘
e
f
f
â†‘
q
eff
	â€‹

â†‘.

IV.2. MÃ©trica de alarma previa
Î”
ğ‘
Î”q y disparo sistÃ©mico
Î”
ğ‘
(
ğ‘
,
ğ‘¡
)
=
âˆ£
ğ‘
e
f
f
(
ğ‘
,
ğ‘¡
)
âˆ’
ğ‘
r
e
f
(
ğ‘
)
âˆ£
Î”q(c,t)=âˆ£q
eff
	â€‹

(c,t)âˆ’q
ref
	â€‹

(c)âˆ£

Se dispara estado crÃ­tico si:

max
â¡
ğ‘
Î”
ğ‘
(
ğ‘
,
ğ‘¡
)
â‰¥
Î”
ğ‘
c
r
i
t
âˆ§
âˆ‘
ğ‘
ğº
ğ‘
(
ğ‘¡
)
â‰¥
ğº
c
r
i
t
c
max
	â€‹

Î”q(c,t)â‰¥Î”q
crit
	â€‹

âˆ§
c
âˆ‘
	â€‹

G
c
	â€‹

(t)â‰¥G
crit
	â€‹


La segunda condiciÃ³n amarrra explÃ­citamente â€œmemoria de shocks muertosâ€ con el rÃ©gimen de riesgo.

Salida al bus: CLUSTER_CRIT cuantiza
Î”
ğ‘
Î”q (0..63):

ğ‘
ğ‘Ÿ
ğ‘–
ğ‘¡
ğ‘
=
âŒŠ
63
â‹…
s
a
t
[
0
,
1
]
(
Î”
ğ‘
(
ğ‘
,
ğ‘¡
)
Î”
ğ‘
c
r
i
t
)
âŒ‰
crit
c
	â€‹

=âŒŠ63â‹…sat
[0,1]
	â€‹

(
Î”q
crit
	â€‹

Î”q(c,t)
	â€‹

)âŒ‰
ARTÃCULO V â€” NodeAgg como inferencia bayesiana de contagio (Shock â†’ Probabilidad)
V.1. Variable latente de crisis por categorÃ­a

Evento latente:

ğ¶
ğ‘
âˆˆ
{
0
,
1
}
C
c
	â€‹

âˆˆ{0,1}

Evidencia:

ğ¸
ğ‘
(
ğ‘¡
)
=
ğ›¼
ğ‘ 
âˆ£
ğ‘ 
Ë‰
âˆ£
ğ‘
(
ğ‘¡
)
+
ğ›¼
ğ‘Ÿ
ğ‘Ÿ
Ë‰
ğ‘
(
ğ‘¡
)
+
ğ›¼
ğ‘”
ğº
ğ‘
(
ğ‘¡
)
E
c
	â€‹

(t)=Î±
s
	â€‹

âˆ£
s
Ë‰
âˆ£
c
	â€‹

(t)+Î±
r
	â€‹

r
Ë‰
c
	â€‹

(t)+Î±
g
	â€‹

G
c
	â€‹

(t)

donde
âˆ£
ğ‘ 
Ë‰
âˆ£
ğ‘
âˆ£
s
Ë‰
âˆ£
c
	â€‹

 es media de shock absoluto,
ğ‘Ÿ
Ë‰
ğ‘
r
Ë‰
c
	â€‹

 media de riesgo, y
ğº
ğ‘
G
c
	â€‹

 memoria.

V.2. Posterior bayesiano (forma logÃ­stica shader-friendly)
ğ‘ƒ
(
ğ¶
ğ‘
=
1
âˆ£
ğ¸
ğ‘
)
=
ğœ
(
ğ›½
0
+
ğ›½
1
ğ¸
ğ‘
)
P(C
c
	â€‹

=1âˆ£E
c
	â€‹

)=Ïƒ(Î²
0
	â€‹

+Î²
1
	â€‹

E
c
	â€‹

)

La sigmoide se implementa como LUT (256 o 1024) o aproximaciÃ³n exp2 (si se tolera).

V.3. PropagaciÃ³n dirigida (hazard entre categorÃ­as)
ğ‘ƒ
(
ğ¶
ğ‘‘
=
1
âˆ£
ğ¶
ğ‘
=
1
)
=
s
a
t
â€‰â£
(
ğ›¾

ğ‘‡
ğ‘
â†’
ğ‘‘
e
f
f
(
ğ‘¡
)
)
P(C
d
	â€‹

=1âˆ£C
c
	â€‹

=1)=sat(Î³T
câ†’d
eff
	â€‹

(t))

Hazard final:

ğ»
ğ‘‘
(
ğ‘¡
)
=
1
âˆ’
âˆ
ğ‘
âˆˆ
ğ‘
(
ğ‘‘
)
(
1
âˆ’
ğ‘ƒ
(
ğ¶
ğ‘
=
1
âˆ£
ğ¸
ğ‘
)
â‹…
ğ‘ƒ
(
ğ¶
ğ‘‘
=
1
âˆ£
ğ¶
ğ‘
=
1
)
)
H
d
	â€‹

(t)=1âˆ’
câˆˆN(d)
âˆ
	â€‹

(1âˆ’P(C
c
	â€‹

=1âˆ£E
c
	â€‹

)â‹…P(C
d
	â€‹

=1âˆ£C
c
	â€‹

=1))

Acoplamientos:
ğ‘‡
ğ‘
â†’
ğ‘‘
T
câ†’d
	â€‹

 proviene de estructura jerÃ¡rquica y afinidades robustas (Ley IV/VII).
Uso:
ğ»
ğ‘‘
H
d
	â€‹

 modula:

presiÃ³n de vacÃ­os (Ley IV:
ğ‘‰
v
a
c
V
vac
	â€‹

),

fricciÃ³n global
ğ›¾
Î³,

severidad de cooldown o persistencia.

ARTÃCULO VI â€” EspecificaciÃ³n WebGL2: Kernel GPU (TSD/Estado) + Shader de Cicatriz Visual
VI.1. â€œComputeâ€ en WebGL2: Transform Feedback (ping-pong sin realloc)

Se define un kernel equivalente: un vertex shader lee atributos (Vertex28), actualiza Meta32 y emite un nuevo buffer.

Pipeline:

Bind VAO_A (buffer actual)

Bind TF_B (buffer destino)

gl.beginTransformFeedback(GL.POINTS) con rasterizer discard

Draw N points

Swap Aâ†”B

Pseudo C++ (alto nivel):

void K_TSD_UPDATE_GPU(){
  glEnable(GL_RASTERIZER_DISCARD);
  bindVAO(src);
  bindTransformFeedback(dst);
  glBeginTransformFeedback(GL_POINTS);
  glDrawArrays(GL_POINTS, 0, N);
  glEndTransformFeedback();
  glDisable(GL_RASTERIZER_DISCARD);
  swap(src, dst);
}

VI.2. Vertex shader: transiciÃ³n de estado + cooldown + TSD

Reglas:

Si STATE==ALFA: TSD_LOG=0.

Si STATE!=ALFA: TSD_LOG incrementa logarÃ­tmicamente (o por LUT de incrementos) hasta 255.

COOLDOWN_T decae a 0.

Transiciones:

ALFAâ†’SIGMA: cuando FLAGS8.F_KILLED o gating Ley IX indica salida de masa.

SIGMAâ†’OMEGA: cuando TSD_LOG â‰¥ TSD_OMEGA o FLAGS8.F_FORCE_OMEGA.

GLSL (pseudo):

version 300 es
precision highp float;
precision highp int;
layout(location=0) in vec2 a_pos;
layout(location=1) in vec2 a_rs;     // risk/shock packed or floats (existing)
layout(location=2) in uint a_meta;   // Meta32 V.1
layout(location=3) in uint a_hid;    // hid32

flat out uint v_meta;
out vec2 v_pos;
out vec2 v_rs;

uint GET_STATE(uint m){ return (m >> 30u) & 0x3u; }
uint GET_TSD  (uint m){ return (m >> 22u) & 0xFFu; }
uint GET_CRIT (uint m){ return (m >> 16u) & 0x3Fu; }
uint GET_COOL (uint m){ return (m >>  8u) & 0xFFu; }
uint GET_FLG  (uint m){ return (m >>  0u) & 0xFFu; }

uint SET_FIELD(uint m, uint v, uint sh, uint mask){
  return (m & ~mask) | ((v << sh) & mask);
}

uint inc_tsd(uint q){
  // LUT opcional: INC[q] precomputado para dtâ‰ˆ16.67ms
  // fallback: +1 saturado (simple)
  return min(255u, q + 1u);
}

void main(){
  uint m = a_meta;
  uint st = GET_STATE(m);
  uint q  = GET_TSD(m);
  uint cd = GET_COOL(m);
  uint fl = GET_FLG(m);

  // cooldown decae
  cd = (cd > 0u) ? (cd - 1u) : 0u;

  // transiciones (ejemplo): bit0 = killed, bit1 = force_omega
  bool killed = (fl & 0x01u) != 0u;
  bool fomega = (fl & 0x02u) != 0u;

  if(st == 0u){ // ALFA
    q = 0u;
    if(killed){ st = 1u; q = 1u; } // ALFA->SIGMA
  }else{ // SIGMA u OMEGA
    q = inc_tsd(q);
    if(fomega || q >= 220u){ st = 2u; } // -> OMEGA
  }

  // writeback
  m = SET_FIELD(m, st, 30u, 0xC0000000u);
  m = SET_FIELD(m, q , 22u, 0x3FC00000u);
  m = SET_FIELD(m, cd,  8u, 0x0000FF00u);

  v_meta = m;
  v_pos  = a_pos;
  v_rs   = a_rs;

  gl_Position = vec4(a_pos, 0.0, 1.0);
}

VI.3. Fragment shader: cicatriz visual (stain/trail) por Shock + TSD

Principio: la cicatriz depende de shock y decae por
ğ‘Š
(
ğ‘‡
ğ‘†
ğ·
)
W(TSD). No se introduce textura histÃ³rica: se usa point sprite + alpha modulado.

GLSL (pseudo):

version 300 es
precision highp float;
precision highp int;
flat in uint v_meta;
in vec2 v_rs; // risk, shock (o packed)
out vec4 fragColor;

uint GET_STATE(uint m){ return (m >> 30u) & 0x3u; }
uint GET_TSD  (uint m){ return (m >> 22u) & 0xFFu; }
uint GET_CRIT (uint m){ return (m >> 16u) & 0x3Fu; }

float tsd_ms(uint q){
  return 60000.0 * (exp2(float(q) / 255.0) - 1.0);
}

float decay(uint q){
  float t = tsd_ms(q) * 0.001;           // seconds
  float lambda = 1.4;                    // 1/s (tunable global)
  float k = lambda / 0.69314718056;
  return exp2(-k * t);
}

void main(){
  uint st = GET_STATE(v_meta);
  uint q  = GET_TSD(v_meta);
  float shock = abs(v_rs.y);

  // alpha base: ALFA normal, SIGMA/OMEGA decae
  float a = 1.0;
  if(st == 1u){ a = decay(q); }
  else if(st == 2u){ a = 0.35 * decay(q); }

  // cicatriz gobernada por shock (clamp)
  float scar = clamp(shock, 0.0, 1.0);
  a *= (0.25 + 0.75 * scar);

  // "stain mode" opcional: usar crit para teÃ±ir/ensanchar (sin cambiar bus)
  float crit = float(GET_CRIT(v_meta)) / 63.0;
  a *= (1.0 + 0.35 * crit);

  if(a < 0.003) discard;
  fragColor = vec4(1.0, 1.0, 1.0, a);
}

ARTÃCULO VII â€” Protocolo Anti-Caos (sin oscilaciones infinitas) y enmiendas tÃ©cnicas
VII.1. Robustez constitucional (FP32 discipline)

Todas las funciones de decaimiento y sigmoides deben estar acotadas y ser monÃ³tonas.

TSD_LOG satura en 255: no hay overflow.

Si TSD_LOG=255 y STATE=OMEGA, el activo es â€œfrÃ­oâ€: no puede reactivar efectos.

VII.2. Cooldown + dt_to_tsd_code determinista (LUT de incrementos)

Para evitar que
ğ‘‡
ğ‘†
ğ·
TSD avance demasiado rÃ¡pido o lento segÃºn frame pacing, se define:

ğ‘
(
ğ‘¡
+
Î”
ğ‘¡
)
=
min
â¡
(
255
,

ğ‘
(
ğ‘¡
)
+
Î”
ğ‘
(
ğ‘
(
ğ‘¡
)
,
Î”
ğ‘¡
)
)
q(t+Î”t)=min(255, q(t)+Î”q(q(t),Î”t))

donde
Î”
ğ‘
Î”q se obtiene de LUT precomputada para
Î”
ğ‘¡
Î”t nominal (16.67ms) o para un pequeÃ±o set de bins de
Î”
ğ‘¡
Î”t.

ConstrucciÃ³n (offline o init):

Î”
ğ‘
(
ğ‘
)
=
max
â¡
(
1
,

r
o
u
n
d
(
ğ‘
(
ğ‘¡
+
Î”
ğ‘¡
)
âˆ’
ğ‘
(
ğ‘¡
)
)
)
Î”q(q)=max(1, round(q(t+Î”t)âˆ’q(t)))

con:

ğ‘
(
ğ‘¡
)
=
r
o
u
n
d
(
255
log
â¡
2
(
ğ‘¡
60000
+
1
)
)
q(t)=round(255log
2
	â€‹

(
60000
t
	â€‹

+1))

Esto garantiza avance suave en el dominio log.

VII.3. Lazy removal OMEGA (no mover posiciones si no hace falta)

Regla canÃ³nica:

STATE==OMEGA â‡’ visibilidad en shader:

si
ğ‘
>
ğ‘‡
ğ‘†
ğ·
_
ğ»
ğ¼
ğ·
ğ¸
q>TSD_HIDE â‡’ discard (o alpha=0).

CPU/GPU no tocan posiciÃ³n: evita cache churn y stutter.

VoidPool puede reciclar slot cuando STATE==OMEGA y
ğ‘
â‰¥
ğ‘‡
ğ‘†
ğ·
_
ğ¹
ğ‘…
ğ¸
ğ¸
qâ‰¥TSD_FREE.

VII.4. Parche de kernel actualizado (incorpora cooldown + transiciones + flags)

C++/WASM branchless (si se hace en CPU):

// Meta32 V.1 masks
static constexpr uint32_t M_STATE = 0xC0000000u; // 31..30
static constexpr uint32_t M_TSD   = 0x3FC00000u; // 29..22
static constexpr uint32_t M_CRIT  = 0x003F0000u; // 21..16
static constexpr uint32_t M_COOL  = 0x0000FF00u; // 15..8
static constexpr uint32_t M_FLG   = 0x000000FFu; // 7..0

static inline uint32_t GET(uint32_t m, uint32_t sh, uint32_t mask){ return (m & mask) >> sh; }
static inline uint32_t SET(uint32_t m, uint32_t sh, uint32_t mask, uint32_t v){
  return (m & ~mask) | ((v << sh) & mask);
}

static inline uint32_t inc_tsd_LUT(uint32_t q){
  // INC[q] precomputed for dtâ‰ˆ16.67ms
  return (q >= 255u) ? 255u : (q + INC[q]);
}

void K_TSD_UPDATE_CPU(uint32_t N, uint32_t* meta){
  for(uint32_t i=0;i<N;++i){
    uint32_t m = meta[i];
    uint32_t st = GET(m,30,M_STATE);
    uint32_t q  = GET(m,22,M_TSD);
    uint32_t cd = GET(m, 8,M_COOL);
    uint32_t fl = GET(m, 0,M_FLG);

    // cooldown decay
    cd = (cd>0u) ? (cd-1u) : 0u;

    uint32_t killed = (fl & 0x01u) ? 1u : 0u;
    uint32_t fomega = (fl & 0x02u) ? 1u : 0u;

    // transitions (branchless style)
    uint32_t isALFA = (st==0u);
    uint32_t isSIGO = 1u - isALFA;

    // ALFA: q=0; if killed -> SIGMA, q=1
    uint32_t st_after = st;
    uint32_t q_after  = q;

    // ALFA path
    uint32_t toSIG = isALFA & killed;
    st_after = toSIG ? 1u : st_after;
    q_after  = isALFA ? 0u : q_after;
    q_after  = toSIG  ? 1u : q_after;

    // SIGMA/OMEGA path: q increments
    uint32_t q_inc = inc_tsd_LUT(q_after);
    q_after = isSIGO ? q_inc : q_after;

    // SIGMA->OMEGA condition
    uint32_t toOMG = isSIGO & (fomega | (q_after >= 220u));
    st_after = toOMG ? 2u : st_after;

    // writeback
    m = SET(m,30,M_STATE, st_after);
    m = SET(m,22,M_TSD,   q_after);
    m = SET(m, 8,M_COOL,  cd);

    meta[i]=m;
  }
}

ARTÃCULO VIII â€” Modelo de coste y presupuesto de rendimiento (LEY V)
VIII.1. Coste de actualizaciÃ³n TSD/Estados (GPU)

Si se hace por transform feedback:

1 lectura de meta (uint), 1â€“2 ops de bitfield, 1 write de meta.

ğ‘
=
200
ğ‘˜
N=200k puntos: coste dominado por bandwidth, no por ALU.

Modelo simple:

ğ¶
T
S
D
â‰ˆ
ğ‘
â‹…
(
ğ‘
l
o
a
d
+
ğ‘
b
i
t
o
p
s
+
ğ‘
s
t
o
r
e
)
C
TSD
	â€‹

â‰ˆNâ‹…(c
load
	â€‹

+c
bitops
	â€‹

+c
store
	â€‹

)

Objetivo: que
ğ¾
ğ‘‡
ğ‘†
ğ·
_
ğ‘ˆ
ğ‘ƒ
ğ·
ğ´
ğ‘‡
ğ¸
K
TSD_UPDATE
	â€‹

 sea sub-milisegundo en GPU moderna.

VIII.2. Coste de render de cicatriz (fragment)

Depende de overdraw. Se controla con:

discard temprano cuando alpha < umbral.

LOD (Ley III): en densidad alta, reducir pointsize.

VIII.3. Coste de inferencia (NodeAgg + hist + Tsallis + Bayes)

ReducciÃ³n por categorÃ­a: O(N) por frame (o amortizado).

Histograma por bins
ğµ
B pequeÃ±o (p.ej. 16): O(CÂ·B).

Hazard dirigido usa vecindad de categorÃ­as (grafo pequeÃ±o): O(|E_cat|).

VIII.4. Presupuesto fijo constitucional

K_TSD_UPDATE â‰¤ 0.80 ms (GPU TF ping-pong)

K_VISUAL_DECAY â‰¤ 2.20 ms (fragment, controlado por LOD + discard)

K_INFERENCE â‰¤ 1.40 ms (CPU/WASM SIMD o GPU parcial)

Reglas para mantener presupuesto bajo carga:

bajar LOD (reduce overdraw),

subir umbral de discard,

reducir bins del histograma,

usar LUT en vez de exp2,

amortizar inferencia (cada 2â€“4 frames) sin romper determinismo (semilla por frame index).

ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para LEY V)
IX.1. Layout Meta32 V.1 (bit exacto)
STATE
âŸ
2

TSD_LOG
âŸ
8

CLUSTER_CRIT
âŸ
6

COOLDOWN_T
âŸ
8

FLAGS8
âŸ
8
2
STATE
	â€‹

	â€‹


8
TSD_LOG
	â€‹

	â€‹


6
CLUSTER_CRIT
	â€‹

	â€‹


8
COOLDOWN_T
	â€‹

	â€‹


8
FLAGS8
	â€‹

	â€‹


Bit positions:

STATE: bits 31..30

TSD_LOG: bits 29..22

CLUSTER_CRIT: bits 21..16

COOLDOWN_T: bits 15..8

FLAGS8: bits 7..0

IX.2. MÃ¡scaras y extractores (C/C++)
static constexpr uint32_t M_STATE = 0xC0000000u; // 31..30
static constexpr uint32_t M_TSD   = 0x3FC00000u; // 29..22
static constexpr uint32_t M_CRIT  = 0x003F0000u; // 21..16
static constexpr uint32_t M_COOL  = 0x0000FF00u; // 15..8
static constexpr uint32_t M_FLG   = 0x000000FFu; // 7..0

static inline uint32_t state(uint32_t m){ return (m>>30)&0x3u; }
static inline uint32_t tsd  (uint32_t m){ return (m>>22)&0xFFu; }
static inline uint32_t crit (uint32_t m){ return (m>>16)&0x3Fu; }
static inline uint32_t cool (uint32_t m){ return (m>> 8)&0xFFu; }
static inline uint32_t flg  (uint32_t m){ return (m>> 0)&0xFFu; }

IX.3. FLAGS8 (definiciÃ³n soberana)

Se definen bits mÃ­nimos (8) para persistencia e inferencia:

Bit	Nombre	Hex	SemÃ¡ntica
0	F_KILLED	0x01	dispara ALFAâ†’SIGMA
1	F_FORCE_OMEGA	0x02	fuerza entrada a OMEGA
2	F_TSD_FREEZE	0x04	congela TSD (cuarentena/orÃ¡culo)
3	F_STAIN_MODE	0x08	cicatriz â€œstainâ€ (shader)
4	F_TRAIL_MODE	0x10	cicatriz tipo estela (shader)
5	F_GHOST_AFF	0x20	habilita memoria deforma
ğ‘‡
ğ‘’
ğ‘“
ğ‘“
T
eff

6	F_LOCKDOWN	0x40	vinculado Ley VI (no reacciones)
7	F_RESERVED	0x80	reservado

MÃ¡scaras compuestas:

static constexpr uint32_t MASK_GHOST =
  0x20u /*F_GHOST_AFF*/ | 0x08u /*F_STAIN_MODE*/ | 0x10u /*F_TRAIL_MODE*/;

static constexpr uint32_t MASK_FORCE_DEATH =
  0x01u /*F_KILLED*/ | 0x02u /*F_FORCE_OMEGA*/;

IX.4. Reglas branchless para transiciones
// Branchless boolean -> mask
static inline uint32_t bmask(uint32_t b){ return 0u - (b & 1u); }

// Example: set STATE to SIGMA if killed and currently ALFA
static inline uint32_t set_sigma_if_killed(uint32_t m){
  uint32_t st = state(m);
  uint32_t f  = flg(m);
  uint32_t isALFA = (st==0u);
  uint32_t killed = (f & 0x01u) ? 1u : 0u;
  uint32_t toSIG  = isALFA & killed;

  uint32_t m2 = (m & ~M_STATE) | ((1u<<30) & M_STATE);
  return (m & ~bmask(toSIG)) | (m2 & bmask(toSIG));
}

AXIOMA FINAL

â€œNingÃºn activo muere: solo transita de masa a memoria. Su estado gobierna su visibilidad; su TSD gobierna su persistencia; su shock gobierna la cicatriz. En TITANV8, la inferencia es la conservaciÃ³n de la informaciÃ³n bajo un bus de 28 bytes.â€

LEY VI â€” El OrÃ¡culo y la Integridad de Fuente
Verdad Ãšnica, Consenso DinÃ¡mico y Cuarentena Determinista (sin bloqueos por I/O)

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Principios de No-NegociaciÃ³n y Modelo de Datos
3. ARTÃCULO II â€” Arquitectura Lock-Free: Ingesta, Doble BÃºfer y Swap AtÃ³mico
4. ARTÃCULO III â€” ReputaciÃ³n DinÃ¡mica de Fuente y PenalizaciÃ³n Anti-CÃ¡rtel
5. ARTÃCULO IV â€” Consenso DinÃ¡mico: Kalman Adaptativo como Atractor de Verdad
6. ARTÃCULO V â€” Pesos DinÃ¡micos y Operador de Consenso Determinista Multi-Fuente
7. ARTÃCULO VI â€” DetecciÃ³n de AnomalÃ­as y Cuarentena Determinista
8. ARTÃCULO VII â€” Consenso de Volumen y DetecciÃ³n de Spoofing (Volumen falso)
9. ARTÃCULO VIII â€” ProyecciÃ³n al Bus: cÃ³mo el OrÃ¡culo modula
10. ARTÃCULO IX â€” IntegraciÃ³n Inter-Ley (Conexiones obligatorias)
11. ARTÃCULO X â€” ImplementaciÃ³n de Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly
12. ARTÃCULO XI â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para el OrÃ¡culo)
13. ARTÃCULO XII â€” Auditabilidad y Trazabilidad (Integridad de Fuente como cadena verificable)
14. ARTÃCULO XIII â€” Modelo de Coste y Presupuesto (ciclos y ms)
15. ARTÃCULO XIV â€” Invariantes del OrÃ¡culo (ConstituciÃ³n de verdad y seguridad)
16. AXIOMA FINAL

Ãmbito
(ConstituciÃ³n operativa del OrÃ¡culo)

LEY VI â€” El OrÃ¡culo y la Integridad de Fuente


AXIOMA FINAL
â€œLa Verdad Ãšnica en TITAN V8 no es un precio real, sino un estado consensuado al que el sistema converge por control dinÃ¡mico, garantizando la integridad de fuente, la cuarentena determinista y la ausencia de bloqueos por I/O.â€


La LEY VI gobierna la construcciÃ³n de verdad a partir de S proveedores (feeds) sobre un universo de N = 200,000 activos bajo:

Tiempo discreto: tick
ğ‘¡
t con presupuesto
16.67

m
s
16.67ms/frame.

Presupuesto duro del OrÃ¡culo:

ğ¾
O
R
A
C
L
E
(
ğ‘¡
)
â‰¤
2.0

m
s
âˆ€
ğ‘¡
K
ORACLE
	â€‹

(t)â‰¤2.0msâˆ€t



Cap constitucional (bounded work por tick):

MAX_UPDATES_PER_TICK = 50,000 activos/tick.
Regla: el kernel de consenso/Kalman jamÃ¡s procesa mÃ¡s de MAX_UPDATES_PER_TICK en un solo tick.
El remanente se difiere al siguiente tick (cola lock-free) o se agrega por clave (sÃ­mbolo/celda) sin bloquear.
ProhibiciÃ³n: exceder el presupuesto temporal por â€œtormenta de datosâ€.
para no interferir con FÃ­sica (Ley IV) + Render (Ley III).

No-negociable: cero bloqueos por I/O: ninguna ruta de red/parseo/validaciÃ³n puede bloquear el hilo de simulaciÃ³n.

Salida constitucional al bus (Ley III): el OrÃ¡culo NO introduce campos. Solo puede modular:

ğ‘Ÿ
ğ‘–
ğ‘ 
ğ‘˜
ğ‘–
(
ğ‘¡
)
risk
i
	â€‹

(t),
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
)
shock
i
	â€‹

(t) (float32 ya existentes / pack existente), y

Meta32 (flags de integridad/disputa/flash/quarantine).

Determinismo operativo: ante discrepancia, el OrÃ¡culo decide; dentro de un tick no hay â€œrollbackâ€:

consistencia
â‰»
precisi
o
ËŠ
n externa
consistenciaâ‰»precisi
o
ËŠ
n externa

IntegraciÃ³n estricta:

Ley I: identidad (UID64/IDX16) como clave de consenso y auditorÃ­a.

Ley II: nacimiento no bloquea: toda incorporaciÃ³n de activo se hace con â€œestado consensuado inicialâ€.

Ley IV: el consenso es un atractor que estabiliza fuerzas; flags modulan barreras/cooldowns.

Ley V: cuarentena/disputa alimentan persistencia y â€œmemoria fantasmaâ€.

Ley VII: Atlas SoA conserva el estado del OrÃ¡culo (no el bus).

Ley VIII: VoidPool jamÃ¡s espera al OrÃ¡culo; el OrÃ¡culo solo marca y el ciclo de vida lo resuelve.

Ley IX: energÃ­a informacional y horizonte consumen
ğ‘‰
ğ‘–
ğ‘‡
(
ğ‘¡
)
V
i
T
	â€‹

(t),
ğ´
ğ‘–
(
ğ‘¡
)
A
i
	â€‹

(t) y flags de integridad.

ARTÃCULO I â€” Principios de No-NegociaciÃ³n y Modelo de Datos
I.1. La Verdad Ãšnica es un Atractor

Para cada activo
ğ‘–
i, el OrÃ¡culo define una verdad interna:

ğ‘
ğ‘–
ğ‘‡
(
ğ‘¡
)
(precio consensuado)
p
i
T
	â€‹

(t)(precio consensuado)

que no es â€œel precio realâ€, sino un estado al que el sistema converge bajo control dinÃ¡mico, incluso si las fuentes divergen.

Atractor (en sentido de control): existe un operador
ğ‘‚
O tal que:

ğ‘
ğ‘–
ğ‘‡
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ‘‚
(
ğ‘
ğ‘–
ğ‘‡
(
ğ‘¡
)
,
{
ğ‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
}
ğ‘ 
=
1
ğ‘†
,
Î˜
(
ğ‘¡
)
)
p
i
T
	â€‹

(t+Î”t)=O(p
i
T
	â€‹

(t),{p
i,s
	â€‹

(t)}
s=1
S
	â€‹

,Î˜(t))

y, si las fuentes son â€œrazonablesâ€ (ruido acotado y no-cÃ¡rtel), entonces:

âˆ¥
ğ‘
ğ‘–
ğ‘‡
(
ğ‘¡
+
Î”
ğ‘¡
)
âˆ’
ğ‘
ğ‘–
âˆ—
(
ğ‘¡
+
Î”
ğ‘¡
)
âˆ¥

â†“

0
âˆ¥p
i
T
	â€‹

(t+Î”t)âˆ’p
i
âˆ—
	â€‹

(t+Î”t)âˆ¥ â†“ 0

donde
ğ‘
ğ‘–
âˆ—
p
i
âˆ—
	â€‹

 es el â€œestado latenteâ€ (no observable directamente) del mercado.

I.2. Cero Bloqueos por I/O + determinismo por corte temporal

Ingesta asÃ­ncrona: threads por feed empujan eventos a buffers lock-free.

Consenso sÃ­ncrono: el hilo OrÃ¡culo consume un snapshot consistente por tick, con un cut-off temporal:

ğœ
â‰¤
ğœ
c
u
t
(
ğ‘¡
)
Ï„â‰¤Ï„
cut
	â€‹

(t)

Dentro de un tick, la regla es: lo que entrÃ³ antes del corte existe; lo demÃ¡s no existe.

I.3. Salida al bus: sÃ³lo risk/shock + Meta32

El OrÃ¡culo jamÃ¡s escribe â€œprecioâ€ al bus Vertex28 (prohibiciÃ³n ontolÃ³gica).
Su efecto es indirecto:

actualiza
ğ‘Ÿ
ğ‘–
ğ‘ 
ğ‘˜
ğ‘–
(
ğ‘¡
)
risk
i
	â€‹

(t),
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
)
shock
i
	â€‹

(t) (sensores visuales y dinÃ¡micos),

setea flags en Meta32 (disputa, quarantine, flash, volumen falso),

alimenta Atlas/NodeAgg (Ley VII) para uso por Ley IV/IX.

I.4. Snapshot de feed por activo y fuente

Para activo
ğ‘–
i y fuente
ğ‘ 
s, el OrÃ¡culo ve observaciones:

ğ‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
p
i,s
	â€‹

(t): precio observado

ğœ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
Ï„
i,s
	â€‹

(t): timestamp del evento (ns/ms, normalizado)

ğ‘‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
d
i,s
	â€‹

(t): profundidad (depth) o calidad microestructural

ğ¿
ğ‘ 
(
ğ‘¡
)
L
s
	â€‹

(t): latencia histÃ³rica de la fuente

ğ‘ˆ
ğ‘ 
(
ğ‘¡
)
U
s
	â€‹

(t): estabilidad/uptime

ğ‘£
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
v
i,s
	â€‹

(t): volumen observado (si existe)

ğ‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
q
i,s
	â€‹

(t): â€œquality bitsâ€ (banderas de feed: trade/quote/auction/etc.)

ARTÃCULO II â€” Arquitectura Lock-Free: Ingesta, Doble BÃºfer y Swap AtÃ³mico
II.1. Buffers SPSC por fuente (I/O jamÃ¡s bloquea)

Cada fuente
ğ‘ 
s tiene un ring buffer SPSC (Single-Producer / Single-Consumer):

Producer: hilo de red/parseo de
ğ‘ 
s

Consumer: hilo OrÃ¡culo

Estructura del evento (alineado, cache-friendly):

struct FeedEvent {             // 32 bytes (alinear a 32)
  uint64_t uid64;               // Ley I
  uint32_t ts_ms;               // timestamp normalizado (ms)
  float    price;               // p_{i,s}
  float    vol;                 // v_{i,s} (0 si N/A)
  uint16_t depth;               // d_{i,s} cuantizado
  uint8_t  src_id;              // s
  uint8_t  qbits;               // flags feed
  uint32_t crc32;               // integridad del evento (opcional)
};

II.2. Doble bÃºfer por tick: snapshot coherente

El OrÃ¡culo opera en dos niveles:

Ingesta (continua): llenar RB_s.

Tick (discreto): construir OBS_A o OBS_B y hacer swap atÃ³mico:

obs_ptr
â†
atomic_exchange(obs_ptr,

new_buf)
obs_ptrâ†atomic_exchange(obs_ptr, new_buf)

GarantÃ­a: el hilo de simulaciÃ³n/leyes superiores solo lee obs_ptr estable; jamÃ¡s espera.

II.3. Orden determinista de aplicaciÃ³n (anti-heisenbug)

Para cada tick, el OrÃ¡culo procesa observaciones con orden total:

(
ğ‘¢
ğ‘–
ğ‘‘
64
,

ğ‘ 
ğ‘Ÿ
ğ‘
_
ğ‘–
ğ‘‘
,

ğ‘¡
ğ‘ 
)

lexicogr
a
ËŠ
fico
(uid64, src_id, ts) lexicogr
a
ËŠ
fico

Sin â€œsortâ€ global caro: se consigue por:

cut-off por fuente (consume en orden natural de llegada),

bucket por asset (hash estable),

fusiÃ³n estable por src_id fijo (S pequeÃ±o).

ARTÃCULO III â€” ReputaciÃ³n DinÃ¡mica de Fuente y PenalizaciÃ³n Anti-CÃ¡rtel
III.1. ReputaciÃ³n continua acotada
ğ‘…
ğ‘ 
(
ğ‘¡
)
âˆˆ
[
0
,
1
]
R
s
	â€‹

(t)âˆˆ[0,1]
ğ‘…
ğ‘ 
(
ğ‘¡
)
=
s
a
t
[
0
,
1
]
(
ğ‘¤
ğ¿
ğœ™
ğ¿
(
ğ¿
ğ‘ 
(
ğ‘¡
)
)
+
ğ‘¤
ğ·
ğœ™
ğ·
(
ğ‘‘
Ë‰
ğ‘ 
(
ğ‘¡
)
)
+
ğ‘¤
ğ‘ˆ
ğœ™
ğ‘ˆ
(
ğ‘ˆ
ğ‘ 
(
ğ‘¡
)
)
)
R
s
	â€‹

(t)=sat
[0,1]
	â€‹

(w
L
	â€‹

Ï•
L
	â€‹

(L
s
	â€‹

(t))+w
D
	â€‹

Ï•
D
	â€‹

(
d
Ë‰
s
	â€‹

(t))+w
U
	â€‹

Ï•
U
	â€‹

(U
s
	â€‹

(t)))

donde
ğœ™
\*
Ï•
\*
	â€‹

 son normalizaciones robustas (monÃ³tonas, saturadas).

Ejemplo (robusto, sin ramas):

ğœ™
ğ¿
(
ğ¿
)
=
s
a
t
[
0
,
1
]
(
ğ¿
max
â¡
âˆ’
ğ¿
ğ¿
max
â¡
âˆ’
ğ¿
min
â¡
+
ğœ€
)
Ï•
L
	â€‹

(L)=sat
[0,1]
	â€‹

(
L
max
	â€‹

âˆ’L
min
	â€‹

+Îµ
L
max
	â€‹

âˆ’L
	â€‹

)
ğœ™
ğ‘ˆ
(
ğ‘ˆ
)
=
s
a
t
[
0
,
1
]
(
ğ‘ˆ
âˆ’
ğ‘ˆ
min
â¡
ğ‘ˆ
max
â¡
âˆ’
ğ‘ˆ
min
â¡
+
ğœ€
)
Ï•
U
	â€‹

(U)=sat
[0,1]
	â€‹

(
U
max
	â€‹

âˆ’U
min
	â€‹

+Îµ
Uâˆ’U
min
	â€‹

	â€‹

)
ğœ™
ğ·
(
ğ‘‘
)
=
s
a
t
[
0
,
1
]
(
ğ‘‘
ğ‘‘
r
e
f
+
ğœ€
)
Ï•
D
	â€‹

(d)=sat
[0,1]
	â€‹

(
d
ref
	â€‹

+Îµ
d
	â€‹

)
III.2. PenalizaciÃ³n anti-cÃ¡rtel por correlaciÃ³n
Î 
ğ‘ 
(
ğ‘¡
)
Î 
s
	â€‹

(t)

Se penalizan fuentes que se mueven â€œen bloqueâ€ de forma sospechosamente correlacionada en innovaciÃ³n:

Î 
ğ‘ 
(
ğ‘¡
)
=
âˆ‘
ğ‘¢
â‰ 
ğ‘ 
max
â¡
(
0
,
ğœŒ
ğ‘ 
,
ğ‘¢
(
ğ‘¡
)
âˆ’
ğœŒ
0
)
2
Î 
s
	â€‹

(t)=
u
î€ 
=s
âˆ‘
	â€‹

max(0,Ï
s,u
	â€‹

(t)âˆ’Ï
0
	â€‹

)
2

donde
ğœŒ
ğ‘ 
,
ğ‘¢
Ï
s,u
	â€‹

 se estima sobre una muestra de innovaciones estandarizadas (Art. IV) en una ventana deslizante.

III.3. Logit reputacional corregido (peso pre-Kalman)
ğœ’
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
log
â¡
(
ğœ€
+
ğ‘…
ğ‘ 
(
ğ‘¡
)
)
âˆ’
ğœ†
ğ‘
ğ‘œ
ğ‘Ÿ
ğ‘Ÿ
Î 
ğ‘ 
(
ğ‘¡
)
âˆ’
ğœ†
ğ‘ 
ğ‘¡
ğ‘
ğ‘™
ğ‘’
1
[
stale
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
]
Ï‡
i,s
	â€‹

(t)=log(Îµ+R
s
	â€‹

(t))âˆ’Î»
corr
	â€‹

Î 
s
	â€‹

(t)âˆ’Î»
stale
	â€‹

1[stale
i,s
	â€‹

(t)]

y su peso base:

ğ‘¤
ğ‘–
,
ğ‘ 
(
0
)
(
ğ‘¡
)
=
exp
â¡
(
ğœ’
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
)
w
i,s
(0)
	â€‹

(t)=exp(Ï‡
i,s
	â€‹

(t))

ImplementaciÃ³n prÃ¡ctica: exp2 o LUT.

ARTÃCULO IV â€” Consenso DinÃ¡mico: Kalman Adaptativo como Atractor de Verdad
IV.1. Estado del OrÃ¡culo por activo (modelo mÃ­nimo 2D)

Para cada activo
ğ‘–
i:

ğ‘¥
ğ‘–
(
ğ‘¡
)
=
[
ğ‘
ğ‘–
ğ‘‡
(
ğ‘¡
)


ğ‘
Ë™
ğ‘–
ğ‘‡
(
ğ‘¡
)
]
,
ğ‘ƒ
ğ‘–
(
ğ‘¡
)
âˆˆ
ğ‘…
2
Ã—
2
x
i
	â€‹

(t)=[
p
i
T
	â€‹

(t)
p
Ë™
	â€‹

i
T
	â€‹

(t)
	â€‹

],P
i
	â€‹

(t)âˆˆR
2Ã—2

Modelo de transiciÃ³n (constante velocidad):

ğ‘¥
ğ‘–
âˆ’
(
ğ‘¡
)
=
ğ¹
(
Î”
ğ‘¡
)
ğ‘¥
ğ‘–
(
ğ‘¡
âˆ’
Î”
ğ‘¡
)
,
ğ¹
=
[
1

Î”
ğ‘¡


0

1
]
x
i
âˆ’
	â€‹

(t)=F(Î”t)x
i
	â€‹

(tâˆ’Î”t),F=[
1
0
	â€‹

Î”t
1
	â€‹

]
ğ‘ƒ
ğ‘–
âˆ’
(
ğ‘¡
)
=
ğ¹
ğ‘ƒ
ğ‘–
(
ğ‘¡
âˆ’
Î”
ğ‘¡
)
ğ¹
âŠ¤
+
ğ‘„
ğ‘–
(
ğ‘¡
)
P
i
âˆ’
	â€‹

(t)=FP
i
	â€‹

(tâˆ’Î”t)F
âŠ¤
+Q
i
	â€‹

(t)
IV.2. MediciÃ³n por fuente (precio observado)

MediciÃ³n escalar:

ğ‘§
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
,
ğ»
=
[
1

0
]
z
i,s
	â€‹

(t)=p
i,s
	â€‹

(t),H=[
1
	â€‹

0
	â€‹

]

InnovaciÃ³n:

ğ‘¦
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘§
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ’
ğ»
ğ‘¥
ğ‘–
âˆ’
(
ğ‘¡
)
y
i,s
	â€‹

(t)=z
i,s
	â€‹

(t)âˆ’Hx
i
âˆ’
	â€‹

(t)

Varianza de innovaciÃ³n:

ğ‘†
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ»
ğ‘ƒ
ğ‘–
âˆ’
(
ğ‘¡
)
ğ»
âŠ¤
+
ğ‘…
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
S
i,s
	â€‹

(t)=HP
i
âˆ’
	â€‹

(t)H
âŠ¤
+R
i,s
	â€‹

(t)

Ganancia de Kalman:

ğ¾
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘ƒ
ğ‘–
âˆ’
(
ğ‘¡
)
ğ»
âŠ¤
ğ‘†
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ’
1
K
i,s
	â€‹

(t)=P
i
âˆ’
	â€‹

(t)H
âŠ¤
S
i,s
	â€‹

(t)
âˆ’1

ActualizaciÃ³n:

ğ‘¥
ğ‘–
(
ğ‘¡
)
=
ğ‘¥
ğ‘–
âˆ’
(
ğ‘¡
)
+
ğ¾
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
ğ‘¦
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
x
i
	â€‹

(t)=x
i
âˆ’
	â€‹

(t)+K
i,s
	â€‹

(t)y
i,s
	â€‹

(t)
ğ‘ƒ
ğ‘–
(
ğ‘¡
)
=
(
ğ¼
âˆ’
ğ¾
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
ğ»
)
ğ‘ƒ
ğ‘–
âˆ’
(
ğ‘¡
)
P
i
	â€‹

(t)=(Iâˆ’K
i,s
	â€‹

(t)H)P
i
âˆ’
	â€‹

(t)
IV.3. AdaptaciÃ³n de
ğ‘„
ğ‘–
(
ğ‘¡
)
Q
i
	â€‹

(t) y
ğ‘…
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
R
i,s
	â€‹

(t) (ley de estabilidad)

Ruido de proceso crece con volatilidad/estrÃ©s:

ğ‘„
ğ‘–
(
ğ‘¡
)
=
ğ‘
0
â‹…
(
1
+
ğœ‚
Î£
Î£
ğ‘–
(
ğ‘¡
)
)
â‹…
[
Î”
ğ‘¡
2

Î”
ğ‘¡


Î”
ğ‘¡

1
]
Q
i
	â€‹

(t)=q
0
	â€‹

â‹…(1+Î·
Î£
	â€‹

Î£
i
	â€‹

(t))â‹…[
Î”t
2
Î”t
	â€‹

Î”t
1
	â€‹

]

Ruido de mediciÃ³n cae con reputaciÃ³n y sube con latencia/stale:

ğ‘…
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘Ÿ
0
â‹…
(
1
+
ğœ‚
ğ¿
ğ¿
~
ğ‘ 
(
ğ‘¡
)
)
â‹…
(
1
+
ğœ‚
ğ‘ 
ğ‘¡
1
[
stale
]
)
â‹…
1
ğœ€
+
ğ‘…
ğ‘ 
(
ğ‘¡
)
R
i,s
	â€‹

(t)=r
0
	â€‹

â‹…(1+Î·
L
	â€‹

L
~
s
	â€‹

(t))â‹…(1+Î·
st
	â€‹

1[stale])â‹…
Îµ+R
s
	â€‹

(t)
1
	â€‹


Regla soberana:
ğ‘…
ğ‘–
,
ğ‘ 
R
i,s
	â€‹

 siempre acotado:

ğ‘…
ğ‘š
ğ‘–
ğ‘›
â‰¤
ğ‘…
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
â‰¤
ğ‘…
ğ‘š
ğ‘
ğ‘¥
R
min
	â€‹

â‰¤R
i,s
	â€‹

(t)â‰¤R
max
	â€‹


para evitar explosiones numÃ©ricas.

ARTÃCULO V â€” Pesos DinÃ¡micos y Operador de Consenso Determinista Multi-Fuente
V.1. InnovaciÃ³n estandarizada y peso final

Definimos la innovaciÃ³n estandarizada:

ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘¦
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
ğ‘†
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
+
ğœ€
Î½
i,s
	â€‹

(t)=
S
i,s
	â€‹

(t)+Îµ
	â€‹

y
i,s
	â€‹

(t)
	â€‹


Peso final:

ğ‘¤
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘¤
ğ‘–
,
ğ‘ 
(
0
)
(
ğ‘¡
)
â‹…
1
ğ‘†
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
+
ğœ€
w
i,s
	â€‹

(t)=w
i,s
(0)
	â€‹

(t)â‹…
S
i,s
	â€‹

(t)+Îµ
1
	â€‹


NormalizaciÃ³n:

ğ‘¤
~
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘¤
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ‘
ğ‘¢
=
1
ğ‘†
ğ‘¤
ğ‘–
,
ğ‘¢
(
ğ‘¡
)
+
ğœ€
w
~
i,s
	â€‹

(t)=
âˆ‘
u=1
S
	â€‹

w
i,u
	â€‹

(t)+Îµ
w
i,s
	â€‹

(t)
	â€‹

V.2. ActualizaciÃ³n determinista â€œsecuencial fijaâ€

En vez de fusionar con orden variable, se impone orden fijo por src_id:

para
ğ‘ 
=
0..
ğ‘†
âˆ’
1
:
si hay obs v
a
ËŠ
lida, aplicar update
para s=0..Sâˆ’1:si hay obs v
a
ËŠ
lida, aplicar update

La fusiÃ³n secuencial en orden fijo garantiza:

misma secuencia de eventos â‡’ mismo estado final (reproducibilidad).

V.3. Regla de â€œcorteâ€ y stale

Se define stale:

stale
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
1
[
ğœ
c
u
t
(
ğ‘¡
)
âˆ’
ğœ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
>
Î”
ğœ
max
â¡
]
stale
i,s
	â€‹

(t)=1[Ï„
cut
	â€‹

(t)âˆ’Ï„
i,s
	â€‹

(t)>Î”Ï„
max
	â€‹

]

Si stale, entonces:

su peso cae (por
ğœ†
ğ‘ 
ğ‘¡
ğ‘
ğ‘™
ğ‘’
Î»
stale
	â€‹

) y/o

entra en cuarentena soft (Art. VI).

ARTÃCULO VI â€” DetecciÃ³n de AnomalÃ­as y Cuarentena Determinista
VI.1. MÃ©trica de innovaciÃ³n estandarizada (gatillo)

Repetimos:

ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
ğ‘§
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ’
ğ»
ğ‘¥
ğ‘–
âˆ’
(
ğ‘¡
)
ğ»
ğ‘ƒ
ğ‘–
âˆ’
(
ğ‘¡
)
ğ»
âŠ¤
+
ğ‘…
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
+
ğœ€
Î½
i,s
	â€‹

(t)=
HP
i
âˆ’
	â€‹

(t)H
âŠ¤
+R
i,s
	â€‹

(t)+Îµ
	â€‹

z
i,s
	â€‹

(t)âˆ’Hx
i
âˆ’
	â€‹

(t)
	â€‹

VI.2. Cuarentena determinista por umbral + temporizador

Si:

âˆ£
ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ£
>
ğœ
q
u
a
r
âˆ£Î½
i,s
	â€‹

(t)âˆ£>Ïƒ
quar
	â€‹


entonces la fuente
ğ‘ 
s para el activo
ğ‘–
i entra en cuarentena por
ğ‘‡
ğ‘„
T
Q
	â€‹

 ticks:

ğ‘
ğ‘š
ğ‘
ğ‘ 
ğ‘˜
ğ‘–
â†
ğ‘
ğ‘š
ğ‘
ğ‘ 
ğ‘˜
ğ‘–

âˆ¨

(
1
â‰ª
ğ‘ 
)
qmask
i
	â€‹

â†qmask
i
	â€‹

 âˆ¨ (1â‰ªs)
ğ‘
ğ‘¢
ğ‘›
ğ‘¡
ğ‘–
ğ‘™
ğ‘–
,
ğ‘ 
â†
ğ‘¡
+
ğ‘‡
ğ‘„
quntil
i,s
	â€‹

â†t+T
Q
	â€‹


Durante cuarentena:

ğ‘¤
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
0
w
i,s
	â€‹

(t)=0

y esto es irreversible dentro del tick.

VI.3. Disputa vs Flash (clasificaciÃ³n de evento adverso)

Definimos dos clases:

DISPUTA: divergencia moderada persistente:

âˆ£
ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ£
>
ğœ
d
i
s
p
durante
ğœ
min
â¡
âˆ£Î½
i,s
	â€‹

(t)âˆ£>Ïƒ
disp
	â€‹

duranteÏ„
min
	â€‹


FLASH: divergencia extrema instantÃ¡nea:

âˆ£
ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ£
>
ğœ
f
l
a
s
h
âˆ£Î½
i,s
	â€‹

(t)âˆ£>Ïƒ
flash
	â€‹


La FLASH activa shock fuerte y flags, y puede gatillar Ley IX.

ARTÃCULO VII â€” Consenso de Volumen y DetecciÃ³n de Spoofing (Volumen falso)
VII.1. Volumen verdadero
ğ‘‰
ğ‘–
ğ‘‡
(
ğ‘¡
)
V
i
T
	â€‹

(t) (robusto + filtrado por flags)

Sea
ğ‘£
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
v
i,s
	â€‹

(t) volumen observado. Definimos un estimador robusto:

ğ‘‰
ğ‘–
ğ‘‡
(
ğ‘¡
)
=
âˆ‘
ğ‘ 
ğ‘¤
~
ğ‘–
,
ğ‘ 
(
ğ‘‰
)
(
ğ‘¡
)
â‹…
s
a
t
(
ğ‘£
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
)
V
i
T
	â€‹

(t)=
s
âˆ‘
	â€‹

w
~
i,s
(V)
	â€‹

(t)â‹…sat(v
i,s
	â€‹

(t))

con pesos:

ğ‘¤
~
ğ‘–
,
ğ‘ 
(
ğ‘‰
)
âˆ
ğ‘…
ğ‘ 
(
ğ‘¡
)
â‹…
(
1
âˆ’
1
[
quar
]
)
â‹…
(
1
âˆ’
1
[
flash
]
)
w
~
i,s
(V)
	â€‹

âˆR
s
	â€‹

(t)â‹…(1âˆ’1[quar])â‹…(1âˆ’1[flash])

y saturaciÃ³n:

s
a
t
(
ğ‘£
)
=
min
â¡
(
ğ‘£
,
ğ‘£
max
â¡
)
sat(v)=min(v,v
max
	â€‹

)
VII.2. Detector branchless de volumen falso (spoofing)

Se define una seÃ±al de liquidez/volumen
ğ¿
ğ‘–
(
ğ‘¡
)
L
i
	â€‹

(t) (ej.
ğ‘‰
ğ‘–
ğ‘‡
V
i
T
	â€‹

 o depth filtrada). Detector:

1
[
F
A
K
E
ğ‘–
]
=
1
[
ğ¿
ğ‘–
(
ğ‘¡
)
âˆ’
ğœ‡
ğ¿
,
ğ‘–
(
ğ‘¡
)
>
ğœ‚
f
a
k
e
â‹…
(
ğœ
ğ¿
,
ğ‘–
(
ğ‘¡
)
+
ğœ€
)
]
1[FAKE
i
	â€‹

]=1[L
i
	â€‹

(t)âˆ’Î¼
L,i
	â€‹

(t)>Î·
fake
	â€‹

â‹…(Ïƒ
L,i
	â€‹

(t)+Îµ)]

donde
ğœ‡
ğ¿
,
ğ‘–
,
ğœ
ğ¿
,
ğ‘–
Î¼
L,i
	â€‹

,Ïƒ
L,i
	â€‹

 son EWMA:

ğœ‡
(
ğ‘¡
)
=
ğ›¼
ğœ‡
(
ğ‘¡
âˆ’
Î”
ğ‘¡
)
+
(
1
âˆ’
ğ›¼
)
ğ¿
(
ğ‘¡
)
Î¼(t)=Î±Î¼(tâˆ’Î”t)+(1âˆ’Î±)L(t)
ğœ
2
(
ğ‘¡
)
=
ğ›¼
ğœ
2
(
ğ‘¡
âˆ’
Î”
ğ‘¡
)
+
(
1
âˆ’
ğ›¼
)
(
ğ¿
(
ğ‘¡
)
âˆ’
ğœ‡
(
ğ‘¡
)
)
2
Ïƒ
2
(t)=Î±Ïƒ
2
(tâˆ’Î”t)+(1âˆ’Î±)(L(t)âˆ’Î¼(t))
2
VII.3. PenalizaciÃ³n adversarial acumulada
ğ´
ğ‘–
(
ğ‘¡
)
A
i
	â€‹

(t)
ğ´
ğ‘–
(
ğ‘¡
)
=
s
a
t
[
0
,
ğ´
max
â¡
]
(
ğ´
ğ‘–
(
ğ‘¡
âˆ’
1
)
+
1
[
F
A
K
E
ğ‘–
]
+
1
[
ğ¹
D
I
S
P
U
T
E
]
+
1
[
ğ¹
F
L
A
S
H
]
)
A
i
	â€‹

(t)=sat
[0,A
max
	â€‹

]
	â€‹

(A
i
	â€‹

(tâˆ’1)+1[FAKE
i
	â€‹

]+1[F
DISPUTE
	â€‹

]+1[F
FLASH
	â€‹

])

Esto se consume por Ley IX como freno/energÃ­a adversarial.

ARTÃCULO VIII â€” ProyecciÃ³n al Bus: cÃ³mo el OrÃ¡culo modula
ğ‘Ÿ
ğ‘–
ğ‘ 
ğ‘˜
/
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
risk/shock y Meta32
VIII.1. Shock como funciÃ³n de discrepancia + flash

El shock se define como observable visual/dinÃ¡mico:

ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
)
â†
s
a
t
(
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
âˆ’
Î”
ğ‘¡
)
+
ğ‘˜
ğœˆ
â‹…
max
â¡
ğ‘ 
âˆ£
ğœˆ
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
âˆ£
)
shock
i
	â€‹

(t)â†sat(shock
i
	â€‹

(tâˆ’Î”t)+k
Î½
	â€‹

â‹…
s
max
	â€‹

âˆ£Î½
i,s
	â€‹

(t)âˆ£)

En caso FLASH:

ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
)
â†
max
â¡
(
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘–
(
ğ‘¡
)
,
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
f
l
a
s
h
)
shock
i
	â€‹

(t)â†max(shock
i
	â€‹

(t),shock
flash
	â€‹

)
VIII.2. Risk como integral de incertidumbre + adversarial
ğ‘Ÿ
ğ‘–
ğ‘ 
ğ‘˜
ğ‘–
(
ğ‘¡
)
â†
s
a
t
(
ğ‘˜
ğ‘ƒ
â‹…
ğ‘ƒ
ğ‘–
,
00
(
ğ‘¡
)
+
ğ‘˜
ğ´
â‹…
ğ´
ğ‘–
(
ğ‘¡
)
)
risk
i
	â€‹

(t)â†sat(k
P
	â€‹

â‹…P
i,00
	â€‹

(t)+k
A
	â€‹

â‹…A
i
	â€‹

(t))

donde
ğ‘ƒ
ğ‘–
,
00
P
i,00
	â€‹

 es varianza del precio consensuado.

VIII.3. Flags de Meta32 (integridad/disputa/flash/quarantine/vol_fake)

La LEY VI define flags branchless en Meta32 (ver Art. XI) y exige:

si cuarentena activa â‡’ F_QUARANTINE=1

si disputa activa â‡’ F_DISPUTE=1

si flash â‡’ F_FLASH=1

si volumen falso â‡’ F_VOL_FAKE=1

ARTÃCULO IX â€” IntegraciÃ³n Inter-Ley (Conexiones obligatorias)
IX.1. Con Ley IX (Horizonte)

El OrÃ¡culo entrega:

ğ‘‰
ğ‘–
ğ‘‡
(
ğ‘¡
)
V
i
T
	â€‹

(t) (volumen verdadero)

ğ´
ğ‘–
(
ğ‘¡
)
A
i
	â€‹

(t) (adversarial)

flags de integridad

para el cÃ¡lculo de energÃ­a informacional
ğ¸
ğ‘–
(
ğ‘¡
)
E
i
	â€‹

(t) y la regla de horizonte.

IX.2. Con Ley IV (DinÃ¡mica)

Flags y shocks ajustan:

fricciÃ³n
ğ›¾
ğ‘–
Î³
i
	â€‹

 (si disputa/flash aumenta)

barreras
ğ‘
ğ‘˜
(
ğ‘¡
)
b
k
	â€‹

(t) (si flash endurece o contrae segÃºn rÃ©gimen)

cooldowns (si cuarentena, congela migraciÃ³n)

IX.3. Con Ley V (Persistencia)

Si F_FLASH o F_DISPUTE:

el activo puede entrar en SIGMA/OMEGA mÃ¡s rÃ¡pido o dejar cicatriz mÃ¡s persistente (vÃ­a shock y TSD).

ARTÃCULO X â€” ImplementaciÃ³n de Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly

A continuaciÃ³n, pseudocÃ³digo â€œejecutableâ€ (estilo Ley IX): ingestiÃ³n, reputaciÃ³n, Kalman, cuarentena, spoofing y write-back.

X.1. Ring buffer SPSC (por fuente)
template<typename T, uint32_t CAP>
struct SPSC_Ring {
  alignas(64) std::atomic<uint32_t> head{0}; // producer writes
  alignas(64) std::atomic<uint32_t> tail{0}; // consumer writes
  alignas(64) T buf[CAP];

  bool push(const T& v){ // producer only
    uint32_t h = head.load(std::memory_order_relaxed);
    uint32_t t = tail.load(std::memory_order_acquire);
    uint32_t nh = (h + 1u) % CAP;
    if(nh == t) return false; // full (drop policy allowed)
    buf[h] = v;
    head.store(nh, std::memory_order_release);
    return true;
  }

  bool pop(T& out){ // consumer only
    uint32_t t = tail.load(std::memory_order_relaxed);
    uint32_t h = head.load(std::memory_order_acquire);
    if(t == h) return false;
    out = buf[t];
    tail.store((t + 1u) % CAP, std::memory_order_release);
    return true;
  }
};

X.2. Estado del OrÃ¡culo en Atlas SoA (Ley VII)
struct OracleSoA {
  float* pT;     // N
  float* pDot;   // N
  float* P00;    // N
  float* P01;    // N
  float* P11;    // N
  float* muL;    // N (EWMA liquidity)
  float* sigL;   // N (EWMA std)
  uint16_t* quarMask;      // N (S<=16)
  uint32_t* quarUntil;     // N*S (opcional si S pequeÃ±o; si no, hash compacta)
  uint8_t*  dispCount;     // N (contador disputa)
  uint8_t*  advA;          // N (A_i)
};

X.3. ReputaciÃ³n global por fuente + penalizaciÃ³n anti-cÃ¡rtel
struct SourceStats {
  float L;     // latency
  float U;     // uptime
  float dbar;  // depth mean
  float R;     // reputation [0,1]
  float Pi;    // cartel penalty
};

inline float sat01(float x){ return fminf(1.f, fmaxf(0.f, x)); }

void update_source_reputation(SourceStats& S){
  float phiL = sat01((Lmax - S.L) / (Lmax - Lmin + 1e-6f));
  float phiU = sat01((S.U - Umin) / (Umax - Umin + 1e-6f));
  float phiD = sat01(S.dbar / (dref + 1e-6f));
  S.R = sat01(wL*phiL + wU*phiU + wD*phiD);
  // S.Pi se actualiza con correlaciones (muestra de innovaciones)
  // R_corr = log(eps+R) - lamCorr*Pi
}

X.4. Kalman 2x2 (price + drift), escalar H=[1,0]
struct Kalman2 {
  float pT, pDot;
  float P00, P01, P11;
};

inline void kalman_predict(Kalman2& K, float dt, float Qi){
  // x^- = F x
  K.pT  = K.pT + dt*K.pDot;

  // P^- = F P F^T + Q
  float P00 = K.P00 + 2.f*dt*K.P01 + dt*dt*K.P11 + Qi*dt*dt;
  float P01 = K.P01 + dt*K.P11 + Qi*dt;
  float P11 = K.P11 + Qi;

  K.P00 = P00; K.P01 = P01; K.P11 = P11;
}

inline float compute_Ris(float Rs, float Ls, uint32_t stale){
  float r = r0 * (1.f + etaL*Ls) * (1.f + etaSt*float(stale)) / (1e-6f + Rs);
  return fminf(Rmax, fmaxf(Rmin, r));
}

inline float kalman_update(Kalman2& K, float z, float R){
  // y = z - pT
  float y = z - K.pT;
  float S = K.P00 + R + 1e-6f;
  float invS = 1.f / S;

  // K = [P00; P01] / S
  float K0 = K.P00 * invS;
  float K1 = K.P01 * invS;

  // x = x^- + K y
  K.pT  += K0 * y;
  K.pDot+= K1 * y;

  // P = (I - K H) P => for scalar H=[1,0]
  float P00n = (1.f - K0) * K.P00;
  float P01n = (1.f - K0) * K.P01;
  float P11n = K.P11 - K1 * K.P01;

  K.P00 = fmaxf(P00n, 1e-9f);
  K.P01 = P01n;
  K.P11 = fmaxf(P11n, 1e-9f);

  // standardized innovation nu
  return y * rsqrtf(S); // nu = y / sqrt(S)
}

X.5. Cuarentena determinista (bitmask) + disputa/flash
inline uint32_t bit(uint32_t s){ return 1u << s; }

inline uint32_t set_if(uint32_t x, uint32_t m, uint32_t cond){
  // cond in {0,1} -> mask 0x0 or 0xFFFFFFFF
  uint32_t cm = 0u - (cond & 1u);
  return (x & ~m) | (m & cm);
}

void quarantine_logic(uint16_t& qmask, uint32_t src, float nu, uint8_t& dispCnt){
  float anu = fabsf(nu);
  uint32_t isFlash = (anu > sigmaFlash);
  uint32_t isDisp  = (anu > sigmaDisp);

  // accumulate dispute count (saturating)
  dispCnt = uint8_t( (dispCnt + uint8_t(isDisp)) & 0xFFu );

  // quarantine if above sigmaQuar or flash
  uint32_t doQuar = (anu > sigmaQuar) | isFlash;
  qmask = uint16_t(qmask | uint16_t(bit(src) & (0u - doQuar)));
}

X.6. Volumen verdadero + spoofing detector (EWMA)
inline void ewma_update(float& mu, float& sig, float x){
  float d = x - mu;
  mu = alpha*mu + (1.f-alpha)*x;
  sig = alpha*sig + (1.f-alpha)*(d*d);
}

inline uint32_t detect_fake(float L, float mu, float sig){
  return (L - mu) > (etaFake * (sqrtf(sig) + 1e-6f));
}

X.7. Write-back a Vertex28: risk/shock + Meta32 flags (sin romper stride)
// Vertex28 assumed layout includes: pos.xy, rs.xy (risk/shock), meta32, hid32 ...
struct Vertex28 {
  float x, y, z;       // 12 B
  float risk;          // 4 B  -> 16
  float shock;         // 4 B  -> 20
  uint32_t meta32;     // 4 B  -> 24
  uint16_t idx16;      // 2 B  -> 26
  uint16_t pad16;      // 2 B  -> 28
};
static_assert(sizeof(Vertex28) == 28, "Vertex28 stride must be 28 bytes");void oracle_apply_to_vertex(uint32_t idx, Vertex28& v, const Kalman2& K,
                            uint8_t A, uint32_t flagsOracle){
  // risk = sat(kP*P00 + kA*A)
  float risk = sat01(kP * K.P00 + kA * float(A));
  // shock decays elsewhere; here we only add increments already computed
  float shock = v.shock;

  v.risk  = risk;
  v.shock = shock;

  // set oracle flags in Meta32 FLAGS8 high bits (see Art. XI)
  uint32_t meta = v.meta;
  meta = (meta & ~MASK_ORACLE_FLAGS8) | (flagsOracle & MASK_ORACLE_FLAGS8);
  v.meta = meta;
}

ARTÃCULO XI â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 soberano para el OrÃ¡culo)

Meta32 V.1 (compatible con Ley V):

STATE (2b)

TSD_LOG (8b)

CLUSTER_CRIT (6b)

COOLDOWN_T (8b)

FLAGS8 (8b)

La LEY VI reclama soberanÃ­a sobre FLAGS8 bits 4..7 (integridad de fuente).
Los bits 0..3 quedan para ciclo de vida / freeze / lockdown (Ley V/VI).

XI.1. FLAGS8 (asignaciÃ³n unificada)
Bit	Nombre	Hex	SemÃ¡ntica
0	F_KILLED	0x01	(Ley V) ALFAâ†’SIGMA
1	F_FORCE_OMEGA	0x02	(Ley V) forzar OMEGA
2	F_TSD_FREEZE	0x04	congelar decaimiento (cuarentena dura / auditorÃ­a)
3	F_LOCKDOWN	0x08	(Ley VI) no aceptar migraciÃ³n/impactos agresivos
4	F_DISPUTE	0x10	disputa de fuentes activa
5	F_QUARANTINE	0x20	cuarentena activa (peso=0)
6	F_FLASH	0x40	flash-crash / anomalÃ­a extrema
7	F_VOL_FAKE	0x80	volumen falso detectado
XI.2. MÃ¡scaras compuestas
static constexpr uint32_t MASK_FLAGS8        = 0x000000FFu;
static constexpr uint32_t MASK_ORACLE_FLAGS8 = 0x000000F0u; // bits 4..7

static constexpr uint32_t F_DISPUTE     = 0x10u;
static constexpr uint32_t F_QUARANTINE  = 0x20u;
static constexpr uint32_t F_FLASH       = 0x40u;
static constexpr uint32_t F_VOL_FAKE    = 0x80u;

static constexpr uint32_t MASK_INTEGRITY = F_DISPUTE | F_QUARANTINE | F_FLASH | F_VOL_FAKE;

XI.3. Reglas branchless de set/clear
inline uint32_t set_flag(uint32_t meta, uint32_t f){
  return meta | f; // branchless
}
inline uint32_t clr_flag(uint32_t meta, uint32_t f){
  return meta & ~f;
}
inline uint32_t set_if_flag(uint32_t meta, uint32_t f, uint32_t cond){
  uint32_t m = 0u - (cond & 1u);
  return (meta & ~f) | (f & m);
}

ARTÃCULO XII â€” Auditabilidad y Trazabilidad (Integridad de Fuente como cadena verificable)
XII.1. Hash de tick (commit ligero, sin I/O)

Para cada tick, el OrÃ¡culo construye un digest:

ğ»
(
ğ‘¡
)
=
x
x
h
a
s
h
64
(
ğ»
(
ğ‘¡
âˆ’
1
)

âˆ¥

s
u
m
m
a
r
y
(
ğ‘‚
ğµ
ğ‘†
(
ğ‘¡
)
)

âˆ¥

s
u
m
m
a
r
y
(
ğ¹
ğ¿
ğ´
ğº
ğ‘†
(
ğ‘¡
)
)
)
H(t)=xxhash64(H(tâˆ’1) âˆ¥ summary(OBS(t)) âˆ¥ summary(FLAGS(t)))

No bloquea: se mantiene en memoria.

Permite reproducir y probar divergencias.

XII.2. Prueba de determinismo

Dado el mismo stream de eventos (mismo orden por fuente y mismo cut-off), se exige:

ğ»
(
ğ‘¡
)

id
e
ËŠ
ntico

âˆ€
ğ‘¡
H(t) id
e
ËŠ
ntico âˆ€t

Cualquier desviaciÃ³n implica bug (data race, lectura no atÃ³mica, o dependencia de reloj no controlada).

ARTÃCULO XIII â€” Modelo de Coste y Presupuesto (ciclos y ms)

Sea
ğ¾
(
ğ‘¡
)
K(t) el nÃºmero de activos â€œtocadosâ€ por nuevas observaciones en el tick (normalmente
ğ¾
â‰ª
ğ‘
Kâ‰ªN).
El OrÃ¡culo no ejecuta Kalman para N completo si no hay datos; aplica â€œevent-driven updatesâ€.

XIII.1. Coste de procesamiento de feeds

Por evento:

pop ring SPSC: ~10â€“25 ciclos (cache-hit)

validaciÃ³n mÃ­nima + bucket: ~20â€“60 ciclos

acumulaciÃ³n en lista por asset: ~30â€“80 ciclos

XIII.2. Coste de Kalman 2x2 por observaciÃ³n

AproximaciÃ³n:

predict: ~15â€“25 FLOPs

update: ~30â€“45 FLOPs + 1 rsqrt (aprox)

total: ~80â€“140 ciclos (WASM SIMD-friendly, segÃºn CPU)

XIII.3. Presupuesto fijo constitucional

Definimos:

ğ¾
O
R
A
C
L
E
_
F
E
E
D
S
K
ORACLE_FEEDS
	â€‹

: ingesta + snapshot

ğ¾
O
R
A
C
L
E
_
K
A
L
M
A
N
K
ORACLE_KALMAN
	â€‹

: updates por tick

ğ¾
O
R
A
C
L
E
_
A
N
O
M
K
ORACLE_ANOM
	â€‹

: detecciÃ³n + cuarentena + flags

Con lÃ­mites:

ğ¾
O
R
A
C
L
E
_
F
E
E
D
S
â‰¤
0.60

m
s
K
ORACLE_FEEDS
	â€‹

â‰¤0.60ms
ğ¾
O
R
A
C
L
E
_
K
A
L
M
A
N
â‰¤
1.00

m
s
K
ORACLE_KALMAN
	â€‹

â‰¤1.00ms
ğ¾
O
R
A
C
L
E
_
A
N
O
M
â‰¤
0.40

m
s
K
ORACLE_ANOM
	â€‹

â‰¤0.40ms
ğ¾
O
R
A
C
L
E
=
âˆ‘
â‰¤
2.00

m
s
K
ORACLE
	â€‹

=âˆ‘â‰¤2.00ms

Mantenimiento bajo carga:

si
ğ¾
(
ğ‘¡
)
K(t) crece, activar cap de updates por tick
ğ¾
max
â¡
K
max
	â€‹

 (p.ej. 50k) y diferir resto (sin romper determinismo: cola estable por UID64).

si S grande, limitar a Top-
ğ‘†
â€²
S
â€²
 por reputaciÃ³n.

usar LUT para exp/log/rsqrt en WASM si el target lo requiere.

ARTÃCULO XIV â€” Invariantes del OrÃ¡culo (ConstituciÃ³n de verdad y seguridad)

No bloqueo: ninguna ruta de red/parseo puede frenar al tick.

Corte temporal soberano: un evento fuera de corte no existe en ese tick.

Cuarentena determinista: si se activa, su peso es cero hasta expiraciÃ³n; no hay â€œnegociaciÃ³nâ€.

Consistencia > precisiÃ³n externa: el bus no se reescribe por arrepentimiento dentro del tick.

Salida mÃ­nima: solo risk/shock + flags Meta32; el resto vive en Atlas SoA.

Estabilidad FP32:
ğ‘…
,
ğ‘„
,
ğ‘ƒ
R,Q,P acotados, sin NaN, sin overflow.

Anti-cÃ¡rtel: correlaciÃ³n excesiva penaliza reputaciÃ³n; no hay secuestro del consenso.

Auditabilidad: digest
ğ»
(
ğ‘¡
)
H(t) reproducible.

AXIOMA FINAL

â€œLa Verdad Ãšnica en TITAN V8 no es un precio real, sino un estado consensuado al que el sistema converge por control dinÃ¡mico, garantizando la integridad de fuente, la cuarentena determinista y la ausencia de bloqueos por I/O.â€

LEY VII â€” SoberanÃ­a del Metadato Binario, UID TopolÃ³gico y Atlas Residente Zero-Copy
(OntologÃ­a sin Strings, ConstrucciÃ³n Bitwise de Identidad y ProyecciÃ³n Determinista al Bus Vertex28)

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” Principios de No-NegociaciÃ³n: Trinidad Binaria y Fin del Nombre
3. ARTÃCULO II â€” UID64 Soberano: Layout Bitwise, ExtracciÃ³n y Invariantes
4. ARTÃCULO III â€” Cuckoo Hashing 2-VÃ­as: FAM16 Cache-Line-First y HuÃ©rfanos
5. ARTÃCULO IV â€” Atlas Residente: AssetRecord 64B y Direccionamiento O(1)
6. ARTÃCULO V â€” DNA32: Layout, BHV como Coeficientes y LUTs Constitucionales
7. ARTÃCULO VI â€” SENT8: PresiÃ³n TermodinÃ¡mica Compacta y ProyecciÃ³n a Shock
8. ARTÃCULO VII â€” Vertex28: La Ãšnica Realidad Exportable (IntegraciÃ³n con Ley III/IV/V)
9. ARTÃCULO VIII â€” Meta32 Soberano: Layout Dual-RÃ©gimen, Masks y Branchless Rules
10. ARTÃCULO IX â€” ConexiÃ³n Inter-Ley: SoberanÃ­a, DinÃ¡mica, OrÃ¡culo, VacÃ­o
11. ARTÃCULO X â€” Identity-Shadowing: MutaciÃ³n Masiva sin Parar el Mundo
12. ARTÃCULO XI â€” Persistencia e Integridad: SerializaciÃ³n y CorrupciÃ³n
13. ARTÃCULO XII â€” ImplementaciÃ³n Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly
14. ARTÃCULO XIII â€” Modelo de Coste y Presupuesto (Ciclos y K-Budgets)
15. ARTÃCULO XIV â€” Axioma Final
16. AXIOMA FINAL

Ãmbito


LEY VII â€” SoberanÃ­a del Metadato Binario, UID TopolÃ³gico y Atlas Residente Zero-Copy


ARTÃCULO I â€” Principios de No-NegociaciÃ³n: Trinidad Binaria y Fin del Nombre

I.1. Dogma OntolÃ³gico

El nombre/ticker es relato externo. TITAN V8 reconoce como existencia computable Ãºnicamente lo direccionable sin ambigÃ¼edad y sin bÃºsqueda textual.

ProposiciÃ³n:
Si un â€œactivoâ€ no puede representarse como ((UID64, DNA32, SENT8)) y proyectarse a Vertex28, no existe para TITAN V8.

I.2. Zero-Copy como ley del silicio

Toda lectura de metadato vital se realiza como:

[
\text{addr} = \text{base} + \text{stride}\cdot \text{slot}
]

sin mapas, sin punteros encadenados, sin alocaciones, sin locks.
El coste estÃ¡ acotado por una o dos cargas de lÃ­nea de cachÃ©.

I.3. Determinismo operativo

Ante dos â€œnarrativasâ€ distintas (feeds, nombres, catÃ¡logos), TITAN decide por:

* UID64 (identidad),
* DNA32 (fenotipo y coeficientes),
* SENT8 (presiÃ³n termodinÃ¡mica),
  no por etiquetas.

---

ARTÃCULO II â€” UID64 Soberano: Layout Bitwise, ExtracciÃ³n y Invariantes

II.1. DefiniciÃ³n formal

[
\textbf{UID64} \in {0,1}^{64}
]
con layout MSBâ†’LSB:

[
\boxed{\textbf{UID64} = [\textbf{HID32}\ |\ \textbf{FAM16}\ |\ \textbf{VER16}]}
]

* HID32: hash estable de identidad (invariante a versiones).
* FAM16: direccionamiento topolÃ³gico dentro del resolvedor (cache-line-first).
* VER16: Ã­ndice fÃ­sico (slot) + versiÃ³n anti-ABA (cuando aplica).

II.2. Funciones de extracciÃ³n (bitwise)

Sea `uid` un `uint64_t`:

[
\begin{aligned}
HID32(uid) &= (uid \gg 32)\ &\ 0xFFFFFFFF \
FAM16(uid) &= (uid \gg 16)\ &\ 0xFFFF \
VER16(uid) &= (uid \gg 0)\ &\ 0xFFFF
\end{aligned}
]

II.3. Invariantes constitucionales

1. HID32 no cambia para un mismo â€œserâ€ a travÃ©s de re-clasificaciones narrativas.
2. VER16 apunta a un slot vÃ¡lido en el Atlas residente (o es rechazado).
3. FAM16 es una prueba de pertenencia: codifica bucket/pÃ¡gina/lado para resoluciÃ³n O(1).

---

ARTÃCULO III â€” Cuckoo Hashing 2-VÃ­as: FAM16 Cache-Line-First y HuÃ©rfanos

III.1. Cuckoo 2-vÃ­as como constituciÃ³n de lookup

La resoluciÃ³n por HID32 se ejecuta con dos cubetas candidatas:

[
b_0 = h_0(HID32) \mod B,\qquad b_1 = h_1(HID32) \mod B
]

y se consulta en dos cargas de 64B (ideal):

[
\text{lookup} = \text{scan}(Bucket[b_0]) \lor \text{scan}(Bucket[b_1])
]

III.2. CodificaciÃ³n de FAM16

[
\boxed{\textbf{FAM16}=[\textbf{PAGE3}\ |\ \textbf{BUCK12}\ |\ \textbf{SIDE1}]}
]

* `PAGE3` (bits 15..13): pÃ¡gina (0..7)
* `BUCK12` (bits 12..1): Ã­ndice de cubeta dentro de pÃ¡gina (0..4095)
* `SIDE1` (bit 0): 0â†’usa (h_0), 1â†’usa (h_1)

Total: (3+12+1=16) bits.

III.3. Bucket64 (64 bytes)

Una cubeta debe ocupar exactamente una lÃ­nea de cachÃ©:

```cpp
// 64 bytes exactos (cache-line aligned)
struct alignas(64) Bucket64 {
  uint32_t hid[8];   // 8 HID32 candidates (32B)
  uint16_t ver[8];   // 8 VER16 slots/versions (16B)
  uint16_t tag[8];   // 8 tags/flags (16B)  => total 64B
};
```

`tag[k]` puede codificar: ocupaciÃ³n, side, checksum corto, etc.

III.4. Lookup SIMD-friendly (dos cubetas, branchless)

Sea `H` el HID buscado. Se carga `hid[0..7]` y se compara en paralelo.

Regla: el resolvedor jamÃ¡s itera listas; escanea un bloque fijo (8 entradas) por cubeta.

III.5. HuÃ©rfanos de Identidad

Si durante inserciÃ³n el algoritmo supera (K_{kick}) desplazamientos:

[
n_{kicks} > K_{kick}\ \Rightarrow\ \textbf{ORPHAN} = TRUE
]

Axioma: un huÃ©rfano no cruza a Vertex28 (no existe para el universo renderizable).
Se purga en ingesta/boot o se envÃ­a a cuarentena offline.

---

ARTÃCULO IV â€” Atlas Residente: AssetRecord 64B y Direccionamiento O(1)

IV.1. Canon: un activo = 1 lÃ­nea de cachÃ©

El Atlas vital se define como un array contiguo de registros de 64 bytes:

```cpp
struct alignas(64) AssetRecord {
  uint64_t uid;      // UID64 (8)
  uint32_t hid;      // HID32 redundante (4)
  uint16_t fam;      // FAM16 (2)
  uint16_t ver;      // VER16 (2)

  uint32_t dna;      // DNA32 (4)
  int8_t   sent;     // SENT8 (1)
  uint8_t  jur;      // cache de JUR4 expandido (1)
  uint16_t pad0;     // (2)

  uint32_t flags;    // flags internos atlas (4)
  uint32_t crc;      // CRC32 opcional (4)

  uint64_t cold_off; // offset a Atlas narrativo (8)
  uint64_t reserved; // (8) futuro / alignment  => total 64B
};
static_assert(sizeof(AssetRecord)==64);
```

Nota constitucional: `cold_off` apunta a datos narrativos (strings, descripciones) fuera del hilo crÃ­tico.

IV.2. Direccionamiento por VER16

[
slot = VER16(uid)
]
y acceso:

[
rec = Atlas[slot]
]

ValidaciÃ³n mÃ­nima obligatoria:

[
rec.uid == uid \ \wedge\ rec.hid == HID32(uid)
]

Si falla: UID invÃ¡lido â†’ rechazo (no se renderiza, no se simula).

IV.3. Anti-ABA (reencarnaciÃ³n)

Si Ley VIII recicla slots, `ver` puede incluir generaciÃ³n:

[
VER16 = [GEN8 | SLOT8]\quad \text{o}\quad [GEN6|SLOT10]
]

y la validaciÃ³n exige:

[
rec.ver == VER16(uid)
]

---

ARTÃCULO V â€” DNA32: Layout, BHV como Coeficientes y LUTs Constitucionales

V.1. Layout inmutable del DNA32

[
\boxed{\textbf{DNA32}=[\textbf{JUR4}\ |\ \textbf{TYPE4}\ |\ \textbf{LIQ4}\ |\ \textbf{BHV20}]}
]

DefiniciÃ³n LSBâ†’MSB (para extracciÃ³n barata):

* Bits 0..19: BHV20
* Bits 20..23: LIQ4
* Bits 24..27: TYPE4
* Bits 28..31: JUR4

ExtracciÃ³n:

[
\begin{aligned}
BHV20(dna) &= dna\ &\ 0x000FFFFF \
LIQ4(dna)  &= (dna \gg 20)\ &\ 0xF \
TYPE4(dna) &= (dna \gg 24)\ &\ 0xF \
JUR4(dna)  &= (dna \gg 28)\ &\ 0xF
\end{aligned}
]

V.2. BHV no describe: activa coeficientes

Sea (b_k \in {0,1}) el bit k-Ã©simo de BHV20.
Se define un vector de coeficientes fÃ­sicos/visuales por LUT:

[
\theta = \theta_0 + \sum_{k=0}^{19} b_k \cdot \Delta\theta_k
]

donde (\theta) puede ser masa, fricciÃ³n, curvatura, brillo, etc.

LUTs constitucionales (ejemplo de familia)

* `LUT_BHV_MASS[20]`
* `LUT_BHV_DRAG[20]`
* `LUT_BHV_CURV[20]`
* `LUT_BHV_VIS[20]`
* `LUT_LIQ2MU[16]` (LIQ4 â†’ movilidad)
* `LUT_TYPE2BASE[16]` (TYPE4 â†’ fenotipo base)
* `LUT_JUR2REG[16]` (JUR4 â†’ rÃ©gimen regulatorio)

V.3. ProyecciÃ³n a parÃ¡metros fÃ­sicos ((\gamma, \kappa^\Omega, m))

DefÃ­nanse saturaciones suaves:

[
sat(x)=\min(1,\max(0,x)),\qquad sat_{sym}(x)=\min(1,\max(-1,x))
]

Masa efectiva

[
m_i = clip\Big(m_0 + \Delta m_{type}[TYPE4] + \sum_{k} b_k\Delta m_k,\ m_{min}, m_{max}\Big)
]

FricciÃ³n efectiva (Stokes)

[
\gamma_i = clip\Big(\gamma_0 + \Delta\gamma_{liq}[LIQ4] + \sum_k b_k\Delta\gamma_k,\ \gamma_{min}, \gamma_{max}\Big)
]

Curvatura inducida por ADN

[
\kappa_i^\Omega = clip\Big(\kappa_0 + \Delta\kappa_{jur}[JUR4] + \sum_k b_k\Delta\kappa_k,\ \kappa_{min}, \kappa_{max}\Big)
]

Regla: todo (\sum b_k\Delta\theta_k) se implementa por LUT + popcount-like accumulation (SIMD-friendly), jamÃ¡s por if-else semÃ¡ntico.

---

ARTÃCULO VI â€” SENT8: PresiÃ³n TermodinÃ¡mica Compacta y ProyecciÃ³n a Shock

VI.1. Dominio y normalizaciÃ³n

[
SENT8 \in [-128,127]\cap\mathbb{Z},\qquad
S_i = clamp\Big(\frac{sent8_i}{127}, -1,1\Big)
]

VI.2. Transporte: difusiÃ³n-disipaciÃ³n discreta

Sea (N(i)) el vecindario top-K (Ley IV). EvoluciÃ³n:

[
S_i(t+\Delta t)=sat_{sym}\left((1-\lambda\Delta t)S_i(t) + \Delta t\sum_{j\in N(i)} w_{ij}(S_j(t)-S_i(t)) + \Delta t,u_i(t)\right)
]

* (\lambda): disipaciÃ³n (evita oscilaciones infinitas)
* (w_{ij}): pesos normalizados (derivables de (T_{ij}))
* (u_i(t)): impulso exÃ³geno (feed/OrÃ¡culo)

VI.3. Fuerza de pÃ¡nico (empuje termodinÃ¡mico)

[
F^{panic}_i = \alpha_p \tanh(\beta_p(-S_i)) \cdot \mathbf{g}_i
]
donde (\mathbf{g}_i) puede ser gradiente de densidad o vector hacia â€œzonas segurasâ€ (Ley IV), siempre acotado.

VI.4. ProyecciÃ³n directa a shock sin CPU pesada

Se define una LUT:

[
shock_i = LUT_{S\to shock}[sent8_i + 128]
]

Regla: el OrÃ¡culo (Ley VI) puede modular `sent8` (o (u_i)), pero la proyecciÃ³n a `shock` es LUT-only.

---

ARTÃCULO VII â€” Vertex28: La Ãšnica Realidad Exportable (IntegraciÃ³n con Ley III/IV/V)

VII.1. DefiniciÃ³n canÃ³nica del bus (stride 28)

```cpp
// 28 bytes exactos: el bus final hacia WebGL2/VBO
struct Vertex28 {
  float x, y, z;     // 12B (2D => z=0)
  float risk;        // 4B
  float shock;       // 4B
  uint32_t meta32;   // 4B
  uint16_t idx16;    // 2B  (slot)
  uint16_t pad;      // 2B  (alineaciÃ³n)
};
static_assert(sizeof(Vertex28)==28);
```

VII.2. Prohibiciones constitucionales

* Prohibido aÃ±adir floats â€œpor comodidadâ€.
* Prohibido depender de doubles en runtime visual.
* Prohibido que el render â€œdescubraâ€ identidad por strings.
* Prohibido que la fÃ­sica lea del Atlas narrativo.

---

ARTÃCULO VIII â€” Meta32 Soberano: Layout Dual-RÃ©gimen, Masks y Branchless Rules

Meta32 es el Ãºnico canal de semÃ¡ntica no-float hacia GPU.
Para conciliar vitalidad (Ley V) y taxonomÃ­a (Ley VII) sin ampliar bus, se adopta layout dual por rÃ©gimen de STATE2.

VIII.1. Bits universales

[
STATE2 = meta32\ &\ 0x3
]

* `00` = ALFA
* `01` = SIGMA
* `10` = OMEGA
* `11` = reservado (debug/void)

VIII.2. Layout A (STATE=ALFA): taxonomÃ­a + render contract

LSBâ†’MSB (bit 0 a 31):

* Bits 0..1: `STATE2`
* Bits 2..5: `GROUP4`
* Bits 6..9: `SUBGROUP4`
* Bits 10..15: `CATEGORY6`
* Bits 16..17: `IS2` (estado de inferencia corto)
* Bits 18..19: `PH2` (fenotipo visual compacto)
* Bits 20..23: `LOD4`
* Bits 24..27: `ORACLE4` = {DISPUTE, QUAR, FLASH, VOLFAKE}
* Bits 28..31: `FLAGS4` = {ORPHAN, SHADOW, PINNED, RESERVED}

JustificaciÃ³n: en ALFA no se requiere TSD; la semÃ¡ntica Ãºtil es taxonomÃ­a+LOD+orÃ¡culo.

VIII.3. Layout B (STATEâ‰ ALFA): vitalidad + persistencia (Ley V)

* Bits 0..1: `STATE2`
* Bits 2..9: `TSD_LOG8`
* Bits 10..15: `CLUSTER_CRIT6`
* Bits 16..23: `COOLDOWN_T8`
* Bits 24..31: `FLAGS8` (incluye orÃ¡culo + transiciÃ³n)

VIII.4. DecodificaciÃ³n branchless (CPU/GPU)

Se construye un selector:

[
m = -1 \cdot 1[STATE2==ALFA] \quad\Rightarrow\quad m \in {0x00000000,\ 0xFFFFFFFF}
]

y se combinan interpretaciones sin ramas:

[
val = (val_A \ &\ m)\ |\ (val_B\ &\ \sim m)
]

VIII.5. Masks compuestas (ejemplos)

```cpp
// universal
constexpr uint32_t M_STATE2    = 0x00000003u;

// ALFA fields
constexpr uint32_t M_GROUP4    = 0x0000003Cu;   // bits 2..5
constexpr uint32_t M_SUBG4     = 0x000003C0u;   // bits 6..9
constexpr uint32_t M_CAT6      = 0x0000FC00u;   // bits 10..15
constexpr uint32_t M_IS2       = 0x00030000u;   // bits 16..17
constexpr uint32_t M_PH2       = 0x000C0000u;   // bits 18..19
constexpr uint32_t M_LOD4      = 0x00F00000u;   // bits 20..23
constexpr uint32_t M_ORACLE4   = 0x0F000000u;   // bits 24..27
constexpr uint32_t M_FLAGS4    = 0xF0000000u;   // bits 28..31

// SIGMA/OMEGA fields (Ley V)
constexpr uint32_t M_TSD8      = 0x000003FCu;   // bits 2..9
constexpr uint32_t M_CRIT6     = 0x0000FC00u;   // bits 10..15
constexpr uint32_t M_COOL8     = 0x00FF0000u;   // bits 16..23
constexpr uint32_t M_FLAGS8    = 0xFF000000u;   // bits 24..31
```

---

ARTÃCULO IX â€” ConexiÃ³n Inter-Ley: SoberanÃ­a, DinÃ¡mica, OrÃ¡culo, VacÃ­o

IX.1. Con Ley I (Identidad)

Ley I define la ontologÃ­a de identidad; Ley VII define la sustancia computable.
UID64 ancla todo: sin UID vÃ¡lido no hay Atlas, no hay Meta32, no hay Vertex.

IX.2. Con Ley IV (DinÃ¡mica)

DNA32 y SENT8 se proyectan a coeficientes ((m,\gamma,\kappa^\Omega)) y fuerzas (pÃ¡nico, fricciÃ³n), sin aÃ±adir bytes.

IX.3. Con Ley V (Persistencia)

En SIGMA/OMEGA, Meta32 cambia a layout de TSD/cooldown: la â€œmemoriaâ€ domina.
La taxonomÃ­a completa sigue existiendo en Atlas; el bus no se rompe.

IX.4. Con Ley VI (OrÃ¡culo)

El OrÃ¡culo no escribe strings; escribe:

* flags de disputa/cuarentena/flash â†’ `ORACLE4` o `FLAGS8`
* seÃ±ales compactas â†’ `sent8`/shock/risk

IX.5. Con Ley VIII (VoidPool)

Al reciclar slots, se exige anti-ABA (GEN en VER16 o verificaciÃ³n rec.uid==uid).
La soberanÃ­a de UID evita â€œresurrecciones falsasâ€.

IX.6. Con Ley IX (Masa mÃ­nima)

Toda energÃ­a/masa informacional se calcula sobre seÃ±ales derivadas de la tupla y su proyecciÃ³n; no sobre nombres.

---

ARTÃCULO X â€” Identity-Shadowing: MutaciÃ³n Masiva sin Parar el Mundo

Para reclasificar o cambiar familia topolÃ³gica (FAM16) en masa (ej. 10k activos) sin stutter:

1. Mantener doble buffer de `fam16`/clasificaciones.
2. Escribir en buffer sombra en background.
3. Hacer swap atÃ³mico de puntero al inicio del tick:

[
ptr_{fam} \leftarrow atomic_exchange(ptr_{fam}, ptr_{fam}^{shadow})
]

Mandato: 10k actualizaciones deben costar < 0.5ms (memcpy contiguo + swap).

---

ARTÃCULO XI â€” Persistencia e Integridad: SerializaciÃ³n y CorrupciÃ³n

XI.1. SerializaciÃ³n binaria mÃ­nima

UID64, DNA32, SENT8 se serializan en little-endian:

```
[uid64_le][dna32_le][sent8][pad7]
```

`pad7` para alineaciÃ³n/stream.

XI.2. VerificaciÃ³n de integridad

* CRC32 opcional por AssetRecord (no en camino crÃ­tico).
* Checks rÃ¡pidos obligatorios en camino crÃ­tico:

  * `rec.uid == uid`
  * `rec.hid == HID32(uid)`
  * `rec.ver == VER16(uid)` si anti-ABA activo

XI.3. Identidad corrupta

Si falla validaciÃ³n:

* marcar `ORPHAN` en Meta32 (o flags internos),
* excluir de Vertex28,
* notificar al subsistema de cuarentena (Ley VI) o a VoidPool (Ley VIII) segÃºn polÃ­tica.

---

ARTÃCULO XII â€” ImplementaciÃ³n Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly

> Nota: pseudocÃ³digo â€œejecutable-likeâ€ (sin dependencias), diseÃ±ado para compilar a C++17 o WASM SIMD.

XII.1. Primitivas

```cpp
using u8  = uint8_t;
using i8  = int8_t;
using u16 = uint16_t;
using u32 = uint32_t;
using u64 = uint64_t;

static inline u32 HID32(u64 uid) { return (u32)(uid >> 32); }
static inline u16 FAM16(u64 uid) { return (u16)(uid >> 16); }
static inline u16 VER16(u64 uid) { return (u16)(uid); }

static inline u32 bcast_mask(bool b) { return b ? 0xFFFFFFFFu : 0u; }
static inline u32 sel_u32(u32 a, u32 b, u32 m){ return (a & m) | (b & ~m); } // m=all1 selects a
```

XII.2. Hashes 2-vÃ­as (branchless)

```cpp
static inline u32 mix32(u32 x){
  x ^= x >> 16; x *= 0x7feb352dU;
  x ^= x >> 15; x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}
static inline u32 h0(u32 hid){ return mix32(hid ^ 0xA5A5A5A5U); }
static inline u32 h1(u32 hid){ return mix32(hid ^ 0x5A5A5A5AU); }
```

XII.3. Lookup SIMD-friendly en Bucket64

VersiÃ³n escalar branchless (8 entradas), portable:

```cpp
struct alignas(64) Bucket64 {
  u32 hid[8];
  u16 ver[8];
  u16 tag[8];
};

static inline int bucket_scan8(const Bucket64& b, u32 H){
  // devuelve Ã­ndice 0..7 si encuentra, o -1 si no.
  // branchless: acumulamos mÃ¡scara
  u32 hit_mask = 0;
pragma unroll
  for(int k=0;k<8;k++){
    u32 eq = (b.hid[k] == H);      // compila a setcc
    hit_mask |= (eq << k);
  }
  // convertir mask->index: ctz; si 0 => -1
  if(hit_mask == 0) return -1;
  return __builtin_ctz(hit_mask);
}
```

VersiÃ³n WASM SIMD (idea; intrÃ­nsecos dependen de toolchain):

```cpp
// PseudocÃ³digo: comparar 4 hid a la vez (v128), luego otros 4.
// En SSE serÃ­a _mm_cmpeq_epi32 + movemask.
// En WASM: i32x4.eq + bitmask.
```

XII.4. lookup_hid: dos cubetas, O(1)

```cpp
struct CuckooTable {
  Bucket64* pages[8];   // PAGE3 -> base de cubetas
  u32 buckets_per_page; // tÃ­picamente 4096
};

struct LookupRes { bool ok; u16 ver; u16 fam; };

static inline LookupRes lookup_hid(const CuckooTable& T, u32 hid){
  u32 b0 = h0(hid) & (T.buckets_per_page - 1);
  u32 b1 = h1(hid) & (T.buckets_per_page - 1);

  // PAGE3 puede derivarse del hash alto (o de fam si se conoce)
  u32 p0 = (h0(hid) >> 29) & 0x7;
  u32 p1 = (h1(hid) >> 29) & 0x7;

  const Bucket64& A = T.pages[p0][b0];
  const Bucket64& B = T.pages[p1][b1];

  int ia = bucket_scan8(A, hid);
  int ib = bucket_scan8(B, hid);

  bool oka = (ia >= 0);
  bool okb = (ib >= 0);
  bool ok  = oka | okb;

  // selecciÃ³n sin ramas: preferimos A si ambos (colisiÃ³n rara)
  u32 mA = bcast_mask(oka);
  u16 ver = (u16)sel_u32( oka ? A.ver[ia] : 0, okb ? B.ver[ib] : 0, mA );
  u16 fam = 0;
  // reconstruimos FAM16: PAGE3|BUCK12|SIDE1
  // BUCK12 = bX, SIDE1=0 si A, 1 si B (ejemplo)
  u16 famA = (u16)((p0<<13) | ((b0 & 0x0FFF)<<1) | 0);
  u16 famB = (u16)((p1<<13) | ((b1 & 0x0FFF)<<1) | 1);
  fam = (u16)sel_u32(famA, famB, mA);

  return { ok, ver, fam };
}
```

XII.5. Atlas access O(1) + ValidateUID

```cpp
struct Atlas { AssetRecord* rec; u32 cap; };

static inline bool ValidateUID(const Atlas& A, u64 uid){
  u16 slot = VER16(uid);
  if(slot >= A.cap) return false;
  const AssetRecord& r = A.rec[slot];
  // checks mÃ­nimos
  return (r.uid == uid) & (r.hid == HID32(uid));
}

static inline AssetRecord* GetAssetRecordFromUID(const Atlas& A, u64 uid){
  u16 slot = VER16(uid);
  // en hot path asumimos slot vÃ¡lido tras ValidateUID
  return &A.rec[slot];
}
```

XII.6. DNA decode + LUT projection (branchless)

```cpp
static inline u32 BHV20(u32 dna){ return dna & 0x000FFFFFU; }
static inline u32 LIQ4 (u32 dna){ return (dna >> 20) & 0xFU; }
static inline u32 TYPE4(u32 dna){ return (dna >> 24) & 0xFU; }
static inline u32 JUR4 (u32 dna){ return (dna >> 28) & 0xFU; }

struct Phys { float m, gamma, kappaOmega; };

extern float LUT_BHV_MASS[20];
extern float LUT_BHV_DRAG[20];
extern float LUT_BHV_CURV[20];
extern float LUT_LIQ2MU[16];
extern float LUT_TYPE2BASEM[16];
extern float LUT_JUR2CURV[16];

static inline float clipf(float x, float lo, float hi){
  return x < lo ? lo : (x > hi ? hi : x);
}

static inline Phys DecodePhys(u32 dna){
  u32 bhv = BHV20(dna);
  u32 liq = LIQ4(dna);
  u32 typ = TYPE4(dna);
  u32 jur = JUR4(dna);

  float dm = LUT_TYPE2BASEM[typ];
  float dg = 0.0f;
  float dk = LUT_JUR2CURV[jur];

  // acumulaciÃ³n BHV20
  // (se puede vectorizar por bloques de 4 bits)
pragma unroll
  for(int k=0;k<20;k++){
    u32 bit = (bhv >> k) & 1U;
    // convertir a float 0/1 sin rama:
    float f = (float)bit;
    dm += f * LUT_BHV_MASS[k];
    dg += f * LUT_BHV_DRAG[k];
    dk += f * LUT_BHV_CURV[k];
  }

  float m     = clipf(1.0f + dm, 0.1f, 50.0f);
  float gamma = clipf(0.1f + dg, 0.01f, 10.0f);
  float kO    = clipf(0.0f + dk, -5.0f, 5.0f);

  return { m, gamma, kO };
}
```

XII.7. SENT8 transport + projection to shock

```cpp
extern float LUT_S2Shock[256];

static inline float SentToShock(i8 sent){
  return LUT_S2Shock[(u8)(sent + 128)];
}

// ejemplo: update simple por disipaciÃ³n (la difusiÃ³n usa vecinos Ley IV)
static inline i8 UpdateSent(i8 sent, float dt, float lambda){
  float S = (float)sent / 127.0f;
  S = S * (1.0f - lambda*dt);
  // clamp [-1,1]
  if(S > 1.0f) S = 1.0f;
  if(S < -1.0f) S = -1.0f;
  int v = (int)lrintf(S * 127.0f);
  if(v > 127) v = 127;
  if(v < -128) v = -128;
  return (i8)v;
}
```

XII.8. Meta32 composition (ALFA)

```cpp
// shifts ALFA
constexpr u32 S_GROUP = 2;
constexpr u32 S_SUBG  = 6;
constexpr u32 S_CAT   = 10;
constexpr u32 S_IS2   = 16;
constexpr u32 S_PH2   = 18;
constexpr u32 S_LOD   = 20;
constexpr u32 S_ORCL  = 24;
constexpr u32 S_FLG4  = 28;

static inline u32 PackMeta32_ALFA(u32 group4, u32 subg4, u32 cat6,
                                 u32 is2, u32 ph2, u32 lod4,
                                 u32 oracle4, u32 flags4){
  u32 meta = 0;
  meta |= 0u; // STATE=ALFA => 00
  meta |= (group4 & 0xF) << S_GROUP;
  meta |= (subg4  & 0xF) << S_SUBG;
  meta |= (cat6   & 0x3F) << S_CAT;
  meta |= (is2    & 0x3) << S_IS2;
  meta |= (ph2    & 0x3) << S_PH2;
  meta |= (lod4   & 0xF) << S_LOD;
  meta |= (oracle4& 0xF) << S_ORCL;
  meta |= (flags4 & 0xF) << S_FLG4;
  return meta;
}
```

XII.9. ProyecciÃ³n completa al Vertex28 (slot â†’ bus)

```cpp
static inline void ProjectToVertex28(Vertex28& v, u16 idx16,
                                     float x,float y,float z,
                                     float risk, float shock,
                                     u32 meta32){
  v.x = x; v.y = y; v.z = z;
  v.risk = risk;
  v.shock = shock;
  v.meta32 = meta32;
  v.idx16 = idx16;
  v.pad = 0;
}
```

---

ARTÃCULO XIII â€” Modelo de Coste y Presupuesto (Ciclos y K-Budgets)

XIII.1. Costes por operaciÃ³n (orden de magnitud)

Tabla orientativa (CPU moderna; depende de arquitectura, pero sirve como constituciÃ³n de presupuesto):

| OperaciÃ³n                     |                                           Coste tÃ­pico |
| ----------------------------- | -----------------------------------------------------: |
| 2 hashes mix32 (h0+h1)        |                                           10â€“20 ciclos |
| Carga Bucket64 (64B)          |                      4â€“12 ciclos (L1 hit) / 30â€“80 (L3) |
| Scan 8 HID32 (escalar)        |                                            8â€“20 ciclos |
| Scan 8 HID32 (SIMD)           |                                             3â€“8 ciclos |
| ValidaciÃ³n Atlas (2 compares) |                                             2â€“5 ciclos |
| Decode DNA (LUT + 20 bits)    | 30â€“80 ciclos (escalar) / 10â€“30 (vectorizado por lotes) |
| Sentâ†’Shock LUT                |                                             2â€“5 ciclos |
| Pack Meta32                   |                                             3â€“8 ciclos |

XIII.2. Presupuestos fijos constitucionales

* K_UID_RESOLVE: presupuesto de resoluciÃ³n por frame
  [
  K_{UID} \le 0.35\text{ ms/frame}
  ]
* K_DNA_PHYSICS: derivaciÃ³n coeficientes desde DNA (por lotes)
  [
  K_{DNA} \le 0.75\text{ ms/frame}
  ]
* K_SENTIMENT_DYNAMICS: actualizaciÃ³n de SENT8 + proyecciÃ³n shock
  [
  K_{SENT} \le 0.40\text{ ms/frame}
  ]

Total Ley VII:
[
K_{VII}=K_{UID}+K_{DNA}+K_{SENT}\le 1.5\text{ ms/frame}
]

XIII.3. Mantenimiento bajo carga

* LOD4 reduce coste visual y densidad.
* Batch decode de DNA: vectorizaciÃ³n por bloques de slots contiguos (morton-friendly).
* Atlas 64B asegura prefetch eficiente.
* Cuckoo evita colas variables (tiempo acotado).

---

ARTÃCULO XIV â€” Axioma Final

[
\boxed{\text{En TITAN V8, el nombre no tiene ontologÃ­a: es un relato externo.}}
]
[
\boxed{\text{La Ãºnica realidad computable es }(UID64,\ DNA32,\ SENT8)\text{ y su proyecciÃ³n inmutable a }(\Omega,\gamma,m,\ Meta32,\ shock).}
]
[
\boxed{\text{Por tanto, la identidad del mercado no se lee: se construye bit a bit.}}
]

LEY VIII â€” La ReencarnaciÃ³n: Protocolo de Purga, VacÃ­o y Reciclaje de Identidad
(OMEGA-ZERO, VoidPool MPMC, Anti-ABA, Anti-Replay, y ReutilizaciÃ³n de Slots sin Locks ni Realloc)

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” OMEGA-ZERO (VacÃ­o Absoluto) y elegibilidad: definiciÃ³n formal + condiciÃ³n booleana cerrada
3. ARTÃCULO II â€” UID64: reencarnaciÃ³n segura (Anti-ABA, Anti-colisiÃ³n, Anti-replay)
4. ARTÃCULO III â€” Meta32: bits soberanos de vida (branchless-skip), multiplexaciÃ³n TSD8/LOD y LifeFlags
5. ARTÃCULO IV â€” VoidPool: estructura O(1) lock-free (MPMC ring con secuencia por celda)
6. ARTÃCULO V â€” Pipeline de Muerte (ALFA â†’ SIGMA/OMEGA â†’ OMEGA-ZERO): enfriamiento fÃ­sico + commit Ãºnico
7. ARTÃCULO VI â€” Pipeline de Nacimiento (OMEGA-ZERO â†’ ALFA): PREPARE/COMMIT, spawn estable, Birth-Shield
8. ARTÃCULO VII â€” ImplementaciÃ³n de bajo nivel: pseudocÃ³digo ejecutable C++/WASM (lock-free, branchless, SIMD-friendly)
9. ARTÃCULO VIII â€” Modelo de coste y presupuesto (ciclos, K_*) y garantÃ­a bajo churn alto
10. ARTÃCULO IX â€” EspecificaciÃ³n binaria y bitwise (Meta32 soberano para reencarnaciÃ³n) + mÃ¡scaras compuestas
11. ARTÃCULO I â€” OMEGA-ZERO (VacÃ­o Absoluto) y Elegibilidad
12. ARTÃCULO II â€” UID64: ReencarnaciÃ³n Segura (Anti-ABA, Anti-ColisiÃ³n, Anti-Replay)
13. ARTÃCULO III â€” Meta32: Bits Soberanos de Vida (Branchless-Skip)
14. ARTÃCULO IV â€” VoidPool: Estructura O(1) Lock-Free (MPMC Ring)
15. ARTÃCULO V â€” Pipeline de Muerte (ALFA â†’ SIGMA/OMEGA â†’ OMEGA-ZERO)
16. ARTÃCULO VI â€” Pipeline de Nacimiento (OMEGA-ZERO â†’ ALFA) con PREPARE/COMMIT
17. ARTÃCULO VII â€” ImplementaciÃ³n Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly
18. ARTÃCULO VIII â€” Modelo de Coste y Presupuesto de Rendimiento
19. ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 Soberano para ReencarnaciÃ³n)
20. AXIOMA FINAL

Ãmbito


LEY VIII â€” La ReencarnaciÃ³n: Protocolo de Purga, VacÃ­o y Reciclaje de Identidad

ARTÃCULO I â€” OMEGA-ZERO (VacÃ­o Absoluto) y elegibilidad: definiciÃ³n formal + condiciÃ³n booleana cerrada

ARTÃCULO II â€” UID64: reencarnaciÃ³n segura (Anti-ABA, Anti-colisiÃ³n, Anti-replay)

ARTÃCULO III â€” Meta32: bits soberanos de vida (branchless-skip), multiplexaciÃ³n TSD8/LOD y LifeFlags

ARTÃCULO IV â€” VoidPool: estructura O(1) lock-free (MPMC ring con secuencia por celda)

ARTÃCULO V â€” Pipeline de Muerte (ALFA â†’ SIGMA/OMEGA â†’ OMEGA-ZERO): enfriamiento fÃ­sico + commit Ãºnico

ARTÃCULO VI â€” Pipeline de Nacimiento (OMEGA-ZERO â†’ ALFA): PREPARE/COMMIT, spawn estable, Birth-Shield

ARTÃCULO VII â€” ImplementaciÃ³n de bajo nivel: pseudocÃ³digo ejecutable C++/WASM (lock-free, branchless, SIMD-friendly)

ARTÃCULO VIII â€” Modelo de coste y presupuesto (ciclos, K_*) y garantÃ­a bajo churn alto

ARTÃCULO IX â€” EspecificaciÃ³n binaria y bitwise (Meta32 soberano para reencarnaciÃ³n) + mÃ¡scaras compuestas

AXIOMA FINAL

Ãmbito

En TITAN V8 el universo de slots es constante y cerrado:

ğ‘
=
200,000
(constante constitucional)
Î”
ğ‘¡
ğ‘“
ğ‘Ÿ
ğ‘
ğ‘š
ğ‘’
=
16.67
 ms
N=200,000(constante constitucional)Î”t
frame
	â€‹

=16.67 ms

No existe â€œcreaciÃ³n/destrucciÃ³nâ€ de slots. Existe Ãºnicamente transmutaciÃ³n:

ALFA
â†’
SIGMA/OMEGA
â†’
OMEGA-ZERO
â†’
ALFA
ALFAâ†’SIGMA/OMEGAâ†’OMEGA-ZEROâ†’ALFA

La reencarnaciÃ³n es una operaciÃ³n de ruta caliente (â€œhot loopâ€) y por tanto debe ser:

ğ‘‚
(
1
)
O(1) por slot, acotada, sin colas variables.

Lock-free, zero-copy, branchless-skip (saltos por mÃ¡scaras).

Sin reallocations de VBO: el bus Vertex28 es inmutable (Ley III/IV/VII).

IntegraciÃ³n estricta con:

Ley I (Identidad): la entidad es UID64 y su validez.

Ley V (Vitalidad/TSD): muerte/persistencia gobernadas por TSD8.

Ley VII (Atlas residente): slot â†” AssetRecord 64B; strings fuera.

Ley IX (Masa mÃ­nima): el â€œcadÃ¡verâ€ no debe inyectar energÃ­a residual.

Mandato operativo: bajo churn extremo (altas entradas/salidas), TITAN V8 mantiene estabilidad numÃ©rica, visual y de identidad, sin micro-stutter, sin ABA, sin replays, sin colisiones vivas.

ARTÃCULO I â€” OMEGA-ZERO (VacÃ­o Absoluto) y Elegibilidad
I.1. DefiniciÃ³n formal (estado terminal elegible)

Se define OMEGA-ZERO como el estado terminal de un slot
ğ‘ 
s en el que no existe entidad viva ni memoria residual efectiva, y por tanto el slot es reclamable.

Un slot estÃ¡ en OMEGA-ZERO si y solo si satisface simultÃ¡neamente:

Condiciones mÃ­nimas de Atlas (Ley VII)
atlas.hid32
[
ğ‘ 
]
=
0
ğ‘¥
00000000

âˆ§

atlas.uid64
[
ğ‘ 
]
=
0
atlas.hid32[s]=0x00000000 âˆ§ atlas.uid64[s]=0
atlas.dna32
[
ğ‘ 
]
=
0

âˆ§

atlas.sent8
[
ğ‘ 
]
=
0
atlas.dna32[s]=0 âˆ§ atlas.sent8[s]=0

Nota: uid64==0 es â€œtumba fÃ­sicaâ€. HID32=0 es â€œinexistencia lÃ³gicaâ€. Ambos obligatorios.

Condiciones mÃ­nimas de Estado fÃ­sico (Ley IV)
ğ‘¥
ğ‘ 
=
ğ‘¥
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
,
ğ‘£
ğ‘ 
=
0
x
s
	â€‹

=x
void
	â€‹

,v
s
	â€‹

=0
ğ‘Ÿ
ğ‘–
ğ‘ 
ğ‘˜
ğ‘ 
=
0
,
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘ 
=
0
risk
s
	â€‹

=0,shock
s
	â€‹

=0

donde el â€œvector voidâ€ es un punto fuera de la cÃ¡mara y fuera de rangos de celdas Morton operativas:

ğ‘¥
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
=
(
ğ‘‹
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
,
ğ‘Œ
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
,
ğ‘
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
)
,
ğ‘‹
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
=
ğ‘Œ
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
=
ğ‘
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
=
10
9
x
void
	â€‹

=(X
void
	â€‹

,Y
void
	â€‹

,Z
void
	â€‹

),X
void
	â€‹

=Y
void
	â€‹

=Z
void
	â€‹

=10
9
Condiciones mÃ­nimas de Persistencia (Ley V)
ğ‘‡
ğ‘†
ğ·
8
(
ğ‘ 
)
=
0
ğ‘¥
ğ¹
ğ¹
(
saturaci
o
ËŠ
n terminal
)
TSD8(s)=0xFF(saturaci
o
ËŠ
n terminal)
Condiciones mÃ­nimas de Meta32 (Ley III/V/VII)
(
Meta32
ğ‘ 

&

ğ¹
_
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
)
â‰ 
0
(Meta32
s
	â€‹

 & F_VOID_READY)
î€ 
=0

y ademÃ¡s:

(
Meta32
ğ‘ 

&

ğ¹
_
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
)
=
0

âˆ§

(
Meta32
ğ‘ 

&

ğ¹
_
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğ·
ğ¸
ğ´
ğ‘‡
ğ»
)
=
0
(Meta32
s
	â€‹

 & F_PENDING_BIRTH)=0 âˆ§ (Meta32
s
	â€‹

 & F_PENDING_DEATH)=0

DICTAMEN: OMEGA-ZERO es el Ãºnico estado elegible para reclamo. NingÃºn otro estado puede ser extraÃ­do del pool ni reasignado.

I.2. CondiciÃ³n booleana cerrada: VoidReady(s)

Se define la funciÃ³n de elegibilidad (booleana cerrada, sin ambigÃ¼edad):

ğ‘‰
ğ‘œ
ğ‘–
ğ‘‘
ğ‘…
ğ‘’
ğ‘
ğ‘‘
ğ‘¦
(
ğ‘ 
)
=
1
[
ğ‘‡
ğ‘†
ğ·
8
(
ğ‘ 
)
=
255
]
âˆ§
1
[
ğ¾
ğ¸
(
ğ‘ 
)
â‰¤
ğœ€
ğ¾
ğ¸
]
âˆ§
1
[
âˆ£
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
(
ğ‘ 
)
âˆ£
â‰¤
ğœ€
ğ‘†
]
âˆ§
1
[
âˆ£
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
8
(
ğ‘ 
)
âˆ£
â‰¤
ğœ€
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
]
VoidReady(s)=1[TSD8(s)=255]âˆ§1[KE(s)â‰¤Îµ
KE
	â€‹

]âˆ§1[âˆ£shock(s)âˆ£â‰¤Îµ
S
	â€‹

]âˆ§1[âˆ£sent8(s)âˆ£â‰¤Îµ
sent
	â€‹

]

donde la energÃ­a cinÃ©tica del slot es:

ğ¾
ğ¸
(
ğ‘ 
)
=
1
2

ğ‘š
ğ‘ 

âˆ¥
ğ‘£
ğ‘ 
âˆ¥
2
KE(s)=
2
1
	â€‹

m
s
	â€‹

âˆ¥v
s
	â€‹

âˆ¥
2

y las constantes â€œde silicioâ€ (tolerancias FP32) se fijan constitucionalmente:

ğœ€
ğ¾
ğ¸
=
10
âˆ’
8
,
ğœ€
ğ‘†
=
10
âˆ’
6
,
ğœ€
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
=
1
Îµ
KE
	â€‹

=10
âˆ’8
,Îµ
S
	â€‹

=10
âˆ’6
,Îµ
sent
	â€‹

=1

InterpretaciÃ³n: sent8 debe ser exactamente 0 o residual mÃ­nimo (|sent8|â‰¤1) antes de declararlo vacÃ­o.

DICTAMEN: el flag
ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
F
VOID_READY
	â€‹

 solo puede elevarse cuando
ğ‘‰
ğ‘œ
ğ‘–
ğ‘‘
ğ‘…
ğ‘’
ğ‘
ğ‘‘
ğ‘¦
(
ğ‘ 
)
=
ğ‘¡
ğ‘Ÿ
ğ‘¢
ğ‘’
VoidReady(s)=true. Cualquier violaciÃ³n es corrupciÃ³n ontolÃ³gica (bug de clase constitucional).

ARTÃCULO II â€” UID64: ReencarnaciÃ³n Segura (Anti-ABA, Anti-ColisiÃ³n, Anti-Replay)
II.1. Layout inmutable (Ley VII)
ğ‘ˆ
ğ¼
ğ·
64
=
[
ğ»
ğ¼
ğ·
32

âˆ£

ğ¹
ğ´
ğ‘€
16

âˆ£

ğ‘‰
ğ¸
ğ‘…
16
]
UID64=[HID32 âˆ£ FAM16 âˆ£ VER16]
	â€‹


HID32: identidad lÃ³gica (hash estable), no â€œtickerâ€.

FAM16: selector topolÃ³gico (Cuckoo 2-vÃ­as, cache-line first).

VER16: epoch/version del slot (anti-ABA).

II.2. VER16 como epoch anti-ABA

Se fija el layout de VER16 como:

ğ‘‰
ğ¸
ğ‘…
16
=
[
ğ¼
ğ·
ğ‘‹
12

âˆ£

ğ¸
ğ‘ƒ
ğ‘‚
ğ¶
ğ»
4
]
VER16=[IDX12 âˆ£ EPOCH4]
	â€‹


IDX12 (bits 15..4): Ã­ndice del slot (0..4095 por pÃ¡gina / o global segÃºn atlas).

EPOCH4 (bits 3..0): contador de reencarnaciÃ³n (0..15) que incrementa en cada commit de nacimiento.

Regla anti-ABA (cerrada):
Si un puntero/UID referencia el mismo IDX12 pero EPOCH4 cambia, es otra entidad (aunque ocupe el mismo slot fÃ­sico).

En validaciÃ³n de acceso (Ley VII):

ğ‘‰
ğ‘
ğ‘™
ğ‘–
ğ‘‘
ğ‘
ğ‘¡
ğ‘’
ğ‘ˆ
ğ¼
ğ·
(
ğ‘¢
ğ‘–
ğ‘‘
)
â‡’
ğ‘Ÿ
ğ‘’
ğ‘
.
ğ‘£
ğ‘’
ğ‘Ÿ
16
=
ğ‘‰
ğ¸
ğ‘…
16
(
ğ‘¢
ğ‘–
ğ‘‘
)
ValidateUID(uid)â‡’rec.ver16=VER16(uid)

Si no coincide: rechazo.

Nota operativa: si 4 bits parecen â€œpocosâ€, se compensa con RejectWindow_W y con validaciÃ³n de HID en Cuckoo (doble cerrojo). El objetivo es O(1) y compactaciÃ³n, no criptografÃ­a infinita.

II.3. HID32 â€œno se quemaâ€: triple cerrojo

Se permite asignar HID32_new al slot reciclado solo si:

No-cero:

ğ»
ğ¼
ğ·
32
ğ‘›
ğ‘’
ğ‘¤
â‰ 
0
HID32
new
	â€‹

î€ 
=0

No estÃ¡ en ventana de rechazo (anti-replay):

ğ»
ğ¼
ğ·
32
ğ‘›
ğ‘’
ğ‘¤
âˆ‰
ğ‘…
ğ‘’
ğ‘—
ğ‘’
ğ‘
ğ‘¡
ğ‘Š
ğ‘–
ğ‘›
ğ‘‘
ğ‘œ
ğ‘¤
ğ‘Š
HID32
new
	â€‹

âˆˆ
/
RejectWindow
W
	â€‹


No existe en Cuckoo vivo (anti-colisiÃ³n viva):

ğ‘™
ğ‘œ
ğ‘œ
ğ‘˜
ğ‘¢
ğ‘
_
â„
ğ‘–
ğ‘‘
(
ğ»
ğ¼
ğ·
32
ğ‘›
ğ‘’
ğ‘¤
)
=
ğ‘“
ğ‘
ğ‘™
ğ‘ 
ğ‘’
lookup_hid(HID32
new
	â€‹

)=false

DICTAMEN: si cualquiera falla, la reencarnaciÃ³n no comitea. Se genera otro HID o se retrasa (backoff).

II.4. GeneraciÃ³n determinista de HID32 (sin strings, anti-spoof)

Se fija la generaciÃ³n como:

ğ»
ğ¼
ğ·
32
ğ‘›
ğ‘’
ğ‘¤
=
Trunc32
â¡
(
SipHash
â¡
ğ¾
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
(
ğ¹
ğ´
ğ‘€
16
âˆ¥
ğ‘‰
ğ¸
ğ‘…
16
âˆ¥
ğ‘›
ğ‘œ
ğ‘›
ğ‘
ğ‘’
32
)
)
HID32
new
	â€‹

=Trunc32(SipHash
K
epoch
	â€‹

	â€‹

(FAM16âˆ¥VER16âˆ¥nonce32))

ğ¾
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
K
epoch
	â€‹

 rota determinÃ­sticamente por epoch global (no por wall-clock):

ğ¾
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
=
KDF
â¡
(
ğ¾
ğ‘š
ğ‘
ğ‘ 
ğ‘¡
ğ‘’
ğ‘Ÿ
,
ğ‘’
ğ‘
ğ‘œ
ğ‘
â„
_
ğ‘”
ğ‘™
ğ‘œ
ğ‘
ğ‘
ğ‘™
)
K
epoch
	â€‹

=KDF(K
master
	â€‹

,epoch_global)

nonce32 se deriva de contador monotÃ³nico + slot + tick:

ğ‘›
ğ‘œ
ğ‘›
ğ‘
ğ‘’
32
=
ğ‘š
ğ‘–
ğ‘¥
32
(
birthCounter
âŠ•
(
ğ‘ 
â‰ª
16
)
âŠ•
ğ‘¡
ğ‘–
ğ‘
ğ‘˜
)
nonce32=mix32(birthCounterâŠ•(sâ‰ª16)âŠ•tick)

DICTAMEN: jamÃ¡s se usa string/ticker para formar HID. El folklore puede mapear a un UID, pero el UID nace del protocolo, no del relato.

ARTÃCULO III â€” Meta32: Bits Soberanos de Vida (Branchless-Skip)
III.1. MultiplexaciÃ³n constitucional sin romper Vertex28

Meta32 mantiene el contrato base de Ley V/VII: layout dual por estado (ALFA vs SIGMA/OMEGA).
Ley VIII aÃ±ade LifeFlags y gobierna su semÃ¡ntica.

Selector universal
ğ‘†
ğ‘‡
ğ´
ğ‘‡
ğ¸
2
=
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32

&

0
ğ‘¥
3
STATE2=Meta32 & 0x3

00 ALFA

01 SIGMA

10 OMEGA

11 reservado (debug/void)

III.2. LifeFlags (hex + bitwise)

Se definen cuatro flags de vida (se ubican dentro del campo FLAGS8 en SIGMA/OMEGA y dentro de FLAGS4 en ALFA; ver Art. IX):

ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
F
VOID_READY
	â€‹

: slot elegible (OMEGA-ZERO listo)

ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
F
PENDING_BIRTH
	â€‹

: slot reservado para nacimiento (fase PREPARE)

ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğ·
ğ¸
ğ´
ğ‘‡
ğ»
F
PENDING_DEATH
	â€‹

: slot marcado para muerte/enfriamiento

ğ¹
ğ‘‚
ğ‘…
ğ‘ƒ
ğ»
ğ´
ğ‘
_
ğ‘†
ğ»
ğ´
ğ·
ğ‘‚
ğ‘Š
F
ORPHAN_SHADOW
	â€‹

: entidad invÃ¡lida, sombra (no cruza a render ni sim)

Regla branchless-skip unificada (CPU/GPU):

ğ‘†
ğ¾
ğ¼
ğ‘ƒ
=
1
[
(
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32

&

(
ğ¹
ğ‘‚
ğ‘…
ğ‘ƒ
ğ»
ğ´
ğ‘
_
ğ‘†
ğ»
ğ´
ğ·
ğ‘‚
ğ‘Š

âˆ¨

ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
)
)
â‰ 
0
]
SKIP=1[(Meta32 & (F
ORPHAN_SHADOW
	â€‹

 âˆ¨ F
PENDING_BIRTH
	â€‹

))
î€ 
=0]

Si SKIP=1, el slot se salta de dinÃ¡mica/decisiones y se renderiza invisible (o se reubica a
ğ‘¥
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
x
void
	â€‹

).

III.3. TSD8 multiplexado

TSD8 se considera semÃ¡ntico solo si el slot estÃ¡ en trÃ¡nsito de muerte o vacÃ­o:

ğ‘‡
ğ‘†
ğ·
_
ğ´
ğ¶
ğ‘‡
ğ¼
ğ‘‰
ğ¸
=
1
[
(
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32

&

(
ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğ·
ğ¸
ğ´
ğ‘‡
ğ»

âˆ¨

ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
)
)
â‰ 
0
]

âˆ¨

1
[
ğ‘†
ğ‘‡
ğ´
ğ‘‡
ğ¸
2
â‰ 
ğ´
ğ¿
ğ¹
ğ´
]
TSD_ACTIVE=1[(Meta32 & (F
PENDING_DEATH
	â€‹

 âˆ¨ F
VOID_READY
	â€‹

))
î€ 
=0] âˆ¨ 1[STATE2
î€ 
=ALFA]

En ALFA, el campo â€œLOD4â€ existe; en SIGMA/OMEGA, esos bits se reutilizan como
ğ‘‡
ğ‘†
ğ·
4
â„
ğ‘–
ğ‘”
â„
TSD4
high
	â€‹

 (ver Art. IX).

DICTAMEN: TSD8 jamÃ¡s requiere bytes extra: es bit-reconstrucciÃ³n desde Meta32.

ARTÃCULO IV â€” VoidPool: Estructura O(1) Lock-Free (MPMC Ring)
IV.1. MPMC bounded con secuencia por celda

Se adopta una cola circular MPMC array-based con secuencia por celda (anti-ABA por celda, no por punteros).
Capacidad:

ğ‘„
ğ¶
ğ´
ğ‘ƒ
=
2
ğ‘
(
potencia de 2
)
QCAP=2
q
(potencia de 2)
ğ‘€
ğ´
ğ‘†
ğ¾
=
ğ‘„
ğ¶
ğ´
ğ‘ƒ
âˆ’
1
MASK=QCAPâˆ’1
Estructura de celda
struct Cell {
  std::atomic<uint64_t> seq; // secuencia por celda (cycle tag 64b, anti-ABA)
  uint32_t slot;             // idx del slot (u32)
};
struct VoidPoolMPMC {
  Cell*  buf;                // QCAP celdas
  uint32_t cap;              // QCAP
  uint32_t mask;             // QCAP-1
  std::atomic<uint32_t> head;
  std::atomic<uint32_t> tail;
};


InicializaciÃ³n:

ğ‘
ğ‘¢
ğ‘“
[
ğ‘–
]
.
ğ‘ 
ğ‘’
ğ‘
=
ğ‘–
,

âˆ€
ğ‘–
âˆˆ
[
0
,
ğ‘„
ğ¶
ğ´
ğ‘ƒ
)
buf[i].seq=i, âˆ€iâˆˆ[0,QCAP)
â„
ğ‘’
ğ‘
ğ‘‘
=
ğ‘¡
ğ‘
ğ‘–
ğ‘™
=
0
head=tail=0
IV.2. AdmisiÃ³n estricta al VoidPool

Un slot entra al pool solo si:

ğ‘‰
ğ‘œ
ğ‘–
ğ‘‘
ğ‘…
ğ‘’
ğ‘
ğ‘‘
ğ‘¦
(
ğ‘ 
)
=
ğ‘¡
ğ‘Ÿ
ğ‘¢
ğ‘’

âˆ§

(
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32
ğ‘ 

&

ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
)
â‰ 
0

âˆ§

ğ‘
ğ‘¡
ğ‘™
ğ‘
ğ‘ 
.
â„
ğ‘–
ğ‘‘
32
[
ğ‘ 
]
=
0
VoidReady(s)=true âˆ§ (Meta32
s
	â€‹

 & F
VOID_READY
	â€‹

)
î€ 
=0 âˆ§ atlas.hid32[s]=0

DICTAMEN: no se empuja al pool un slot con HID no-cero, ni con velocidad residual, ni con shock residual. El pool no es un â€œbasureroâ€; es una cÃ¡mara de vacÃ­o certificada.

ARTÃCULO V â€” Pipeline de Muerte (ALFA â†’ SIGMA/OMEGA â†’ OMEGA-ZERO)
V.1. Marcaje atÃ³mico y enfriamiento fÃ­sico

En delisting / muerte, se ejecuta:

ğ‘€
ğ‘’
ğ‘¡
ğ‘
32
ğ‘ 
â†
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32
ğ‘ 

âˆ¨

ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğ·
ğ¸
ğ´
ğ‘‡
ğ»
(
store release
)
Meta32
s
	â€‹

â†Meta32
s
	â€‹

 âˆ¨ F
PENDING_DEATH
	â€‹

(store release)

A partir de ese instante, el slot entra en enfriamiento (cooldown fÃ­sico) que garantiza convergencia a vacÃ­o.

Decaimiento (cerrado, estable en FP32)

Se imponen leyes de disipaciÃ³n acotadas:

ğ‘£
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ‘£
(
ğ‘¡
)
â‹…
ğ‘’
âˆ’
ğœ†
ğ‘£
Î”
ğ‘¡
v(t+Î”t)=v(t)â‹…e
âˆ’Î»
v
	â€‹

Î”t
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
(
ğ‘¡
)
â‹…
ğ‘’
âˆ’
ğœ†
ğ‘ 
Î”
ğ‘¡
shock(t+Î”t)=shock(t)â‹…e
âˆ’Î»
s
	â€‹

Î”t
ğ‘†
(
ğ‘¡
+
Î”
ğ‘¡
)
=
ğ‘†
(
ğ‘¡
)
â‹…
ğ‘’
âˆ’
ğœ†
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
Î”
ğ‘¡
S(t+Î”t)=S(t)â‹…e
âˆ’Î»
sent
	â€‹

Î”t

con saturaciÃ³n y clamps:

âˆ¥
ğ‘£
âˆ¥
â‰¤
ğ‘£
ğ‘š
ğ‘
ğ‘¥
,
âˆ£
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
âˆ£
â‰¤
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
ğ‘š
ğ‘
ğ‘¥
,
âˆ£
ğ‘†
âˆ£
â‰¤
1
âˆ¥vâˆ¥â‰¤v
max
	â€‹

,âˆ£shockâˆ£â‰¤shock
max
	â€‹

,âˆ£Sâˆ£â‰¤1

Regla TSD8: TSD8 avanza solo si el estado estÃ¡ bajo control:

ğ‘
ğ‘‘
ğ‘£
ğ‘
ğ‘›
ğ‘
ğ‘’
_
ğ‘¡
ğ‘ 
ğ‘‘
=
1
[
âˆ¥
ğ‘£
âˆ¥
â‰¤
ğ‘£
ğ‘”
ğ‘
ğ‘¡
ğ‘’
]
âˆ§
1
[
âˆ£
ğ‘ 
â„
ğ‘œ
ğ‘
ğ‘˜
âˆ£
â‰¤
ğ‘ 
ğ‘”
ğ‘
ğ‘¡
ğ‘’
]
âˆ§
1
[
âˆ£
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
8
âˆ£
â‰¤
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
ğ‘”
ğ‘
ğ‘¡
ğ‘’
]
advance_tsd=1[âˆ¥vâˆ¥â‰¤v
gate
	â€‹

]âˆ§1[âˆ£shockâˆ£â‰¤s
gate
	â€‹

]âˆ§1[âˆ£sent8âˆ£â‰¤sent
gate
	â€‹

]
V.2. Commit OMEGA-ZERO (punto Ãºnico)

Cuando VoidReady(s)=true:

Zero-fill del Atlas (streaming stores, sin locks).

ğ‘¥
â†
ğ‘¥
ğ‘£
ğ‘œ
ğ‘–
ğ‘‘
xâ†x
void
	â€‹

,
ğ‘£
â†
0
vâ†0, risk=shock=0.

Forzar TSD8=0xFF.

Limpiar flags de trÃ¡nsito y levantar
ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
F
VOID_READY
	â€‹

.

VoidPool.push(s).

DICTAMEN: existe un Ãºnico punto en el que un slot entra al vacÃ­o y se publica al pool. Ese commit es el â€œhorizonte de no retornoâ€ para la reencarnaciÃ³n (consistencia > sentimentalismo).

ARTÃCULO VI â€” Pipeline de Nacimiento (OMEGA-ZERO â†’ ALFA) con PREPARE/COMMIT
VI.1. Fase PREPARE (invisible, zero-copy)

s = VoidPool.pop() (si no hay, no nace nadie).

Marcar:

ğ‘€
ğ‘’
ğ‘¡
ğ‘
32
ğ‘ 
â†
ğ‘€
ğ‘’
ğ‘¡
ğ‘
32
ğ‘ 

âˆ¨

ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
(
release
)
Meta32
s
	â€‹

â†Meta32
s
	â€‹

 âˆ¨ F
PENDING_BIRTH
	â€‹

(release)

Generar UID64_new y validarlo con triple cerrojo (Art. II).

Escribir en Atlas:

ğ‘
ğ‘¡
ğ‘™
ğ‘
ğ‘ 
.
ğ‘¢
ğ‘–
ğ‘‘
64
[
ğ‘ 
]
â†
ğ‘ˆ
ğ¼
ğ·
64
ğ‘›
ğ‘’
ğ‘¤
,

ğ‘
ğ‘¡
ğ‘™
ğ‘
ğ‘ 
.
â„
ğ‘–
ğ‘‘
32
[
ğ‘ 
]
â†
ğ»
ğ¼
ğ·
32
ğ‘›
ğ‘’
ğ‘¤
,

ğ‘
ğ‘¡
ğ‘™
ğ‘
ğ‘ 
.
ğ‘‘
ğ‘›
ğ‘
32
[
ğ‘ 
]
â†
ğ·
ğ‘
ğ´
32
ğ‘›
ğ‘’
ğ‘¤
,

ğ‘
ğ‘¡
ğ‘™
ğ‘
ğ‘ 
.
ğ‘ 
ğ‘’
ğ‘›
ğ‘¡
8
[
ğ‘ 
]
â†
ğ‘†
ğ¸
ğ‘
ğ‘‡
8
ğ‘›
ğ‘’
ğ‘¤
atlas.uid64[s]â†UID64
new
	â€‹

, atlas.hid32[s]â†HID32
new
	â€‹

, atlas.dna32[s]â†DNA32
new
	â€‹

, atlas.sent8[s]â†SENT8
new
	â€‹


Inicializar estado fÃ­sico y visual mÃ­nimo.

Durante PREPARE el slot es invisible por branchless-skip.

VI.2. Spawn estable
ğ‘¥
ğ‘ 
ğ‘
ğ‘
ğ‘¤
ğ‘›
x
spawn
	â€‹

 (anti-explosiÃ³n local)

Se define el punto de nacimiento como centroide de la categorÃ­a + jitter acotado:

ğ‘¥
ğ‘ 
ğ‘
ğ‘
ğ‘¤
ğ‘›
=
ğ‘¥
ğ‘
ğ‘’
ğ‘›
ğ‘¡
ğ‘Ÿ
ğ‘œ
ğ‘–
ğ‘‘
(
ğ‘
ğ‘
ğ‘¡
)
+
ğ›¿
x
spawn
	â€‹

=x
centroid
	â€‹

(cat)+Î´
âˆ¥
ğ›¿
âˆ¥
â‰¤
ğ‘Ÿ
ğ‘ 
ğ‘
ğ‘
ğ‘¤
ğ‘›
âˆ¥Î´âˆ¥â‰¤r
spawn
	â€‹


donde:

ğ‘Ÿ
ğ‘ 
ğ‘
ğ‘
ğ‘¤
ğ‘›
=
ğ‘
ğ‘™
ğ‘–
ğ‘
(
ğ‘Ÿ
0
+
ğ›¼
ğœŒ
â‹…
ğœŒ
ğ‘
ğ‘
ğ‘¡
+
ğ›¼
Î£
â‹…
Î£
ğ‘ 
ğ‘¦
ğ‘ 
,

ğ‘Ÿ
ğ‘š
ğ‘–
ğ‘›
,
ğ‘Ÿ
ğ‘š
ğ‘
ğ‘¥
)
r
spawn
	â€‹

=clip(r
0
	â€‹

+Î±
Ï
	â€‹

â‹…Ï
cat
	â€‹

+Î±
Î£
	â€‹

â‹…Î£
sys
	â€‹

, r
min
	â€‹

,r
max
	â€‹

)

Birth-Shield durante
ğœ
ğ‘
ğ‘–
ğ‘Ÿ
ğ‘¡
â„
Ï„
birth
	â€‹

 ticks:

aumentar fricciÃ³n efectiva:

ğ›¾
â†
ğ›¾
â‹…
(
1
+
ğœ‚
ğ›¾
)
Î³â†Î³â‹…(1+Î·
Î³
	â€‹

)

reducir temperatura/ruido (si aplica Ley IV/V):

ğ‘‡
â†
ğ‘‡
â‹…
(
1
âˆ’
ğœ‚
ğ‘‡
)
Tâ†Tâ‹…(1âˆ’Î·
T
	â€‹

)

Objetivo: impedir explosiones de densidad y cascadas de fuerza al insertar masa nueva.

VI.3. Fase COMMIT (punto constitucional)

Orden exacto (sin ambigÃ¼edad):

Escribir Vertex28 del slot con estado inicial coherente (posiciÃ³n, risk/shock, meta).

Limpiar:

ğ‘€
ğ‘’
ğ‘¡
ğ‘
32

&
=
âˆ¼
ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
Meta32 &=âˆ¼F
PENDING_BIRTH
	â€‹


Limpiar:

ğ‘€
ğ‘’
ğ‘¡
ğ‘
32

&
=
âˆ¼
ğ¹
ğ‘‰
ğ‘‚
ğ¼
ğ·
_
ğ‘…
ğ¸
ğ´
ğ·
ğ‘Œ
Meta32 &=âˆ¼F
VOID_READY
	â€‹


Forzar STATE2=ALFA y TSD8=0.

Setear OracleState / flags (Ley VI) y LOD inicial (Ley III/IV).

Emitir evento lÃ³gico opcional EV_BIRTH(s) (fuera del hilo crÃ­tico si hay cola de eventos).

DICTAMEN: COMMIT es el primer instante en el que el slot vuelve a existir para fÃ­sica/render.

ARTÃCULO VII â€” ImplementaciÃ³n Bajo Nivel (C++/WASM): Lock-Free, Branchless, SIMD-Friendly

PseudocÃ³digo ejecutable-like. SemÃ¡ntica atÃ³mica estilo C++20. En WASM threads, usar atomics equivalentes.

VII.1. Constantes constitucionales
constexpr float X_VOID = 1.0e9f;
constexpr float EPS_KE = 1.0e-8f;
constexpr float EPS_S  = 1.0e-6f;
constexpr int   EPS_SENT = 1;

constexpr float V_GATE = 1.0e-3f;
constexpr float S_GATE = 1.0e-4f;
constexpr int   SENT_GATE = 1;

constexpr uint32_t TSD_MAX = 255;

VII.2. Meta32: masks LifeFlags (ubicaciÃ³n definida en Art. IX)

AquÃ­ asumimos que, en SIGMA/OMEGA, LifeFlags viven en FLAGS8 (bits 24..31).
Definimos bits dentro de ese byte:

// FLAGS8 (bits 24..31) sub-bits:
constexpr uint32_t F_VOID_READY      = 1u << 24; // bit0 del byte alto
constexpr uint32_t F_PENDING_BIRTH   = 1u << 25;
constexpr uint32_t F_PENDING_DEATH   = 1u << 26;
constexpr uint32_t F_ORPHAN_SHADOW   = 1u << 27;

// (otros bits 28..31 reservados para orÃ¡culo/transiciones)


Branchless skip unificado:

static inline uint32_t skip_mask(uint32_t meta){
  uint32_t f = meta & (F_ORPHAN_SHADOW | F_PENDING_BIRTH);
  // f!=0 => mask=0xFFFFFFFF else 0
  return (f | (0u - f)) >> 31 ? 0xFFFFFFFFu : 0u; // trick branchless
}

VII.3. VoidReady(s) (cerrado)
struct PhysState {
  float vx, vy, vz;
  float m;      // masa efectiva (puede venir de LUT DNA)
  float shock;
  int8_t sent8;
  uint32_t tsd8; // reconstruido desde meta o campo auxiliar
};

static inline float KE(const PhysState& p){
  float v2 = p.vx*p.vx + p.vy*p.vy + p.vz*p.vz;
  return 0.5f * p.m * v2;
}

static inline bool VoidReady(const PhysState& p){
  // TSD8==255 AND KE<=eps AND |shock|<=eps AND |sent8|<=eps_sent
  // shock abs branchless-ish:
  float absS = (p.shock < 0.f) ? -p.shock : p.shock;
  int absSent = (p.sent8 < 0) ? -p.sent8 : p.sent8;

  return (p.tsd8 == 255u) &
         (KE(p) <= EPS_KE) &
         (absS <= EPS_S) &
         (absSent <= EPS_SENT);
}

VII.4. VoidPool MPMC (push/pop lock-free con secuencia por celda)
static inline bool vpool_push(VoidPoolMPMC& Q, uint32_t slot){
  uint32_t pos = Q.tail.load(std::memory_order_relaxed);
  for(;;){
    Cell& c = Q.buf[pos & Q.mask];
    uint32_t seq = c.seq.load(std::memory_order_acquire);
    int32_t dif = (int32_t)seq - (int32_t)pos;
    if(dif == 0){
      if(Q.tail.compare_exchange_weak(pos, pos+1,
          std::memory_order_relaxed, std::memory_order_relaxed)){
        c.slot = slot;
        c.seq.store(pos+1, std::memory_order_release);
        return true;
      }
    } else if(dif < 0){
      return false; // cola llena
    } else {
      pos = Q.tail.load(std::memory_order_relaxed);
    }
  }
}

static inline bool vpool_pop(VoidPoolMPMC& Q, uint32_t& out_slot){
  uint32_t pos = Q.head.load(std::memory_order_relaxed);
  for(;;){
    Cell& c = Q.buf[pos & Q.mask];
    uint32_t seq = c.seq.load(std::memory_order_acquire);
    int32_t dif = (int32_t)seq - (int32_t)(pos+1);
    if(dif == 0){
      if(Q.head.compare_exchange_weak(pos, pos+1,
          std::memory_order_relaxed, std::memory_order_relaxed)){
        out_slot = c.slot;
        c.seq.store(pos + Q.cap, std::memory_order_release);
        return true;
      }
    } else if(dif < 0){
      return false; // cola vacÃ­a
    } else {
      pos = Q.head.load(std::memory_order_relaxed);
    }
  }
}


DICTAMEN: esta cola domina a Treiber en churn alto porque:

evita ABA por celda con secuencia,

evita contenciÃ³n por CAS en un Ãºnico puntero,

coste acotado y predecible.

VII.5. Death pipeline (tick-update + commit OMEGA-ZERO)
struct Atlas {
  uint64_t* uid64;
  uint32_t* hid32;
  uint32_t* dna32;
  int8_t*   sent8;
  uint32_t  cap;
};

struct VBOState {
  // arrays SoA internos (permitidos) que terminan en Vertex28 (Ley III)
  float* x; float* y; float* z;
  float* vx; float* vy; float* vz;
  float* risk; float* shock;
  std::atomic<uint32_t>* meta;
  // tsd8 puede reconstruirse de meta (multiplex) o guardarse SoA interno
  uint8_t* tsd8;
};

static inline void decay(float& v, float lambda, float dt){
  // aproximaciÃ³n cheap: exp2(-k*dt) o LUT; aquÃ­: exp2
  // exp2f es aceptable CPU; si se exige, usar LUT
  v *= exp2f(-lambda * dt * 1.4426950408889634f); // ln2^-1
}

static inline void death_update_slot(uint32_t s, Atlas& A, VBOState& P, float dt){
  uint32_t meta = P.meta[s].load(std::memory_order_relaxed);

  // si no pending_death, nada
  if((meta & F_PENDING_DEATH) == 0) return;

  // enfriamiento fÃ­sico
  decay(P.vx[s], 12.0f, dt); decay(P.vy[s], 12.0f, dt); decay(P.vz[s], 12.0f, dt);
  decay(P.shock[s], 10.0f, dt);

  // sentimiento: disipaciÃ³n simple
  int8_t sent = A.sent8[s];
  A.sent8[s] = UpdateSent(sent, dt, 4.0f);

  // avanzar TSD8 solo si gates ok
  float v2 = P.vx[s]*P.vx[s] + P.vy[s]*P.vy[s] + P.vz[s]*P.vz[s];
  float vabs = sqrtf(v2);
  float absShock = (P.shock[s] < 0.f) ? -P.shock[s] : P.shock[s];
  int absSent = (A.sent8[s] < 0) ? -A.sent8[s] : A.sent8[s];

  uint32_t adv = (vabs <= V_GATE) & (absShock <= S_GATE) & (absSent <= SENT_GATE);
  uint32_t t = P.tsd8[s];
  t = t + (adv & (t < 255u)); // branchless increment
  P.tsd8[s] = (uint8_t)t;

  // comprobar VoidReady
  PhysState ps;
  ps.vx=P.vx[s]; ps.vy=P.vy[s]; ps.vz=P.vz[s];
  ps.m=1.0f; // si se requiere, deriva de DNA LUT (Ley VII) o cache
  ps.shock=P.shock[s];
  ps.sent8=A.sent8[s];
  ps.tsd8=P.tsd8[s];

  if(!VoidReady(ps)) return;

  // COMMIT OMEGA-ZERO (punto Ãºnico)
  // 1) zero-fill atlas (streaming stores ideal)
  A.uid64[s] = 0;
  A.hid32[s] = 0;
  A.dna32[s] = 0;
  A.sent8[s] = 0;

  // 2) estado fÃ­sico al void
  P.x[s]=X_VOID; P.y[s]=X_VOID; P.z[s]=X_VOID;
  P.vx[s]=0.f; P.vy[s]=0.f; P.vz[s]=0.f;
  P.risk[s]=0.f; P.shock[s]=0.f;
  P.tsd8[s]=255u;

  // 3) meta flags: limpiar trÃ¡nsito, levantar VOID_READY
  uint32_t m2 = meta;
  m2 &= ~(F_PENDING_DEATH | F_PENDING_BIRTH | F_ORPHAN_SHADOW);
  m2 |= F_VOID_READY;
  P.meta[s].store(m2, std::memory_order_release);

  // push al VoidPool se hace fuera o aquÃ­ si tenemos acceso a Q (ver orquestador)
}

VII.6. Birth pipeline (PREPARE/COMMIT + HID generation)

Incluimos: RejectWindow_W, lookup_hid (Ley VII) y generaciÃ³n SipHash truncada (se muestra como stub).

struct RejectWindow {
  // ring de tamaÃ±o potencia de 2 con HID recientes (anti-replay)
  uint32_t* ring;
  uint32_t  mask;
  std::atomic<uint32_t> wptr;
};

static inline void reject_push(RejectWindow& W, uint32_t hid){
  uint32_t p = W.wptr.fetch_add(1, std::memory_order_relaxed);
  W.ring[p & W.mask] = hid;
}

static inline bool reject_contains(const RejectWindow& W, uint32_t hid){
  // O(W) serÃ­a caro; se recomienda bloom o hashing 2 niveles.
  // ConstituciÃ³n mÃ­nima: bloom64 + ring para debugging.
  // AquÃ­: stub => asumir bloom externo.
  return false;
}

// Stub SipHash->Trunc32
static inline uint32_t siphash_trunc32(uint64_t k0, uint64_t k1,
                                       uint16_t fam16, uint16_t ver16, uint32_t nonce32){
  uint64_t x = ((uint64_t)fam16<<48) ^ ((uint64_t)ver16<<32) ^ (uint64_t)nonce32;
  // no es SipHash real (placeholder); en implementaciÃ³n: SipHash-2-4
  x ^= k0; x = (x ^ (x>>33)) * 0xff51afd7ed558ccdULL;
  x ^= k1; x = (x ^ (x>>33)) * 0xc4ceb9fe1a85ec53ULL;
  x ^= (x>>33);
  return (uint32_t)x;
}

static inline uint16_t bump_epoch(uint16_t ver16){
  // VER16=[IDX12|EPOCH4]
  uint16_t idx = ver16 & 0xFFF0u;
  uint16_t ep  = ver16 & 0x000Fu;
  ep = (uint16_t)((ep + 1u) & 0x000Fu);
  return (uint16_t)(idx | ep);
}

static inline bool birth_prepare(uint32_t s,
                                 Atlas& A, VBOState& P,
                                 const CuckooTable& C,
                                 RejectWindow& W,
                                 uint64_t K0, uint64_t K1,
                                 uint16_t fam16,
                                 uint32_t dna32_new, int8_t sent8_new,
                                 uint32_t& out_hid32, uint64_t& out_uid64){
  // marcar pending birth
  uint32_t meta = P.meta[s].load(std::memory_order_relaxed);
  meta |= F_PENDING_BIRTH;
  P.meta[s].store(meta, std::memory_order_release);

  // ver16: bump epoch
  // (si el slot estÃ¡ vacÃ­o, ver16 puede residir en atlas auxiliar; aquÃ­ lo reconstruimos desde slot)
  uint16_t ver16 = (uint16_t)s; // ejemplo: idx en ver
  ver16 = bump_epoch(ver16);

  // generar HID con triple cerrojo (reintentos acotados)
  uint32_t hid = 0;
  uint32_t nonce = 0;
  for(int k=0;k<8;k++){ // 8 intentos acotados (O(1))
    nonce = mix32((uint32_t)(k) ^ (s<<16));
    hid = siphash_trunc32(K0, K1, fam16, ver16, nonce);
    hid |= 1u; // evitar 0 en promedio (si saliera 0, lo fuerza a impar; aÃºn validamos)
    bool ok = (hid != 0u) &
              (!reject_contains(W, hid)) &
              (!lookup_hid(C, hid).ok); // Ley VII
    if(ok){ break; }
    hid = 0;
  }
  if(hid == 0u) return false;

  // formar UID64
  uint64_t uid = ( (uint64_t)hid << 32 ) | ( (uint64_t)fam16 << 16 ) | (uint64_t)ver16;

  // escribir atlas (zero-copy)
  A.uid64[s] = uid;
  A.hid32[s] = hid;
  A.dna32[s] = dna32_new;
  A.sent8[s] = sent8_new;

  out_hid32 = hid;
  out_uid64 = uid;

  // inicializar estado fÃ­sico mÃ­nimo (spawn se aplica en orquestador)
  P.risk[s] = 0.f;
  P.shock[s] = SentToShock(sent8_new);
  P.vx[s]=P.vy[s]=P.vz[s]=0.f;
  P.tsd8[s]=0u;

  // registrar en reject window (anti-replay)
  reject_push(W, hid);
  return true;
}

static inline void birth_commit(uint32_t s, VBOState& P,
                                uint32_t meta_alfa_initial){
  // orden constitucional
  uint32_t meta = P.meta[s].load(std::memory_order_relaxed);

  meta &= ~F_PENDING_BIRTH;
  meta &= ~F_VOID_READY;
  meta &= ~F_PENDING_DEATH;
  meta &= ~F_ORPHAN_SHADOW;

  // fuerza STATE2=ALFA (00) sin tocar el resto (meta_alfa_initial ya trae campos de taxonomÃ­a/LOD/orÃ¡culo)
  meta = (meta & ~0x3u) | 0u;
  meta = meta_alfa_initial | (meta & (F_PENDING_BIRTH|F_VOID_READY|F_PENDING_DEATH|F_ORPHAN_SHADOW)); // normalmente 0

  P.tsd8[s]=0u;
  P.meta[s].store(meta, std::memory_order_release);
}

ARTÃCULO VIII â€” Modelo de Coste y Presupuesto de Rendimiento

La Ley VIII debe operar â€œdebajo del radarâ€ del frame budget, sin interferir con:

fÃ­sica (Ley IV),

densidad/dualidad y VBO streaming (Ley III),

inferencia/TSD (Ley V),

orÃ¡culo (Ley VI).

VIII.1. Coste de VoidReady y VoidPool
VoidReady(s) (por slot en muerte)

Operaciones dominantes:

3 mul + 2 add (vÂ²)

1 mul (0.5mvÂ²)

1â€“2 abs

4 comparaciones

3 AND lÃ³gicos

Coste tÃ­pico: 15â€“40 ciclos (depende de sqrt si se usa; recomendado: evitar sqrt y comparar vÂ²).

OptimizaciÃ³n constitucional: comparar
ğ‘£
2
v
2
 contra
ğ‘£
ğ‘”
ğ‘
ğ‘¡
ğ‘’
2
v
gate
2
	â€‹

 para eliminar sqrt:

ğ‘£
2
â‰¤
ğ‘£
ğ‘”
ğ‘
ğ‘¡
ğ‘’
2
v
2
â‰¤v
gate
2
	â€‹

VoidPool.push/pop (MPMC)

Dominantes:

1â€“2 CAS + 1 load seq + 1 store seq
Coste tÃ­pico (baja contenciÃ³n): 20â€“80 ciclos.
En contenciÃ³n, el coste crece, pero sigue acotado por bucles cortos y coherencia de cachÃ©.

VIII.2. Coste del pipeline de muerte

Por slot en trÃ¡nsito:

3 decays velocidad + 1 decay shock (multiplicaciones + LUT/exp2)

update sent8 (barato)

incremento TSD8 branchless

commit ocasional (zero-fill + stores)

Coste tÃ­pico por tick de slot moribundo: 60â€“180 ciclos.
Commit OMEGA-ZERO (evento raro): 200â€“800 ciclos (stores contiguos).

VIII.3. Coste del pipeline de nacimiento

Por nacimiento:

pop pool: 20â€“100 ciclos

1â€“8 intentos HID: hashing + 2-bucket lookup (Ley VII)

stores a Atlas + meta
Coste tÃ­pico: 500â€“3,000 ciclos por nacimiento (acotado, depende de lookup y L3).

VIII.4. Presupuestos fijos constitucionales (K_*)

DefÃ­nanse presupuestos por frame:

K_VOID_MANAGEMENT (push/pop + bookkeeping):

ğ¾
ğ‘‰
ğ‘‚
ğ¼
ğ·
â‰¤
0.20
 ms/frame
K
VOID
	â€‹

â‰¤0.20 ms/frame

K_DEATH_PIPELINE (enfriamiento + commits):

ğ¾
ğ·
ğ¸
ğ´
ğ‘‡
ğ»
â‰¤
0.35
 ms/frame
K
DEATH
	â€‹

â‰¤0.35 ms/frame

K_BIRTH_PIPELINE (prepare/commit + HID):

ğ¾
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
â‰¤
0.35
 ms/frame
K
BIRTH
	â€‹

â‰¤0.35 ms/frame

Total Ley VIII:

ğ¾
ğ‘‰
ğ¼
ğ¼
ğ¼
=
ğ¾
ğ‘‰
ğ‘‚
ğ¼
ğ·
+
ğ¾
ğ·
ğ¸
ğ´
ğ‘‡
ğ»
+
ğ¾
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
â‰¤
0.90
 ms/frame
K
VIII
	â€‹

=K
VOID
	â€‹

+K
DEATH
	â€‹

+K
BIRTH
	â€‹

â‰¤0.90 ms/frame
CÃ³mo se mantiene bajo carga (churn alto)

Rate-limit births por frame (cap de nacimientos):

ğ‘
ğ‘–
ğ‘Ÿ
ğ‘¡
â„
ğ‘ 
ğ‘“
ğ‘Ÿ
ğ‘
ğ‘š
ğ‘’
â‰¤
ğµ
ğ‘š
ğ‘
ğ‘¥
births
frame
	â€‹

â‰¤B
max
	â€‹


Backoff determinista si HID colisiona o RejectWindow bloquea.

Batch commits: acumular slots void-ready y empujar al pool en bloque para mejorar locality.

Branchless-skip: slots en PREPARE nunca entran a fÃ­sica/render costoso.

Sin realloc VBO: el pipeline no toca buffers, solo escribe posiciones/metas.

ARTÃCULO IX â€” ESPECIFICACIÃ“N BINARIA Y BITWISE (Meta32 Soberano para ReencarnaciÃ³n)

La Ley VIII fija exactamente cÃ³mo se codifica vida/muerte/vacÃ­o sin romper Vertex28.

IX.1. Meta32 dual (ALFA vs SIGMA/OMEGA)

Bits 0..1: STATE2 (universal)

Layout ALFA (STATE2=00): taxonomÃ­a+LOD+orÃ¡culo+flags

0..1: STATE2

2..5: GROUP4

6..9: SUBGROUP4

10..15: CATEGORY6

16..17: IS2

18..19: PH2

20..23: LOD4

24..27: ORACLE4

28..31: FLAGS4 (incluye LifeFlags comprimidos)

LifeFlags en ALFA (FLAGS4):

bit 28: F_PENDING_DEATH_A (equivalente a pending_death)

bit 29: F_ORPHAN_SHADOW_A

bit 30: reservado

bit 31: reservado

En ALFA no existe VOID_READY ni PENDING_BIRTH por definiciÃ³n: un slot vivo no es reclamable y no estÃ¡ en prepare.

Layout SIGMA/OMEGA (STATE2â‰ 00): TSD+cooldown+flags

0..1: STATE2

2..9: TSD8

10..15: CLUSTER_CRIT6

16..23: COOLDOWN_T8

24..31: FLAGS8 (aquÃ­ viven LifeFlags completos)

LifeFlags en SIGMA/OMEGA (FLAGS8 bits 24..31):

bit 24: F_VOID_READY

bit 25: F_PENDING_BIRTH

bit 26: F_PENDING_DEATH

bit 27: F_ORPHAN_SHADOW

bits 28..31: TRANS4/ORACLE4 (reservado por Ley VI + transiciones internas)

IX.2. MÃ¡scaras compuestas
constexpr uint32_t M_STATE2    = 0x00000003u;

// SIGMA/OMEGA
constexpr uint32_t M_TSD8      = 0x000003FCu; // 2..9
constexpr uint32_t M_CRIT6     = 0x0000FC00u; // 10..15
constexpr uint32_t M_COOL8     = 0x00FF0000u; // 16..23
constexpr uint32_t M_FLAGS8    = 0xFF000000u; // 24..31

// LifeFlags (SIGMA/OMEGA)
constexpr uint32_t F_VOID_READY    = 1u<<24;
constexpr uint32_t F_PENDING_BIRTH = 1u<<25;
constexpr uint32_t F_PENDING_DEATH = 1u<<26;
constexpr uint32_t F_ORPHAN_SHADOW = 1u<<27;

constexpr uint32_t M_LIFE_ANY = (F_VOID_READY|F_PENDING_BIRTH|F_PENDING_DEATH|F_ORPHAN_SHADOW);

IX.3. Reglas branchless para manipulaciÃ³n
Set/Clear sin branches
ğ‘š
ğ‘’
ğ‘¡
ğ‘
â†
(
ğ‘š
ğ‘’
ğ‘¡
ğ‘

&

âˆ¼
ğ‘š
ğ‘
ğ‘ 
ğ‘˜
)

âˆ£

(
ğ‘£
ğ‘
ğ‘™
ğ‘¢
ğ‘’

&

ğ‘š
ğ‘
ğ‘ 
ğ‘˜
)
metaâ†(meta & âˆ¼mask)  âˆ£  (value & mask)
static inline uint32_t bit_set(uint32_t meta, uint32_t f){ return meta | f; }
static inline uint32_t bit_clr(uint32_t meta, uint32_t f){ return meta & ~f; }

static inline uint32_t set_if(uint32_t meta, uint32_t f, uint32_t cond01){
  // cond01: 0 o 1
  uint32_t m = 0u - cond01; // 0x000..0 o 0xFFF..F
  return meta | (f & m);
}

Skip mask unificada
ğ‘†
ğ¾
ğ¼
ğ‘ƒ
=
1
[
(
ğ‘š
ğ‘’
ğ‘¡
ğ‘
&
(
ğ¹
ğ‘‚
ğ‘…
ğ‘ƒ
ğ»
ğ´
ğ‘
_
ğ‘†
ğ»
ğ´
ğ·
ğ‘‚
ğ‘Š
âˆ¨
ğ¹
ğ‘ƒ
ğ¸
ğ‘
ğ·
ğ¼
ğ‘
ğº
_
ğµ
ğ¼
ğ‘…
ğ‘‡
ğ»
)
)
â‰ 
0
]
SKIP=1[(meta&(F
ORPHAN_SHADOW
	â€‹

âˆ¨F
PENDING_BIRTH
	â€‹

))
î€ 
=0]

y se convierte a mÃ¡scara:

static inline uint32_t to_mask_nonzero(uint32_t x){
  return ((x | (0u - x)) >> 31) ? 0xFFFFFFFFu : 0u;
}

AXIOMA FINAL
En TITAN V8, la muerte no es el fin, sino una transici
o
ËŠ
n ordenada hacia el vac
Ä±
ËŠ
o.
En TITAN V8, la muerte no es el fin, sino una transici
o
ËŠ
n ordenada hacia el vac
Ä±
ËŠ
o.
	â€‹

La identidad se recicla de forma segura y eficiente, garantizando estabilidad y reutilizaci
o
ËŠ
n de slots sin bloqueos ni reasignaciones.
La identidad se recicla de forma segura y eficiente, garantizando estabilidad y reutilizaci
o
ËŠ
n de slots sin bloqueos ni reasignaciones.
	â€‹

N=200,000 es constante; no hay creaci
o
ËŠ
n/destrucci
o
ËŠ
n de slots, solo transmutaci
o
ËŠ
n de identidad bajo O(1), lock-free y Vertex28 inmutable.
N=200,000 es constante; no hay creaci
o
ËŠ
n/destrucci
o
ËŠ
n de slots, solo transmutaci
o
ËŠ
n de identidad bajo O(1), lock-free y Vertex28 inmutable.

LEY IX â€” La Masa MÃ­nima
Horizonte de Eventos, EntropÃ­a de Bekensteinâ€“Hawking Informacional y Singularidades SistÃ©micas

Tabla de Contenidos

1. Ãmbito
2. ARTÃCULO I â€” EnergÃ­a Informacional E_i(t): definiciÃ³n, componentes, pesos, normalizaciÃ³n y clamps
3. ARTÃCULO II â€” Umbral crÃ­tico E_crit: Horizonte de Eventos, flags Meta32, histÃ©resis y salida controlada
4. ARTÃCULO III â€” DinÃ¡mica Post-Horizonte: colapso, disipaciÃ³n, entropÃ­a BH y radiaciÃ³n Hawking informacional
5. ARTÃCULO IV â€” Curvatura del Manifold y PercepciÃ³n: Î©â€², distorsiÃ³n visual, fuerza efectiva e inaccesibilidad informacional
6. ARTÃCULO V â€” Singularidades SistÃ©micas: detecciÃ³n, contenciÃ³n (Ley VI) y purga masiva (Ley VIII)
7. ARTÃCULO VI â€” ImplementaciÃ³n bajo nivel C++/WASM + GPU: pseudocÃ³digo ejecutable (lock-free, branchless, SIMD-friendly)
8. ARTÃCULO VII â€” Modelo de coste y presupuestos K*: garantÃ­a bajo estrÃ©s extremo
9. ARTÃCULO VIII â€” EspecificaciÃ³n binaria y bitwise: Meta32 soberano para Horizonte / Singularidad
10. ARTÃCULO I â€” La EnergÃ­a Informacional E_i(t) (Masa MÃ­nima)
11. ARTÃCULO II â€” E_crit y Horizonte de Eventos
12. ARTÃCULO III â€” DinÃ¡mica Post-Horizonte
13. ARTÃCULO IV â€” Curvatura del Manifold y PercepciÃ³n
14. ARTÃCULO V â€” Singularidades SistÃ©micas y PrevenciÃ³n
15. ARTÃCULO VI â€” ImplementaciÃ³n bajo nivel (C++/WASM + GPU)
16. ARTÃCULO VII â€” Modelo de coste y presupuestos (K_*)
17. ARTÃCULO VIII â€” EspecificaciÃ³n binaria y bitwise (Meta32 soberano)
18. AXIOMA FINAL

Ãmbito
Mandato Operativo

LEY IX â€” La Masa MÃ­nima

(EnergÃ­a Informacional E_i, Colapso Determinista, Curvatura del Manifold y ProtecciÃ³n del Universo N=200,000)

ARTÃCULO I â€” EnergÃ­a Informacional E_i(t): definiciÃ³n, componentes, pesos, normalizaciÃ³n y clamps
ARTÃCULO II â€” Umbral crÃ­tico E_crit: Horizonte de Eventos, flags Meta32, histÃ©resis y salida controlada
ARTÃCULO III â€” DinÃ¡mica Post-Horizonte: colapso, disipaciÃ³n, entropÃ­a BH y radiaciÃ³n Hawking informacional
ARTÃCULO IV â€” Curvatura del Manifold y PercepciÃ³n: Î©â€², distorsiÃ³n visual, fuerza efectiva e inaccesibilidad informacional
ARTÃCULO V â€” Singularidades SistÃ©micas: detecciÃ³n, contenciÃ³n (Ley VI) y purga masiva (Ley VIII)
ARTÃCULO VI â€” ImplementaciÃ³n bajo nivel C++/WASM + GPU: pseudocÃ³digo ejecutable (lock-free, branchless, SIMD-friendly)
ARTÃCULO VII â€” Modelo de coste y presupuestos K*: garantÃ­a bajo estrÃ©s extremo
ARTÃCULO VIII â€” EspecificaciÃ³n binaria y bitwise: Meta32 soberano para Horizonte / Singularidad
AXIOMA FINAL

Ãmbito

La LEY IX es el mecanismo constitucional final que impide el colapso del universo bajo estrÃ©s informacional. TITAN V8 opera con:

N = 200,000 (constante)
Î”t_frame = 16.67 ms

y con un bus visual inmutable:

Vertex28 (stride 28 bytes) + Meta32 (re-interpretado)

Dogma: en TITAN V8, la â€œverdadâ€ no se mide por exactitud externa, sino por estabilidad interna bajo presupuesto fijo. La Masa MÃ­nima es el â€œfreno gravitacionalâ€ que:

evita explosiones numÃ©ricas (Ley IV),
amortigua contagios y memoria (Ley V),
se alimenta del OrÃ¡culo (Ley VI),
se codifica en Meta32 (Ley VII),
y desemboca en purga/reencarnaciÃ³n cuando el universo lo exige (Ley VIII).

IntegraciÃ³n estricta con Leyes Iâ€“VIII (sin bytes nuevos)

Ley I (Identidad): un activo en horizonte sigue existiendo (UID vÃ¡lido) pero su informaciÃ³n es opaca para afinidad/contagio.
Ley II (Nacimiento): el nacimiento nunca puede â€œnacerâ€ dentro del horizonte: Birth-Shield prohÃ­be E_i alto en Ï„_birth.
Ley III (Dualidad y Densidad): E_i actÃºa como densidad informacional: a mayor E, mayor curvatura efectiva.
Ley IV (Manifold/Langevin): el horizonte modifica Î© y el solver: fuerzas y movilidad se curvan por un potencial de horizonte.
Ley V (Persistencia temporal): el horizonte usa los mismos bits (Meta32) y el mismo paradigma TSD/HSD (tiempo codificado en 8 bits).
Ley VI (OrÃ¡culo): el volumen verdadero V_i^T(t) y penalizaciones adversariales son insumos de E_i(t).
Ley VII (Atlas): no existe string. La opacidad se implementa por flags + reglas de acceso.
Ley VIII (ReencarnaciÃ³n): singularidades sistÃ©micas disparan purga acelerada a OMEGA-ZERO y reciclaje seguro.

Mandato Operativo

Bajo formaciÃ³n de horizontes y singularidades:

Estabilidad numÃ©rica: no explotan risk/shock, no hay NaNs, no hay energÃ­as negativas â€œabsurdasâ€.
Estabilidad visual: transiciÃ³n al horizonte sin micro-stutter, sin â€œpantalla negraâ€.
Estabilidad ontolÃ³gica: UID/VER16 anti-ABA intactos; no hay â€œdoble vidaâ€ de un slot.
Presupuesto fijo: la Ley IX opera dentro de K* (Art. VII) sin robar tiempo a FÃ­sica/Render.

ARTÃCULO I â€” La EnergÃ­a Informacional E_i(t) (Masa MÃ­nima)

I.1. DefiniciÃ³n formal

Se define la energÃ­a informacional del activo i como:

E_i(t) = (1/Îº_i(t)) (w_V V~_i^T(t) + w_Î£ Î£~_i(t) + w_R R~_i(t))

donde:

V~_i^T(t): volumen verdadero normalizado (Ley VI).
Î£~_i(t): volatilidad normalizada (Ley IV).
R~_i(t): riesgo sistÃ©mico normalizado (Ley IV/V/VI).
Îº_i(t): liquidez efectiva (Ley IV/VII/VI).
w_V, w_Î£, w_R: constantes de silicio (Art. I.3).

DICTAMEN: E_i(t) es la masa mÃ­nima computable que decide si el activo debe entrar en horizonte.

I.2. Componentes: origen y cÃ¡lculo constitucional

(a) Volumen verdadero V~_i^T(t) (Ley VI â†’ Ley IX)

El OrÃ¡culo define V_i^T(t) filtrado por disputa, flash y spoofing. La Ley IX exige una normalizaciÃ³n robusta:

V~_i^T(t) = sat[0,1]((log(1+V_i^T(t)) âˆ’ Î¼_V)/(Ïƒ_V + Îµ_V))

Î¼_V, Ïƒ_V: estimadores robustos por familia/categorÃ­a (NodeAgg).
Îµ_V: constante de silicio.

DICTAMEN: sin OrÃ¡culo no hay volumen verdadero; por tanto V_T es la Ãºnica entrada vÃ¡lida.

(b) Volatilidad Î£~_i(t) (Ley IV â†’ Ley IX)

Î£_i(t) = EMA_{Ï„_Î£}(Î”p_i(t)^2)
Î£~_i(t) = sat[0,1]((Î£_i(t) âˆ’ Î£_min)/(Î£_max âˆ’ Î£_min))

DICTAMEN: si el feed estÃ¡ en cuarentena, Î”p_i se sustituye por predicciÃ³n del OrÃ¡culo para no contaminar Î£.

(c) Riesgo sistÃ©mico R~_i(t) (Ley IV/V/VI â†’ Ley IX)

R_i(t) = sat[0,R_max](Î±_r risk_i(t) + Î±_s |shock_i(t)| + Î±_h H_cat(i)(t))
R~_i(t) = sat[0,1](R_i(t)/R_max)

DICTAMEN: R_i debe ser monotÃ³nico con risk y |shock|.

(d) Liquidez Îº_i(t) (Ley VII/VI/IV â†’ Ley IX)

Îº_i(t) = Îº_DNA(i)â‹…Îº_depth(i,t)â‹…Îº_uptime(t)

Forma robusta:

Îº_i(t)=sat[Îº_min,Îº_max](Îº_0 + a_1 log(1+d_i(t)) âˆ’ a_2 A_i(t))

DICTAMEN: Îº_i(t) â‰¥ Îº_min > 0. El denominador jamÃ¡s puede ser cero.

I.3. Pesos constitucionales w_V, w_Î£, w_R

w_V=0.35, w_Î£=0.25, w_R=0.40

DICTAMEN: los pesos no se auto-ajustan en hot loop.

I.4. NormalizaciÃ³n, clamps y anti-explosiÃ³n

E_i_raw(t)=(1/max(Îº_i(t),Îº_min))(w_V V~_i^T + w_Î£ Î£~_i + w_R R~_i)
E_i(t)=clamp(E_i_raw(t),E_min,E_max)

E_min=0, E_max=8
Îº_i(t)â†max(Îº_i(t),Îº_min), Îº_min=10^{-3}

ARTÃCULO II â€” E_crit y Horizonte de Eventos

E_crit=3.2

CondiciÃ³n de entrada:

E_i(t) â‰¥ E_crit

HistÃ©resis de salida:

E_exit = E_crit(1âˆ’h), h=0.15
COOLDOWN_T âˆˆ [0,255]

Salida solo si:

E_i(t) â‰¤ E_exit âˆ§ COOLDOWN_T=0 âˆ§ F_SING_CORE=0

ARTÃCULO III â€” DinÃ¡mica Post-Horizonte

dx_i/dt = âˆ’Î±_H (x_i âˆ’ x_sing)
x_i(t+Î”t)=x_i(t)+(1âˆ’e^{âˆ’Î±_HÎ”t})(x_singâˆ’x_i(t))
Î±_H = 2.5 s^{-1}

III.2. DisipaciÃ³n:

KE_i(t+Î”t)=KE_i(t)e^{âˆ’Î»_KEÎ”t}
S_i(t+Î”t)=S_i(t)e^{âˆ’Î»_SÎ”t}
Î»_KE=6.0 s^{-1}, Î»_S=3.0 s^{-1}

III.3. EntropÃ­a BH:

r_{H,i}=r_0+Î±_r log(1+(E_i(t)âˆ’E_crit)/(E_crit+Îµ_E))_+
A_i=4Ï€ r_{H,i}^2
S_{BH,i}=k_I A_i /(4â„“_I^2)
k_I=1, â„“_I=0.25, r_0=0.6, Î±_r=0.9

III.4. RadiaciÃ³n Hawking:

Î¦_H(x,t)=Î£_{iâˆˆH} Ï‰_i(t) K(||xâˆ’x_i||/r_{H,i})
Ï‰_i(t)=Ï‰_0 e^{âˆ’t_{H,i}/Ï„_H}
K(u)=exp2(âˆ’u^2)

shock_j â† shock_j + Î·_H Î¦_H(x_j,t)â‹…sign(shock_j)
shock_j â† clamp(shock_j, âˆ’shock_max, shock_max)

ARTÃCULO IV â€” Curvatura del Manifold y PercepciÃ³n

Î©â€²(x,t;a)=Î©(x,t;a)â‹…(1+Î²_H Î¦_H(x,t))
Î²_H=0.35

F_eff=F/Î©â€²
Î¼_eff=Î¼â‹…1/(1+Î²_H Î¦_H)

Opacidad:

if (Meta32_i & F_INFO_LOST)!=0 â‡’ excluir de reducciones y lookups externos.

ARTÃCULO V â€” Singularidades SistÃ©micas y PrevenciÃ³n

Ï_E(x,t)=Î£_i E_i(t) W(||xâˆ’x_i||/r_Ï)
W(u)=max(0,1âˆ’u)^2
Ï_crit=18

Purga masiva si:

|H_cell| â‰¥ H_crit o Ï_E â‰¥ Ï_panic
H_crit=256, Ï_panic=28

ARTÃCULO VI â€” ImplementaciÃ³n bajo nivel (C++/WASM + GPU)

VI.1. Estructuras SoA mÃ­nimas (sin romper Vertex28)

```cpp
struct SoA {
  float* x; float* y; float* z;
  float* vx; float* vy; float* vz;
  float* risk; float* shock;
  float* sigma;     // volatilidad cacheada (actualiza lento)
  float* kappa;     // liquidez cacheada (actualiza lento)
  float* Vtrue;     // volumen verdadero (orÃ¡culo)
  float* E;         // energÃ­a informacional (buffer)
  uint8_t* hsd8;    // "Horizon Since Detection" (multiplex TSD8 en meta)
  std::atomic<uint32_t>* meta;
};

struct GridPotential {
  // textura/tabla por celdas (CPU o GPU)
  float* phi;        // Î¦_H por celda
  float* rhoE;       // Ï_E por celda
  uint32_t W, H;     // dims
};
```

VI.2. CÃ¡lculo SIMD-friendly de E_i(t) (branchless)

```cpp
constexpr float Ecrit = 3.2f;
constexpr float Emin = 0.f, Emax = 8.f;
constexpr float kappa_min = 1.0e-3f;

constexpr float wV = 0.35f, wS = 0.25f, wR = 0.40f;
constexpr float Rmax = 4.0f;

static inline float sat01(float x){ return x<0.f?0.f:(x>1.f?1.f:x); }
static inline float clampf(float x,float a,float b){ return x<a?a:(x>b?b:x); }

static inline float fast_log1p(float x){
  // constituciÃ³n: LUT o aproximaciÃ³n; aquÃ­ placeholder
  return log1pf(x);
}

static inline float Vnorm(float V){
  float z = 0.22f * fast_log1p(V) - 0.45f; // ejemplo
  return sat01(z);
}

static inline float SigNorm(float s){
  return sat01((s - 0.01f) * 0.25f); // ejemplo: (s-min)/(max-min)
}

static inline float RiskEff(float risk, float shock, float Hcat){
  float a = 0.55f*risk + 0.35f*fabsf(shock) + 0.10f*Hcat;
  return clampf(a, 0.f, Rmax);
}

static inline float Rnorm(float R){ return sat01(R / Rmax); }

void energy_kernel(SoA& P, const float* Hcat, uint32_t N){
  // Hcat: hazard/memoria por categorÃ­a ya reducido (Ley V)
  for(uint32_t i=0;i<N;i++){
    uint32_t meta = P.meta[i].load(std::memory_order_relaxed);

    // skip branchless: si ORPHAN o PENDING_BIRTH, energÃ­a = 0
    uint32_t skip = ((meta & (1u<<27 /*F_ORPHAN_SHADOW*/))!=0) |
                    ((meta & (1u<<25 /*F_PENDING_BIRTH*/))!=0);
    if(skip){ P.E[i]=0.f; continue; }

    float k = P.kappa[i];
    k = (k < kappa_min) ? kappa_min : k;

    float Vt = Vnorm(P.Vtrue[i]);
    float Sg = SigNorm(P.sigma[i]);
    float R  = Rnorm(RiskEff(P.risk[i], P.shock[i], Hcat[/*cat(i)*/0]));

    float Eraw = (wV*Vt + wS*Sg + wR*R) / k;
    P.E[i] = clampf(Eraw, Emin, Emax);
  }
}
```

VI.3. Entrada a horizonte: actualizaciÃ³n bitwise de Meta32 (latched)

```cpp
constexpr uint32_t F_HORIZON   = 1u << 28;
constexpr uint32_t F_SING_CORE = 1u << 29;
constexpr uint32_t F_INFO_LOST = 1u << 30;

constexpr uint32_t F_PENDING_DEATH = 1u<<26;

static inline uint32_t set_state_sigma(uint32_t meta){
  // STATE2 bits 0..1 = 01
  return (meta & ~0x3u) | 0x1u;
}

static inline uint32_t pack_tsd8(uint32_t meta, uint8_t tsd){
  // bits 2..9
  meta &= ~0x000003FCu;
  meta |= (uint32_t(tsd) << 2);
  return meta;
}

static inline uint32_t pack_cool8(uint32_t meta, uint8_t t){
  // bits 16..23
  meta &= ~0x00FF0000u;
  meta |= (uint32_t(t) << 16);
  return meta;
}

void horizon_latch(SoA& P, uint32_t N){
  for(uint32_t i=0;i<N;i++){
    uint32_t meta = P.meta[i].load(std::memory_order_relaxed);

    uint32_t inH = (meta & F_HORIZON) != 0;
    uint32_t hit = (P.E[i] >= 3.2f); // Ecrit

    // latch: si hit y no inH => entrar
    if(hit && !inH){
      meta = set_state_sigma(meta);
      meta |= (F_HORIZON | F_INFO_LOST); // por defecto opaco
      meta = pack_tsd8(meta, 0);         // HSD8=0
      meta = pack_cool8(meta, 255);      // cooldown mÃ¡ximo
      P.meta[i].store(meta, std::memory_order_release);
    }
  }
}
```

VI.4. DinÃ¡mica post-horizonte y potencial de curvatura (Î¦_H)

```cpp
static inline uint8_t inc_sat_u8(uint8_t x){ return (x==255)?255:uint8_t(x+1); }

void horizon_update(SoA& P, GridPotential& G, uint32_t N, float dt){
  // (1) limpiar grid
  memset(G.phi, 0, sizeof(float)*G.W*G.H);
  memset(G.rhoE,0, sizeof(float)*G.W*G.H);

  // (2) recorrer activos y acumular potencial por celda (aprox)
  for(uint32_t i=0;i<N;i++){
    uint32_t meta = P.meta[i].load(std::memory_order_relaxed);
    if((meta & F_HORIZON)==0) continue;

    // HSD8 vive en bits 2..9 cuando F_HORIZON=1 (multiplex)
    uint8_t hsd = uint8_t((meta >> 2) & 0xFFu);
    hsd = inc_sat_u8(hsd);
    meta = (meta & ~0x000003FCu) | (uint32_t(hsd) << 2);

    // disipaciÃ³n suave
    P.vx[i] *= 0.85f; P.vy[i] *= 0.85f; P.vz[i] *= 0.85f;
    P.shock[i] *= 0.90f;
    // colapso a centro por celda/categorÃ­a (simplificado aquÃ­)
    float xs = 0.f, ys = 0.f, zs = 0.f;
    float a = 1.f - exp2f(-2.5f*dt*1.4426950409f);
    P.x[i] += a*(xs - P.x[i]);
    P.y[i] += a*(ys - P.y[i]);
    P.z[i] += a*(zs - P.z[i]);

    // acumular en grid (celda)
    uint32_t cx = uint32_t(P.x[i]) & (G.W-1);
    uint32_t cy = uint32_t(P.y[i]) & (G.H-1);
    uint32_t idx = cy*G.W + cx;

    G.phi[idx]  += 0.12f * exp2f(-float(hsd)/90.f); // Ï‰_i(t)
    G.rhoE[idx] += P.E[i];

    P.meta[i].store(meta, std::memory_order_release);
  }

  // (3) suavizado local de grid (3x3) para Î¦_H y Ï_E (barato)
  // (no mostrado completo)
}
```

VI.5. Shader: distorsiÃ³n por horizonte (WebGL2-friendly)

```glsl
// sampler2D uPhiTex;   // Î¦_H por celdas
// uniform float betaH;

void applyLensing(inout vec2 uv, vec2 gradPhi){
  uv += 0.015 * gradPhi; // lente suave
}

void main(){
  vec2 uv = vUV;
  float phi = texture(uPhiTex, uv).r;
  // grad approx (2 taps)
  float phi_x = texture(uPhiTex, uv + vec2(1.0/texW,0)).r - phi;
  float phi_y = texture(uPhiTex, uv + vec2(0,1.0/texH)).r - phi;
  vec2 gradPhi = vec2(phi_x, phi_y);

  applyLensing(uv, gradPhi);

  vec4 col = texture(uScene, uv);
  // oscurecimiento + aberraciÃ³n leve
  col.rgb *= (1.0 / (1.0 + betaH * phi));
  col.r += 0.03 * phi; col.b -= 0.03 * phi;

  outColor = col;
}
```

ARTÃCULO VII â€” Modelo de coste y presupuestos (K_*)

K_IX â‰¤ 1.35 ms/frame
K_ENERGY_CALC â‰¤ 0.55 ms
K_HORIZON_DYNAMICS â‰¤ 0.35 ms
K_MANIFOLD_DISTORTION â‰¤ 0.45 ms

ARTÃCULO VIII â€” EspecificaciÃ³n binaria y bitwise (Meta32 soberano)

Layout SIGMA/OMEGA:

0..1: STATE2
2..9: TSD8 o HSD8 si F_HORIZON=1
10..15: CLUSTER_CRIT6
16..23: COOLDOWN_T8
24..27: LifeFlags (Ley VIII)
28: F_HORIZON
29: F_SING_CORE
30: F_INFO_LOST
31: reservado

MÃ¡scaras:

M_STATE2 = 0x00000003
M_TSD8   = 0x000003FC
M_COOL8  = 0x00FF0000
M_FLAGS8 = 0xFF000000

LifeFlags:

F_VOID_READY      = 1u<<24
F_PENDING_BIRTH   = 1u<<25
F_PENDING_DEATH   = 1u<<26
F_ORPHAN_SHADOW   = 1u<<27

Flags Ley IX:

F_HORIZON         = 1u<<28
F_SING_CORE       = 1u<<29
F_INFO_LOST       = 1u<<30

ManipulaciÃ³n branchless (ejemplo):

```cpp
// cond01 = (E>=Ecrit) & !inH
uint32_t cond01 = (P.E[i] >= Ecrit) & ((meta & F_HORIZON)==0);
uint32_t m = 0u - cond01; // 0 o 0xFFFFFFFF

meta = (meta & ~0x3u) | (1u & m) | (meta & 0x3u & ~m); // STATE2->SIGMA si cond
meta |= (F_HORIZON & m);
meta |= (F_INFO_LOST & m);

// salida
uint32_t cool = (meta >> 16) & 0xFFu;
uint32_t canExit = (P.E[i] <= Eexit) & (cool==0) & ((meta & F_SING_CORE)==0);
uint32_t me = 0u - canExit;
meta &= ~(F_HORIZON & me);
meta &= ~(F_INFO_LOST & me);
```

AXIOMA FINAL

En TITAN V8, la informaciÃ³n es masa y la masa curva el manifold.
Cuando E_i(t) â‰¥ E_crit, se forma un Horizonte de Eventos: la informaciÃ³n se vuelve opaca,
la entropÃ­a crece como S_BH âˆ A, y la curvatura inducida protege al universo de singularidades no controladas.
Si las singularidades se agrupan, la Ley VIII ejecuta la purga: se sacrifica informaciÃ³n local para salvar la estabilidad global.
