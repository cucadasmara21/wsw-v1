# scripts/seed_galaxy.py
from __future__ import annotations

import argparse
import math
import random
from typing import List, Dict

from sqlalchemy import text
from database import SessionLocal


def pack_meta32(risk_0_127: int, shock_0_127: int, trend_0_3: int) -> int:
    """
    meta32 layout (simple, stable, WebGL-friendly):
    bits 31..25: risk (7 bits)
    bits 24..18: shock (7 bits)
    bits 17..16: trend (2 bits) 0 flat, 1 bull, 2 bear
    bits 15..0 : phase (16 bits) (temporal offset / noise)
    """
    risk = max(0, min(127, int(risk_0_127)))
    shock = max(0, min(127, int(shock_0_127)))
    trend = max(0, min(3, int(trend_0_3)))
    phase = random.randint(0, 65535)
    return ((risk & 0x7F) << 25) | ((shock & 0x7F) << 18) | ((trend & 0x03) << 16) | (phase & 0xFFFF)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--n", type=int, default=10000)
    ap.add_argument("--force", action="store_true", help="Delete existing assets before seeding")
    args = ap.parse_args()

    db = SessionLocal()

    # If assets already exist and not forced, do nothing.
    existing = db.execute(text("SELECT COUNT(*) FROM assets")).scalar() or 0
    if existing > 0 and not args.force:
        print(f"assets already has {existing} rows; refusing to seed without --force")
        return

    if args.force:
        print("FORCE enabled: deleting existing assets...")
        db.execute(text("DELETE FROM assets"))
        db.commit()

    # 6 “Monoliths” / clusters (0..5). Values are in [0,1] because points.bin expects that.
    centroids = [
        (0.22, 0.22),
        (0.78, 0.22),
        (0.50, 0.50),
        (0.22, 0.78),
        (0.78, 0.78),
        (0.50, 0.18),
    ]

    # Titan taxonomy32 (clustered): top 8 bits = monolith id (1..6),
    # next 8 bits = cluster id (0..255), remaining can be noise for later.
    # This produces visible “galaxies” and later helps causal buckets.
    def make_taxonomy32(monolith: int, cluster8: int) -> int:
        m = max(1, min(6, monolith)) & 0xFF
        c = cluster8 & 0xFF
        tail = random.randint(0, 0xFFFF)  # optional entropy
        return (m << 24) | (c << 16) | tail

    rows: List[Dict] = []
    n = int(args.n)

    print(f"Seeding {n} synthetic assets...")
    for i in range(n):
        monolith_idx = random.randint(0, 5)
        cx, cy = centroids[monolith_idx]

        # Gaussian cloud around centroid
        x = cx + random.gauss(0, 0.06)
        y = cy + random.gauss(0, 0.06)

        # Clamp to [0,1]
        x = 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)
        y = 0.0 if y < 0.0 else (1.0 if y > 1.0 else y)

        # Semantics: risk higher near “outer” rings, shock spikes randomly
        dx = x - cx
        dy = y - cy
        r = math.sqrt(dx * dx + dy * dy)

        risk = int(min(127, max(0, (r / 0.12) * 127)))
        shock = 0
        if random.random() < 0.02:
            shock = random.randint(60, 127)

        # trend: bull/bear bias per monolith for clear color separation
        if monolith_idx in (0, 3):       # bull-biased
            trend = 1
        elif monolith_idx in (1, 4):     # bear-biased
            trend = 2
        else:
            trend = 0

        meta32 = pack_meta32(risk, shock, trend)
        taxonomy32 = make_taxonomy32(monolith_idx + 1, random.randint(0, 255))

        rows.append(
            {
                "symbol": f"SYNT-{i}",
                "name": f"Synthetic Asset {i}",
                "x": x,
                "y": y,
                "titan_taxonomy32": taxonomy32,
                "meta32": meta32,
            }
        )

    db.execute(
        text(
            """
            INSERT INTO assets (symbol, name, x, y, titan_taxonomy32, meta32)
            VALUES (:symbol, :name, :x, :y, :titan_taxonomy32, :meta32)
            """
        ),
        rows,
    )
    db.commit()
    print("OK: seeded assets =", n)


if __name__ == "__main__":
    main()
